{"version":3,"sources":["index.prefix.js","LogNative.js","Log.js","Observable.js","DataChannel.js","CryptoLib.js","WebRtcFactory.js","WebSocketFactory.js","Services.js","Synchronizer.js","Timers.js","Version.js","Time.js","ArrayUtils.js","HashMap.js","HashSet.js","LimitIterable.js","Queue.js","SortedList.js","Assert.js","BufferUtils.js","SerialBuffer.js","Crypto.js","CRC32.js","NumberUtils.js","MerkleTree.js","MerklePath.js","MerkleProof.js","PlatformUtils.js","StringUtils.js","Policy.js","Primitive.js","Hash.js","PrivateKey.js","PublicKey.js","KeyPair.js","RandomSecret.js","Commitment.js","CommitmentPair.js","Signature.js","PartialSignature.js","Address.js","Account.js","PrunedAccount.js","BasicAccount.js","Contract.js","HashedTimeLockedContract.js","VestingContract.js","AccountsTreeNode.js","AccountsTreeStore.js","SynchronousAccountsTreeStore.js","AccountsProof.js","AccountsTreeChunk.js","AccountsTree.js","SynchronousAccountsTree.js","PartialAccountsTree.js","Accounts.js","BlockHeader.js","BlockInterlink.js","BlockBody.js","BlockUtils.js","Subscription.js","Transaction.js","SignatureProof.js","BasicTransaction.js","ExtendedTransaction.js","TransactionsProof.js","TransactionCache.js","TransactionStoreEntry.js","TransactionStore.js","TransactionReceipt.js","Block.js","IBlockchain.js","BaseChain.js","BlockChain.js","HeaderChain.js","ChainProof.js","ChainData.js","ChainDataStore.js","MempoolTransactionSet.js","Mempool.js","BaseConsensusAgent.js","FullChain.js","FullConsensusAgent.js","FullConsensus.js","LightChain.js","LightConsensusAgent.js","LightConsensus.js","PartialLightChain.js","NanoChain.js","NanoConsensusAgent.js","NanoConsensus.js","NanoMempool.js","ConsensusDB.js","Consensus.js","Genesis.js","Protocol.js","Message.js","AddrMessage.js","BlockMessage.js","GetAddrMessage.js","GetBlocksMessage.js","HeaderMessage.js","InventoryMessage.js","MempoolMessage.js","PingMessage.js","PongMessage.js","RejectMessage.js","SignalMessage.js","SubscribeMessage.js","TxMessage.js","VersionMessage.js","VerAckMessage.js","AccountsProofMessage.js","GetAccountsProofMessage.js","ChainProofMessage.js","GetChainProofMessage.js","AccountsTreeChunkMessage.js","GetAccountsTreeChunkMessage.js","TransactionsProofMessage.js","GetTransactionsProofMessage.js","GetTransactionReceiptsMessage.js","TransactionReceiptsMessage.js","MessageFactory.js","WebRtcConnector.js","WebRtcDataChannel.js","WebRtcUtils.js","WebSocketConnector.js","WebSocketDataChannel.js","NetAddress.js","PeerId.js","PeerAddress.js","PeerAddressState.js","PeerAddressBook.js","CloseType.js","NetworkConnection.js","PeerChannel.js","NetworkAgent.js","PeerConnectionStatistics.js","PeerConnection.js","SignalProcessor.js","ConnectionPool.js","PeerScorer.js","NetworkConfig.js","Network.js","NetUtils.js","PeerKeyStore.js","Peer.js","Miner.js","Wallet.js","MultiSigWallet.js","WalletStore.js","IWorker.js","CryptoWorker.js","CryptoWorkerImpl.js","MinerWorker.js","MinerWorkerImpl.js","MinerWorkerPool.js","index.suffix.js"],"names":["module","exports","atob","require","btoa","JDB","fs","https","WebSocket","global","Class","register","clazz","prototype","constructor","name","LogNative","[object Object]","this","_global_level","Log","INFO","_tag_levels","_chalk","tag","level","args","isLoggable","unshift","prefix","Level","toStringTag","Date","toTimeString","substr","chalk","ERROR","console","log","red","join","WARNING","yellow","cyan","DEBUG","magenta","TRACE","trace","instance","_instance","native","_native","setLoggable","l","i","length","toString","msg","message","arguments","Array","slice","call","undefined","VERBOSE","ASSERT","d","bind","e","v","w","t","Observable","WILDCARD","_listeners","Map","type","callback","has","get","push","set","id","apply","observable","types","fire","on","DataChannel","super","_buffer","_msgType","_receivingTag","_sendingTag","_expectedMessagesByType","_timers","Timers","timeoutCallback","msgTimeout","MESSAGE_TIMEOUT","chunkTimeout","CHUNK_TIMEOUT","isArray","expectedMsg","ExpectedMessage","resetTimeout","_onTimeout","Error","clearAll","close","readyState","ReadyState","OPEN","buffer","SerialBuffer","byteLength","CHUNK_SIZE_MAX","_error","readUint8","effectiveChunkLength","readPos","chunk","read","NumberUtils","UINT8_MAX","chunkBuffer","messageSize","Message","peekLength","MESSAGE_SIZE_MAX","peekType","remainingBytes","writePos","write","clearTimeout","delete","Assert","that","_sendChunked","remaining","writeUint8","Uint8Array","sendChunk","CONNECTING","CLOSING","CLOSED","fromString","str","CryptoLib","crypto","getRandomValues","buf","TypeError","code","bytes","randomBytes","WebRtcFactory","configuration","rtcSessionDescriptionInit","rtcIceCandidateInit","WebSocketFactory","networkConfig","port","peerAddress","sslConfig","options","key","readFileSync","cert","httpsServer","createServer","req","res","writeHead","end","listen","Server","server","url","Services","provided","NONE","accepted","_provided","_accepted","services","FULL","LIGHT","NANO","Synchronizer","_queue","_working","fn","Promise","resolve","reject","_doWork","catch","job","shift","result","working","_timeouts","_intervals","waitTime","setTimeout","intervalTime","setInterval","clearInterval","Version","CODE","Time","offset","_offset","now","ArrayUtils","arr","Math","floor","random","uintarr","begin","clamp","min","max","len","byteOffset","list","k","n","indices","from","x","map","reverseRange","found","j","HashMap","fnHash","_hash","_map","_fnHash","o","hashCode","value","clear","keys","values","size","HashSet","collection","add","remove","Symbol","iterator","valueIterator","LimitIterable","it","limit","_iterator","_limit","count","next","done","Queue","hash","index","indexOf","splice","SortedList","sortedList","compare","_list","_compare","a","b","currentIndex","currentElement","round","_insertionIndex","pop","condition","BufferUtils","String","fromCharCode","string","charCodeAt","u8","TextDecoder","_ISO_8859_15_DECODER","decode","replace","num","_BASE64_LOOKUP","start","tmp","output","_tripletToBase64","extraBytes","parts","len2","_base64encodeChunk","PlatformUtils","isNodeJs","Buffer","_codePointTextDecoder","_base64fromByteArray","base64","c","toBase64","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","carry","base32","charmap","toUpperCase","split","forEach","char","hex","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","parseInt","viewA","viewB","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","DataView","_readPos","_writePos","subarray","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","pow","isUint64","readUint16","readUint32","readUint64","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","toAscii","isMultibyte","fromAscii","view","padding","isUint8","Crypto","lib","impl","IWorker","_workerImplementation","CryptoWorker","init","_workerSync","_workerAsync","startWorkerPoolForProxy","publicKeyType","publicKeySize","privateKey","_cryptoWorkerSync","publicKeyDerive","privateKeyType","privateKeySize","keyPairType","Object","keyPairDerive","privateKeyGenerate","publicKey","obj","signatureType","signatureSize","data","signatureCreate","signature","signatureVerify","block","transactionValid","timeNow","_cryptoWorkerAsync","blockVerify","Block","GENESIS","HASH","serialize","hashType","hashSize","blake2bSize","computeBlake2b","argon2dSize","computeArgon2d","sha256Size","computeSha256","randomnessSize","commitmentPairType","randomness","commitmentCreate","secret","commitment","randomSecretType","randomSecretSize","commitmentType","commitmentSize","partialSignatureType","partialSignatureSize","publicKeys","publicKeysHash","worker","publicKeyDelinearize","privateKeyDelinearize","publicKeysDelinearizeAndAggregate","combinedCommitment","delinearizedPartialSignatureCreate","commitments","commitmentsAggregate","partialSignatures","reduce","sigA","sigB","scalarsAdd","combinedSignature","aggregatePartialSignatures","concatTypedArrays","salt","iterations","kdf","headers","poolSize","partitions","promises","part","computeArgon2dBatch","pows","all","_pow","Hash","CRC32","table","_POLYNOMIAL","_table","_createTable","_hex_chars","crc","val","Number","isInteger","UINT16_MAX","UINT32_MAX","UINT64_MAX","MAX_SAFE_INTEGER","MerkleTree","_computeRoot","light","mid","left","right","leftHash","rightHash","MerklePath","nodes","some","MerklePathNode","_nodes","leafValue","leafHash","path","_compute","containsLeaf","inner","equals","leftLeaf","rightLeaf","root","node","concat","serializedSize","leftBitsSize","ceil","leftBits","unserialize","_compress","sum","every","_left","MerkleProof","hashes","operations","isUint16","_operations","leafValues","leafHashes","fnCompare","leaves","Set","sort","leafIndex","valueIndex","comparisonResult","compute","Operation","CONSUME_PROOF","isLeaf","h","CONSUME_INPUT","leftOps","leftPath","rightOps","rightPath","inputs","stack","proofNodes","op","hashStack","opBitsSize","opBits","opCount","countNodes","window","isBrowser","process","RTCPeerConnection","webkitRTCPeerConnection","navigator","onLine","test","isHex","str1","str2","Policy","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","BLOCK_TARGET_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Primitive","arg","_obj","toHex","algorithm","Algorithm","BLAKE2B","getSize","_algorithm","blake2b","blake2bSync","blake2bAsync","argon2d","ARGON2D","sha256","SHA256","SIZE","fromBase64","fromHex","NULL","PrivateKey","privateKeyUnserialize","privateKeySerialize","PublicKey","delinearizeAndAggregatePublicKeys","publicKeyUnserialize","publicKeySerialize","lightAsync","Address","fromHash","PeerId","KeyPair","locked","lockSalt","_locked","_lockedInternally","_lockSalt","_internalPrivateKey","keyPairPrivate","keyPairGenerate","hexBuf","roundsLog","rounds","encryptedKey","EXPORT_SALT_LENGTH","check","EXPORT_CHECKSUM_LENGTH","_otpKdf","keyPair","fromPrivateKey","pubHash","keyPairFromKeys","_privateKey","isLocked","_unlockedPrivateKey","_publicKey","keyPairPublic","unlockKey","wasLocked","unlock","encryptedSize","log2","EXPORT_KDF_ROUNDS","relock","overwrite","_otpPrivateKey","_clearUnlockedPrivateKey","derive","LOCK_KDF_ROUNDS","xor","RandomSecret","randomSecretUnserialize","randomSecretSerialize","Commitment","aggregateCommitments","commitmentUnserialize","commitmentSerialize","CommitmentPair","commitmentPairGenerate","commitmentPairFromValues","_secret","commitmentPairRandomSecret","_commitment","commitmentPairCommitment","SERIALIZED_SIZE","Signature","signatures","combinePartialSignatures","s","signatureUnserialize","signatureSerialize","PartialSignature","aggregateCommitment","partialSignatureUnserialize","partialSignatureSerialize","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","transaction","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","Type","BASIC","VESTING","HTLC","PrunedAccount","address","account","_address","_account","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Transaction","Flag","recipientType","withIncomingTransaction","create","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","hashAlgorithm","toUserFriendlyAddress","proof","ProofType","REGULAR_TRANSFER","hashDepth","preImage","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","AccountsTreeNode","TERMINAL","childrenSuffixes","childrenHashes","BRANCH","arg2","_prefix","isBranch","_childrenSuffixes","_childrenHashes","isTerminal","readVarLengthString","isTerminalType","terminalNode","isBranchType","childCount","childSuffix","childHash","childIndex","branchNode","writeVarLengthString","child","payloadSize","varLengthStringSize","_getChildIndex","suffix","find","filter","parent","getChildren","includes","is","ourChild","otherChild","AccountsTreeStore","jdb","createObjectStore","AccountsTreeStoreCodec","getObjectStore","store","JungleDB","createVolatileObjectStore","_store","put","startPrefix","relevantKeys","keyStream","KeyRange","lowerBound","tx","snapshot","inherit","enableWatchdog","synchronousTransaction","SynchronousAccountsTreeStore","truncate","commit","abort","stripDown","copy","valueEncoding","JSON_ENCODING","_syncStore","preload","expectedToBePresent","getSync","putSync","removeSync","AccountsProof","_index","children","isChildOf","getChildHash","getChild","rootNode","_getAccount","commonPrefix","childKey","childNode","AccountsTreeChunk","_proof","lastPrefix","tail","terminalNodes","head","SIZE_MAX","EMPTY","AccountsTree","getPersistent","_init","createVolatile","_synchronizer","getRootNode","_put","_insert","rootPath","newChild","newChildHash","newParent","withChild","newParentHash","_updateKeys","_prune","nodeHash","withAccount","childPrefix","withoutChild","hasSingleChild","getFirstChild","hasChildren","addresses","prefixes","_getAccountsProof","includeNode","subPrefixes","startsWith","getTerminalNodes","lastNode","getAccountsProof","SynchronousAccountsTree","PartialAccountsTree","_preloadAddresses","putBatch","finalizeBatch","getRootNodeSync","_updateHashes","_insertBatch","_updateKeysBatch","_pruneBatch","zeroHash","subHashes","currentHash","newNode","_complete","_lastPrefix","Status","ERR_INCORRECT_PROOF","_putLight","_mergeProof","ERR_UNMERGEABLE","complete","OK_COMPLETE","OK_UNFINISHED","upperBound","nodeChildren","proofNode","proofChildren","nextChild","getLastChild","insertedNode","proofChild","proofHash","missingPrefix","tree","ERR_HASH_MISMATCH","Accounts","accountsTree","_tree","bubble","genesisBlock","encodedAccounts","isEmpty","_commitBlockBody","body","height","TransactionCache","rootSync","accountsHash","getChunk","transactionCache","preloadAddresses","getAddresses","transactions","_processSenderAccounts","_processRecipientAccounts","_processContracts","toBePruned","senderAccount","_getSync","isToBePruned","revertBlockBody","_revertBlockBody","accountType","partialTree","senderType","recipientAccount","reverse","withContractCommand","prunedAccounts","accIdx","findIndex","acc","_rewardMiner","txFees","coinbaseTransaction","ExtendedTransaction","minerAddr","blockRewardAt","BlockHeader","prevHash","_prevHash","interlinkHash","_interlinkHash","bodyHash","_bodyHash","_accountsHash","_nBits","_height","_timestamp","_nonce","_version","nBits","timestamp","nonce","version","CURRENT_VERSION","isHash","BlockUtils","isValidCompact","SUPPORTED_VERSIONS","isProofOfWork","target","prevHeader","hard","compactToTarget","difficulty","compactToDifficulty","V1","BlockInterlink","_hashes","repeatBits","_repeatBits","compressed","_compressed","repeatBitsSize","lastHash","computeRoot","BlockBody","extraData","_minerAddr","_extraData","_transactions","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","previousTx","compareBlockOrder","previousAcc","getMerkleLeafs","transactionCount","compact","isFinite","isNaN","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","actualTime","adjustment","averageDifficulty","nextTarget","Subscription","ADDRESSES","minFeePerByte","MIN_FEE","_addresses","_minFeePerByte","addAll","additionalSize","ANY","contains","BLOCKS_ONLY","format","flags","_format","_senderType","_recipientType","_value","_fee","_validityStartHeight","_flags","_data","FORMAT_MAP","serializedContentSize","_valid","_verify","verifyOutgoingTransaction","recCompare","senderCompare","feePerByte","flag","Format","EXTENDED","ALL","signerKey","merklePath","_merklePath","_signature","merkleRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","dataSize","proofSize","TransactionsProof","blockOrder","_blockOrder","shiftBlock","removeAll","missingBlocks","blockFromOrder","blocks","TransactionStoreEntry","transactionHash","blockHash","_transactionHash","_blockHeight","_blockHash","senderKey","recipientKey","entries","transactionKey","TransactionStore","TransactionStoreCodec","createIndex","only","indexedTransactions","fromBlock","indexedTransaction","toJSON","fromJSON","TransactionReceipt","_header","_interlink","_body","header","interlink","time","isLight","areWorkersAsync","valid","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","depthDiff","getTargetDepth","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","nextTargetDepth","hashAsync","IBlockchain","headHash","BaseChain","includeForks","chainData","getChainData","onMainChain","getBlockAt","headData","_mainChain","tailHeight","tailData","getChainDataAt","prevData","totalDifficulty","getNextTarget","chain","BaseChainSnapshot","_prove","m","delta","BlockChain","alpha","_getSuperChain","merge","_isGoodSuperChain","_getHeaderChain","ChainProof","headPow","toLight","reference","getBlock","superchain","_hasSuperQuality","underlyingLength","_isLocallyGood","superLength","HeaderChain","failOnBadness","suffixTail","prefixHead","chains","getSuperChains","deletedBlockHeights","referenceBlock","numBlocksToDelete","candidateBlock","candidateTarget","newPrefix","proof1","proof2","lca","lowestCommonAncestor","score1","NanoChain","_getProofScore","score2","counts","maxScore","score","_head","chain1","chain2","merged","i1","i2","block1","block2","_blocks","isSuccessorOf","denseSuffix","denseSuffixHead","_headers","superChains","_suffix","_chains","isAnchored","_verifyDifficulty","denseChain","totalDifficulties","headIndex","tailIndex","checkBlock","ChainData","_totalDifficulty","_totalWork","_onMainChain","totalWork","ChainDataStore","ChainDataStoreCodec","_createIndexes","candidates","Query","eq","lower","maxValues","minValues","forward","within","sortNumber","MempoolTransactionSet","sortedTransactions","Mempool","blockchain","accounts","_blockchain","_accounts","_transactionsByHash","_transactionSetByAddress","_evictTransactions","_pushTransaction","ReturnCode","KNOWN","TRANSACTION_RELAY_FEE_MIN","numBelowFeePerByte","FREE_TRANSACTIONS_PER_SENDER_MAX","FEE_TOO_LOW","INVALID","tmpAccount","copyAndAdd","ACCEPTED","maxSize","Infinity","txSize","getTransactions","gatherToBePrunedAccounts","__evictTransactions","BaseConsensusAgent","peer","_peer","_synced","_knownObjects","InvVector","BLOCK","_objectsToRequest","_objectsInFlight","_objectsThatFlew","_objectsProcessing","_remoteSubscription","_waitingInvVectors","_sendWaitingInvVectors","TRANSACTION_RELAY_INTERVAL","_waitingFreeInvVectors","_sendFreeWaitingInvVectors","FREE_TRANSACTION_RELAY_INTERVAL","channel","_onInv","_onBlock","_onHeader","_onTx","_onNotFound","_onSubscribe","_onGetData","_onGetHeader","_onClose","matchesBlock","vector","inv","dequeueMulti","BaseInventoryMessage","VECTORS_MAX_COUNT","invVectors","FREE_TRANSACTION_SIZE_PER_INTERVAL","dequeue","matchesTransaction","fromTransaction","enqueue","subscription","vectors","unknownObjects","_shouldRequestData","_getBlock","_onKnownBlockAnnounced","_onNewBlockAnnounced","TRANSACTION","_getTransaction","_onKnownTransactionAnnounced","_onNewTransactionAnnounced","REQUEST_THRESHOLD","_requestData","REQUEST_THROTTLE","_onNoUnknownObjects","vectorsMaxCount","_doRequestData","_noMoreData","REQUEST_TIMEOUT","getData","transactionPromises","_onObjectReceived","_processBlock","_onObjectProcessed","_processHeader","_processTransaction","_onAllObjectsReceived","_onAllObjectsProcessed","notFound","synced","FullChain","transactionStore","_time","_snapshots","_snapshotOrder","_transactionCache","_transactionStore","_blockKnownCount","_blockInvalidCount","_blockOrphanCount","_blockExtendedCount","_blockRebranchedCount","_blockForkedCount","_headHash","getHead","getBlocks","prependBlocks","realDifficulty","putChainData","setHead","initialize","_pushBlock","OK_KNOWN","ERR_INVALID","ERR_ORPHAN","_extend","OK_EXTENDED","_rebranch","OK_REBRANCHED","OK_FORKED","accountsTx","commitBlock","transactionStoreTx","commitCombined","_saveSnapshot","pushBlock","_extendChainProof","forkChain","forkHashes","curData","curHash","transactionCacheTx","clone","revertBlock","numMissingBlocks","chainTx","forkData","_getChainProof","_getSnapshot","getAccountsTreeChunk","matches","addressesSet","transactionReceipts","entriesBySender","getBySender","entriesByRecipient","getByRecipient","entry","txStoreEntry","async","transactionsTx","currentBlock","oldestHash","oldestSnapshot","blockForkedCount","blockRebranchedCount","blockExtendedCount","blockOrphanCount","blockInvalidCount","blockKnownCount","FullConsensusAgent","mempool","_mempool","_syncing","_numBlocksExtending","_numBlocksForking","_forkHead","_failedSyncs","_syncTarget","_onGetBlocks","_onGetChainProof","_onGetAccountsProof","_onGetAccountsTreeChunk","_onGetTransactionsProof","_onGetTransactions","_onMempool","isFullNode","_syncFinished","SYNC_ATTEMPTS_MAX","CloseType","BLOCKCHAIN_SYNC_FAILED","_requestBlocks","subscribe","delay","MEMPOOL_DELAY_MIN","MEMPOOL_DELAY_MAX","maxInvSize","isExpectingMessage","INV","expectMessage","GET_BLOCKS_TIMEOUT","locators","step","isNanoNode","getTransaction","syncBlockchain","RECEIVED_INVALID_BLOCK","_onOrphanBlock","timeoutExists","_outOfSync","RESYNC_THROTTLE","pushTransaction","TX","RejectMessage","Code","REJECT_INSUFFICIENT_FEE","REJECT_INVALID","startBlock","locator","GETBLOCKS_VECTORS_MAX","direction","GetBlocksMessage","Direction","FORWARD","getChainProof","chainProof","accountsProof","getTransactionsProof","transactionsProof","accountsTreeChunk","getTransactionReceiptsByAddress","TransactionReceiptsMessage","RECEIPTS_MAX_COUNT","receipts","allTransactions","MEMPOOL_ENTRIES_MAX","MEMPOOL_THROTTLE","FullConsensus","network","_network","_agents","_established","_syncPeer","_onPeerJoined","_onPeerLeft","agent","relayBlock","relayTransaction","_onPeerSynced","_onPeerOutOfSync","_syncBlockchain","SYNC_THROTTLE","randomElement","established","LightChain","partialChain","PartialLightChain","mainChain","LightConsensusAgent","_partialChain","_catchup","_orphanedBlocks","_busy","_accountsRequest","_requestedChainProof","_onChainProof","_onAccountsTreeChunk","getHeader","err","DID_NOT_GET_REQUESTED_HEADER","_initChainProofSync","state","State","PROVE_CHAIN","_requestChainProof","PROVE_ACCOUNTS_TREE","_requestAccountsTree","PROVE_BLOCKS","_requestProofBlocks","COMPLETE","_applyOrphanedBlocks","ABORTED","ABORTED_SYNC","CHAIN_PROOF","GET_CHAIN_PROOF_TIMEOUT","CHAINPROOF_REQUEST_TIMEOUT","CHAINPROOF_CHUNK_TIMEOUT","pushProof","INVALID_CHAIN_PROOF","getMissingAccountsPrefix","ACCOUNTS_TREE_CHUNK","GET_ACCOUNTS_TREE_CHUNK_TIMEOUT","ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT","hasChunk","INVALID_ACCOUNTS_TREE_CHUNK","rootHash","ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH","pushAccountsTreeChunk","_lastChainHeight","proofHeadHeight","getBlockLocators","numBlocksNeeded","_chain","_headerRequest","HEADER","GET_HEADER_TIMEOUT","NanoConsensusAgent","requestedHash","RECEIVED_WRONG_HEADER","LightConsensus","agents","_state","_partialTree","_accountsTx","_proofHead","_pushProof","toDo","manyPow","knownBlock","suffixBlocks","currentProof","isBetterProof","_acceptProof","tailEnd","_pushLightBlock","partialAccountsTree","_pushBlockInternal","proofHeadHash","_pushBlockBackwards","_pushHeadBlock","_prepend","needsMoreBlocks","pushChunk","numBlocks","_pushHeader","_transactionsRequest","_blockRequest","_requestedTransactionReceipts","_onAccountsProof","_onTransactionsProof","_onTransactionReceipts","_localSubscription","fromAddresses","SUBSCRIPTION_CHANGE_THROTTLE","pushHeader","status","RECEIVED_INVALID_HEADER","RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION","_getAccounts","ACCOUNTS_PROOF","GET_ACCOUNTS_PROOF_TIMEOUT","ACCOUNTSPROOF_REQUEST_TIMEOUT","hasProof","INVALID_ACCOUNTS_PROOF","ACCOUNTS_PROOF_ROOT_HASH_MISMATCH","getAccount","INCOMPLETE_ACCOUNTS_PROOF","_getTransactionsProof","TRANSACTIONS_PROOF","GET_TRANSACTIONS_PROOF_TIMEOUT","TRANSACTIONSPROOF_REQUEST_TIMEOUT","INVALID_TRANSACTION_PROOF","getTransactionReceipts","TRANSACTION_RECEIPTS","GET_TRANSACTION_RECEIPTS_TIMEOUT","TRANSACTIONS_REQUEST_TIMEOUT","_getFullBlock","NOT_FOUND","INVALID_BLOCK","NanoConsensus","_onHeadChanged","subscribeAccounts","includedTransactions","changeHead","getAccounts","knowsBlock","relayed","getFullBlock","NanoMempool","maxCount","txHash","ConsensusDB","dbName","VERSION","initPersistent","connect","Consensus","netconfig","NetworkConfig","getDefault","prepareSyncCryptoWorker","db","getFull","Network","getLight","initVolatile","difficultyToCompact","Protocol","DUMB","WS","RTC","pos","readVarUint","magic","checksum","MAGIC","_writeChecksum","writeVarUint","varUintSize","GET_DATA","GET_HEADER","GET_BLOCKS","MEMPOOL","REJECT","SUBSCRIBE","ADDR","GET_ADDR","PING","PONG","SIGNAL","GET_CHAIN_PROOF","GET_ACCOUNTS_PROOF","GET_ACCOUNTS_TREE_CHUNK","GET_TRANSACTIONS_PROOF","GET_TRANSACTION_RECEIPTS","VERACK","AddrMessage","PeerAddress","addr","_setChecksum","BlockMessage","_block","GetAddrMessage","protocolMask","serviceMask","_protocolMask","_serviceMask","_locators","_maxInvSize","_direction","BACKWARD","HeaderMessage","_vectors","InvMessage","GetDataMessage","GetHeaderMessage","NotFoundMessage","MempoolMessage","PingMessage","PongMessage","messageType","reason","_messageType","_code","_reason","REJECT_MALFORMED","REJECT_OBSOLETE","REJECT_DOUBLE","REJECT_DUST","SignalMessage","senderId","recipientId","ttl","payload","hasPayload","_senderId","_recipientId","_ttl","_payload","_senderPubKey","toPeerId","UNROUTABLE","TTL_EXCEEDED","SubscribeMessage","_subscription","TxMessage","_transaction","_accountsProof","hasAccountsProof","VersionMessage","genesisHash","challengeNonce","_peerAddress","_genesisHash","_challengeNonce","CHALLENGE_SIZE","VerAckMessage","AccountsProofMessage","GetAccountsProofMessage","ChainProofMessage","GetChainProofMessage","AccountsTreeChunkMessage","_accountsTreeChunk","GetAccountsTreeChunkMessage","_startPrefix","TransactionsProofMessage","GetTransactionsProofMessage","GetTransactionReceiptsMessage","_transactionReceipts","receipt","MessageFactory","CLASSES","WebRtcConnector","_networkConfig","_connectors","signalChannel","protocol","peerId","connector","OutboundPeerConnector","conn","_onConnection","CONNECT_TIMEOUT","isUnroutable","isTtlExceeded","isValidSignal","JSON","parse","InboundPeerConnector","onSignal","PeerConnector","_signalChannel","_peerId","randomUint32","_rtcConnection","newPeerConnection","rtcConfig","onicecandidate","_onIceCandidate","_lastIceCandidate","_iceCandidateQueue","signal","sdp","setRemoteDescription","newSessionDescription","then","createAnswer","description","_onDescription","_handleCandidateQueue","candidate","_addIceCandidate","newIceCandidate","remoteDescription","addIceCandidate","stringify","SIGNAL_TTL_INITIAL","event","_signal","setLocalDescription","localDescription","WebRtcDataChannel","netAddress","WebRtcUtils","candidateToNetAddress","NetworkConnection","webRtcConfig","createDataChannel","binaryType","onopen","_onDataChannel","createOffer","offer","ondatachannel","nativeChannel","ordered","_channel","onmessage","_onMessage","onclose","onerror","Blob","reader","FileReader","onloadend","readAsArrayBuffer","send","NetAddress","fromIP","WebSocketConnector","_wss","newWebSocketServer","ws","timeoutKey","newWebSocket","host","handshakeTimeout","_socket","remoteAddress","WebSocketDataChannel","_ws","ip","saneIp","NetUtils","sanitizeIP","_ip","UNSPECIFIED","UNKNOWN","isPseudo","isPrivateIP","distance","_protocol","_services","_netAddress","_distance","WsPeerAddress","RtcPeerAddress","DumbPeerAddress","isPrivate","_signatureVerified","isSeed","age","PeerAddressBook","MAX_AGE_WEBSOCKET","MAX_AGE_WEBRTC","MAX_AGE_DUMB","publicKeyHex","_host","_port","hostGloballyReachable","PeerAddressState","NEW","lastConnected","bannedUntil","banBackoff","INITIAL_FAILED_BACKOFF","_signalRouter","SignalRouter","_failedAttempts","_closeTypes","signalRouter","maxFailedAttempts","MAX_FAILED_ATTEMPTS_RTC","MAX_FAILED_ATTEMPTS_WS","failedAttempts","bestRoute","updateBestRoute","BANNED","isBanningType","isFailingType","FAILED","TRIED","ESTABLISHED","_bestRoute","_routes","oldRoute","newRoute","SignalRoute","deleteRoute","route","MAX_DISTANCE","_peerIds","SEED_PEERS","_housekeeping","HOUSEKEEPING_INTERVAL","localPeerAddress","withoutId","_get","peerAddressState","maxAddresses","exceedsAge","peerAddresses","newAddresses","_add","MAX_SIZE","MAX_TIMESTAMP_DRIFT","knownAddress","addRoute","_removeBySignalChannel","_ban","MAX_FAILED_BACKOFF","_remove","deleteBestRoute","hasRoute","duration","DEFAULT_BAN_TIME","deleteAllRoutes","unbannedAddresses","knownAddressesCount","seed","closingType","SENDING_PING_MESSAGE_FAILED","SENDING_OF_VERSION_MESSAGE_FAILED","DUPLICATE_CONNECTION","PEER_IS_BANNED","CONNECTION_LIMIT_PER_IP","MANUAL_NETWORK_DISCONNECT","MANUAL_WEBSOCKET_DISCONNECT","MAX_PEER_COUNT_REACHED","PEER_CONNECTION_RECYCLED","PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE","ADDR_MESSAGE_TOO_LARGE","INVALID_ADDR","ADDR_NOT_GLOBALLY_REACHABLE","INVALID_SIGNAL_TTL","INVALID_SIGNATURE","INCOMPATIBLE_VERSION","INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE","INVALID_SIGNATURE_IN_VERACK_MESSAGE","DIFFERENT_GENESIS_BLOCK","INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE","UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE","CLOSED_BY_REMOTE","PING_TIMEOUT","CONNECTION_FAILED","NETWORK_ERROR","VERSION_TIMEOUT","VERACK_TIMEOUT","_bytesSent","_bytesReceived","_inbound","_closed","_lastError","_id","_instanceCount","_onError","logAddress","_isChannelClosing","_isChannelClosed","_isChannelOpen","connType","_close","bytesSent","bytesReceived","inbound","outbound","closed","PeerChannel","connection","_conn","rawMsg","FAILED_TO_PARSE_MESSAGE_TYPE","Event","_send","ascending","NetworkAgent","_knownAddresses","_versionReceived","_verackReceived","_versionSent","_verackSent","_versionAttempts","_peerAddressVerified","_peerChallengeNonce","_pingTimes","_onVersion","_onVerAck","_onAddr","_onGetAddr","_onPing","_onPong","filteredAddresses","RELAY_THROTTLE","_sendVerAck","HANDSHAKE_TIMEOUT","VERSION_ATTEMPTS_MAX","handshake","VERSION_RETRY_DELAY","_canAcceptMessage","isCompatible","verifySignature","storedAddress","Peer","_finishHandshake","verack","_checkConnectivity","CONNECTIVITY_CHECK_INTERVAL","ANNOUNCE_ADDR_INTERVAL","_requestAddresses","getAddr","globallyReachable","query","ping","pong","startTime","PeerConnectionStatistics","_latencies","_messages","latency","msgType","latencyMedian","median","PeerConnection","peerConnection","PeerConnectionState","networkConnection","_networkConnection","_peerChannel","_networkAgent","_closingType","_score","_establishedSince","_statistics","CONNECTED","peerChannel","networkAgent","NEGOTIATING","addLatency","addMessage","establishedSince","ageEstablished","statistics","SignalProcessor","rtcConnector","_rtcConnector","_forwards","SignalStore","myPeerId","signalForwarded","senderAddr","getByPeerId","unroutable","getChannelByPeerId","_maxSize","ForwardedSignal","oldest","lastSeen","SIGNAL_MAX_AGE","toDelete","dequeueUntil","dSignal","ConnectionPool","_connectionsByPeerAddress","_connectionsByNetAddress","_wsConnector","peerAddr","_onConnectError","_peerCountWs","_peerCountRtc","_peerCountDumb","_peerCountFull","_peerCountLight","_peerCountNano","_connectingCount","_inboundCount","_signalProcessor","_allowInboundExchange","getConnectionByPeerAddress","_removeNetAddress","peerConnections","peerCountFull","isBanned","getConnectionsByNetAddress","PEER_COUNT_PER_IP_MAX","peerCount","PEER_COUNT_MAX","_hasPriority","isEstablished","_checkOutboundConnectionRequest","getOutbound","connecting","getInbound","_checkConnection","_addNetAddress","_checkHandshake","_onHandshake","_updateConnectedPeerCount","kbTransferred","toFixed","isLightNode","peerCountWs","peerCountRtc","peerCountDumb","peerCountLight","peerCountNano","connectingCount","allowInboundExchange","PeerScorer","connections","_connections","_connectionScores","numAddresses","minCandidates","_scoreAddress","scores","canConnect","_scoreProtocol","_scoreServices","_getMinAge","_scoreConnection","reset","scoreAge","_scoreConnectionAge","scoreType","scoreProtocol","BEST_PROTOCOL_WS_DISTRIBUTION","medianDelay","scoreSpeed","bestAge","maxAge","BEST_AGE_FULL","BEST_AGE_LIGHT","MAX_AGE_LIGHT","BEST_AGE_NANO","MAX_AGE_NANO","MIN_AGE_FULL","MIN_AGE_LIGHT","MIN_AGE_NANO","connectionScores","lowestConnectionScore","supportsWebRTC","RtcNetworkConfig","DumbNetworkConfig","_keyPair","PeerKeyStore","generate","WsNetworkConfig","_key","_cert","_sslConfig","_rtcConfig","iceServers","urls","_autoConnect","_backoff","CONNECT_BACKOFF_INITIAL","_backedOff","_relayAddresses","_checkPeerCount","_onPeersChanged","_onRecyclingRequest","_scorer","_houseKeepingIntervalId","disconnect","disconnectWebSocket","_updateTimeOffset","recycleConnections","SCORE_INBOUND_EXCHANGE","PEER_COUNT_RELAY","relayAddresses","PEER_COUNT_DESIRED","CONNECTING_COUNT_MAX","pickAddress","oldBackoff","CONNECT_BACKOFF_MAX","connectOutbound","offsets","timeOffset","offsetsLength","TIME_OFFSET_MAX","scoreConnections","PEER_COUNT_RECYCLING_ACTIVE","percentageToRecycle","connectionsToRecycle","peerCountWebSocket","peerCountWebRtc","peerCountConnecting","ADDRESS_UPDATE_DELAY","isLocalIP","isIPv4Address","subnet","IPv4_PRIVATE_NETWORK","isIPv4inSubnet","isIPv6Address","toLowerCase","_normalizeIP","subIp","mask","_IPv4toLong","isEmbeddedIPv4","innerEmpty","IP_BLACKLIST","emptyIndex","necessaryAddition","maxZeroSeqStart","maxZeroSeqLength","curZeroSeqStart","curZeroSeqLength","KEY_DATABASE","PeerKeyStoreCodec","_timeOffset","_setNetAddress","Miner","minerAddress","_lastHashrate","_hashrateWorker","_hashrate","_lastHashCounts","_totalHashCount","_lastElapsed","_totalElapsed","_workerPool","MinerWorkerPool","hardwareConcurrency","threads","cores","cpus","throttleAfter","_onWorkerShare","_mempoolChanged","_restarting","_lastRestart","_submittingBlock","_startWork","_updateHashrate","_retry","getNextBlock","startMiningOnBlock","stopWork","startWork","noncesPerRun","MIN_TIME_ON_BLOCK","_getNextInterlink","_getNextBody","_getNextHeader","commitBlockBody","_getNextTimestamp","interlinkSize","getMetadataSize","getTransactionsForBlock","stop","elapsed","MOVING_AVERAGE_MAX_SIZE","oldestElapsed","oldestHashCount","hashrate","throttleWait","cycleWait","runsPerCycle","Wallet","fromEncrypted","exportEncrypted","lock","MultiSigWallet","minSignatures","multiSigKeys","k_combinations","numPublicKeys","serialBuf","_loadMultiSig","_minSignatures","_publicKeys","exportedSize","pubKey","encryptedExportedSize","recipientAddr","aggregatedCommitment","aggregatedPublicKey","fromPartialSignatures","multiSig","WalletStore","_jdb","_walletStore","_multiSigStore","WALLET_DATABASE","WalletStoreCodec","MULTISIG_WALLET_DATABASE","defaultAddress","defaultWallet","setDefault","base64Address","loadEncrypted","loadPlain","wallet","exportPlain","Proxy","workerScript","_workersSupported","Nimiq","_path","createProxy","Worker","URL","createObjectURL","Pool","startWorkerForProxy","command","self","postMessage","_insideWebWorker","WorkerGlobalScope","_global","baseClazz","stubBaseOnMessage","_moduleLoadedCallbacks","document","getElementsByTagName","script","createElement","src","ret","onreadystatechange","onload","appendChild","proxyClass","_name","_messageId","_worker","_receive","_waiting","_invoke","cb","error","WorkerProxy","wasm","funcName","getOwnPropertyNames","Stub","finalRes","_result","asm","__dirname","moduleSettings","preRun","importScripts","_loadBrowserScript","WebAssembly","toUint8Array","u","readFile","wasmBinary","xhr","XMLHttpRequest","open","responseType","response","_onmessage","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","_size","_step","destroy","workerPromises","createdWorkers","idx","input","ARGON2_HASH_SIZE","BLAKE2_HASH_SIZE","SHA256_HASH_SIZE","PUBLIC_KEY_SIZE","PRIVATE_KEY_SIZE","MULTISIG_RANDOMNESS_SIZE","SIGNATURE_SIZE","PARTIAL_SIGNATURE_SIZE","SIGNATURE_HASH_SIZE","CryptoWorkerImpl","_superInit","importWasm","importScript","memoryStart","Module","_get_static_memory_start","memorySize","_get_static_memory_size","_pubKeyPointer","_pubKeyBuffer","HEAP8","_privKeyPointer","_privKeyBuffer","_signaturePointer","_signatureBuffer","_messagePointer","_messageBuffer","stackPtr","stackSave","wasmOut","stackAlloc","wasmIn","HEAPU8","_nimiq_blake2","stackRestore","_nimiq_argon2","stackTmp","_nimiq_sha256","wasmSalt","_nimiq_kdf","_ed25519_public_key_derive","fill","wasmOutCommitment","wasmOutSecret","_ed25519_create_commitment","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","concatenatedCommitments","wasmInCommitments","_ed25519_aggregate_commitments","aggCommitments","concatenatedPublicKeys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_delinearize_public_key","delinearizedPublicKey","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","wasmInPrivateKey","_ed25519_derive_delinearized_private_key","delinearizedPrivateKey","wasmInSecret","wasmInCommitment","wasmInMessage","_ed25519_delinearized_partial_sign","partialSignature","messageLength","_ed25519_sign","_ed25519_verify","blockSerialized","prepareForWorkerUse","MinerWorker","blockHeader","minNonce","maxNonce","MinerWorkerImpl","_malloc","_nimiq_argon2_target","_free","_miningEnabled","_activeNonces","_noncesPerRun","_observable","_shareCompact","_runsPerCycle","_cycleWait","_superUpdateToSize","nimiq_node","multiMine","fail","nimiq_argon2_target_async","nonces","off","shareCompact","_startMiner","nonceRange","_singleMiner","newMin","newRange"],"mappings":"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","file":"node.js","sourcesContent":["module.exports = {};\nconst atob = require('atob');\nconst btoa = require('btoa');\nconst JDB = require('jungle-db');\nconst fs = require('fs');\nconst https = require('https');\nconst WebSocket = require('ws');\n\nglobal.Class = {\n    register: clazz => {\n        module.exports[clazz.prototype.constructor.name] = clazz;\n    }\n};\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        this._chalk = require('chalk');\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        this._tag_levels[tag] = level;\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (!this.isLoggable(tag, level)) return;\n        if (tag && tag.name) tag = tag.name;\n        if (tag) args.unshift(tag + ':');\n        let prefix = `[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}] `;\n        const chalk = this._chalk;\n        if (level >= Log.ERROR) {\n            console.log(prefix + chalk.red(args.join(' ')));\n        } else if (level >= Log.WARNING) {\n            console.log(prefix + chalk.yellow(args.join(' ')));\n        } else if (level >= Log.INFO) {\n            console.log(prefix + chalk.cyan(args.join(' ')));\n        } else if (level >= Log.DEBUG) {\n            console.log(prefix + chalk.magenta(args.join(' ')));\n        } else if (level <= Log.TRACE) {\n            console.trace(prefix + args.join(' '));\n        } else {\n            console.log(prefix + args.join(' '));\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, level);\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = l;\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n/**\n * @enum {number}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.TRACE:\n                return 'T';\n            case Log.VERBOSE:\n                return 'V';\n            case Log.DEBUG:\n                return 'D';\n            case Log.INFO:\n                return 'I';\n            case Log.WARNING:\n                return 'W';\n            case Log.ERROR:\n                return 'E';\n            case Log.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","class Observable {\n    /**\n     * @returns {string}\n     * @constant\n     */\n    static get WILDCARD() {\n        return '*';\n    }\n\n    constructor() {\n        /** @type {Map.<string, Array.<Function>>} */\n        this._listeners = new Map();\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) {\n        if (!this._listeners.has(type)) {\n            this._listeners.set(type, [callback]);\n            return 0;\n        } else {\n            return this._listeners.get(type).push(callback) - 1;\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) {\n        if (!this._listeners.has(type) || !this._listeners.get(type)[id]) return;\n        delete this._listeners.get(type)[id];\n    }\n\n    /**\n     * @param {string} type\n     * @param {...*} args\n     */\n    fire(type, ...args) {\n        // Notify listeners for this event type.\n        if (this._listeners.has(type)) {\n            for (const i in this._listeners.get(type)) {\n                const listener = this._listeners.get(type)[i];\n                listener.apply(null, args);\n            }\n        }\n\n        // Notify wildcard listeners. Pass event type as first argument\n        if (this._listeners.has(Observable.WILDCARD)) {\n            for (const i in this._listeners.get(Observable.WILDCARD)) {\n                const listener = this._listeners.get(Observable.WILDCARD)[i];\n                listener.apply(null, arguments);\n            }\n        }\n    }\n\n    /**\n     * @param {Observable} observable\n     * @param {...string} types\n     */\n    bubble(observable, ...types) {\n        for (const type of types) {\n            let callback;\n            if (type == Observable.WILDCARD) {\n                callback = function() {\n                    this.fire.apply(this, arguments);\n                };\n            } else {\n                callback = function() {\n                    this.fire.apply(this, [type, ...arguments]);\n                };\n            }\n            observable.on(type, callback.bind(this));\n        }\n    }\n}\nClass.register(Observable);\n","/**\n * @abstract\n */\nclass DataChannel extends Observable {\n    constructor() {\n        super();\n\n        // Buffer for chunked messages.\n        // XXX We currently only support one chunked message at a time.\n        /** @type {SerialBuffer} */\n        this._buffer = null;\n\n        /** @type {Message.Type} */\n        this._msgType = 0;\n\n        /** @type {number} */\n        this._receivingTag = -1;\n\n        /** @type {number} */\n        this._sendingTag = 0;\n\n        /** @type {Map.<Message.Type, ExpectedMessage>} */\n        this._expectedMessagesByType = new Map();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._expectedMessagesByType.has(type);\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        if (!Array.isArray(types)) {\n            types = [types];\n        }\n\n        if (types.length === 0) return;\n\n        const expectedMsg = new ExpectedMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n        for (const type of types) {\n            this._expectedMessagesByType.set(type, expectedMsg);\n        }\n\n        // Set timers for any of the expected types.\n        this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), chunkTimeout);\n        this._timers.resetTimeout(`msg-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), msgTimeout);\n    }\n\n    /**\n     * @abstract\n     */\n\n    /* istanbul ignore next */\n    close() { throw new Error('Not implemented'); }\n\n    /**\n     * @protected\n     */\n    _onClose() {\n        this._timers.clearAll();\n        this.fire('close', this);\n    }\n\n    /**\n     * @param {string} msg\n     * @private\n     */\n    _error(msg) {\n        this.fire('error', msg, this);\n        Log.e(DataChannel, msg);\n        this.close();\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     */\n    _onMessage(msg) {\n        try {\n            // Drop message if the channel is not open.\n            if (this.readyState !== DataChannel.ReadyState.OPEN) {\n                return;\n            }\n\n            // Drop empty messages.\n            const buffer = new SerialBuffer(msg);\n            if (buffer.byteLength === 0) {\n                return;\n            }\n\n            // Chunk is too large.\n            if (buffer.byteLength > DataChannel.CHUNK_SIZE_MAX) {\n                this._error('Received chunk larger than maximum chunk size, discarding');\n                return;\n            }\n\n            const tag = buffer.readUint8();\n\n            // Buffer length without tag.\n            const effectiveChunkLength = buffer.byteLength - buffer.readPos;\n            const chunk = buffer.read(effectiveChunkLength);\n\n            // Detect if this is a new message.\n            if (this._buffer === null && tag === (this._receivingTag + 1) % NumberUtils.UINT8_MAX) {\n                const chunkBuffer = new SerialBuffer(chunk);\n                const messageSize = Message.peekLength(chunkBuffer);\n\n                if (messageSize > DataChannel.MESSAGE_SIZE_MAX) {\n                    this._error(`Received message with excessive message size ${messageSize} > ${DataChannel.MESSAGE_SIZE_MAX}`);\n                    return;\n                }\n\n                this._buffer = new SerialBuffer(messageSize);\n                this._receivingTag = tag;\n                this._msgType = Message.peekType(chunkBuffer);\n            }\n\n            if (this._buffer === null) {\n                Log.e(DataChannel, `Message does not start next tag ${this._receivingTag + 1} (but ${tag}), but buffer is null`);\n                return;\n            }\n\n            // Currently, we only support one message at a time.\n            if (tag !== this._receivingTag) {\n                this._error(`Received message with wrong message tag ${tag}, expected ${this._receivingTag}`);\n                return;\n            }\n\n            let remainingBytes = this._buffer.byteLength - this._buffer.writePos;\n\n            // Mismatch between buffer sizes.\n            if (effectiveChunkLength > remainingBytes) {\n                this._error('Received chunk larger than remaining bytes to read, discarding');\n                return;\n            }\n\n            // Write chunk and subtract remaining byte length.\n            this._buffer.write(chunk);\n            remainingBytes -= effectiveChunkLength;\n\n            const expectedMsg = this._expectedMessagesByType.get(this._msgType);\n            if (remainingBytes === 0) {\n                if (expectedMsg) {\n                    this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n                    this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n                    for (const type of expectedMsg.types) {\n                        this._expectedMessagesByType.delete(type);\n                    }\n                }\n\n                const msg = this._buffer.buffer;\n                this._buffer = null;\n                this.fire('message', msg, this);\n            } else {\n                // Set timeout.\n                if (expectedMsg) {\n                    this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), expectedMsg.chunkTimeout);\n                }\n                this.fire('chunk', this._buffer);\n            }\n        } catch (e) {\n            this._error(`Error occurred while parsing incoming message, ${e.message}`);\n        }\n    }\n\n    /**\n     * @param {ExpectedMessage} [expectedMsg]\n     * @private\n     */\n    _onTimeout(expectedMsg) {\n        if (expectedMsg) {\n            this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n            this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n\n            for (const type of expectedMsg.types) {\n                this._expectedMessagesByType.delete(type);\n            }\n\n            expectedMsg.timeoutCallback();\n        }\n\n        Log.e(DataChannel, 'Timeout while receiving chunked message');\n        this._buffer = null;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     */\n    send(msg) {\n        Assert.that(msg.byteLength <= DataChannel.MESSAGE_SIZE_MAX, 'DataChannel.send() max message size exceeded');\n\n        const tag = this._sendingTag;\n        this._sendingTag = (this._sendingTag + 1) % NumberUtils.UINT8_MAX;\n        this._sendChunked(msg, tag);\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @param {number} tag\n     * @private\n     */\n    _sendChunked(msg, tag) {\n        // Send chunks.\n        let remaining = msg.byteLength;\n        let chunk = null;\n        while (remaining > 0) {\n            let buffer = null;\n            if (remaining + /*tag*/ 1 >= DataChannel.CHUNK_SIZE_MAX) {\n                buffer = new SerialBuffer(DataChannel.CHUNK_SIZE_MAX);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, DataChannel.CHUNK_SIZE_MAX - /*tag*/ 1);\n            } else {\n                buffer = new SerialBuffer(remaining + /*tag*/ 1);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, remaining);\n            }\n\n            buffer.write(chunk);\n            this.sendChunk(buffer);\n            remaining -= chunk.byteLength;\n        }\n    }\n\n    /**\n     * @abstract\n     * @param {Uint8Array} msg\n     */\n\n    /* istanbul ignore next */\n    sendChunk(msg) { throw  new Error('Not implemented'); }\n\n    /**\n     * @abstract\n     * @type {DataChannel.ReadyState}\n     */\n\n    /* istanbul ignore next */\n    get readyState() { throw new Error('Not implemented'); }\n}\n\nDataChannel.CHUNK_SIZE_MAX = 1024 * 16; // 16 kb\nDataChannel.MESSAGE_SIZE_MAX = 10 * 1024 * 1024; // 10 mb\nDataChannel.CHUNK_TIMEOUT = 1000 * 5; // 5 seconds\nDataChannel.MESSAGE_TIMEOUT = (DataChannel.MESSAGE_SIZE_MAX / DataChannel.CHUNK_SIZE_MAX) * DataChannel.CHUNK_TIMEOUT;\n\nclass ExpectedMessage {\n    /**\n     * @param {Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} msgTimeout\n     * @param {number} chunkTimeout\n     */\n    constructor(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        this.id = types.join(':');\n        this.types = types;\n        this.timeoutCallback = timeoutCallback;\n        this.msgTimeout = msgTimeout;\n        this.chunkTimeout = chunkTimeout;\n    }\n}\n\n/**\n * @enum {number}\n */\nDataChannel.ReadyState = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\n\n/**\n * @param {string} str\n * @return {DataChannel.ReadyState}\n */\nDataChannel.ReadyState.fromString = function (str) {\n    switch (str) {\n        case 'connecting':\n            return DataChannel.ReadyState.CONNECTING;\n        case 'open':\n            return DataChannel.ReadyState.OPEN;\n        case 'closing':\n            return DataChannel.ReadyState.CLOSING;\n        case 'closed':\n            return DataChannel.ReadyState.CLOSED;\n        default:\n            throw new Error('Invalid string');\n    }\n};\n\nClass.register(DataChannel);\n","class CryptoLib {\n    static get instance() {\n        if (!CryptoLib._instance) {\n            const instance = {};\n            const crypto = require('crypto');\n            instance.getRandomValues = (buf) => {\n                if (!(buf instanceof Uint8Array)) {\n                    throw new TypeError('expected Uint8Array');\n                }\n                if (buf.length > 65536) {\n                    const e = new Error();\n                    e.code = 22;\n                    e.message = `Failed to execute \\'getRandomValues\\' on \\'Crypto\\': The ArrayBufferView\\'s byte length ${buf.length} exceeds the number of bytes of entropy available via this API (65536).`;\n                    e.name = 'QuotaExceededError';\n                    throw e;\n                }\n                const bytes = crypto.randomBytes(buf.length);\n                buf.set(bytes);\n                return buf;\n            };\n\n            CryptoLib._instance = instance;\n        }\n        return CryptoLib._instance;\n    }\n}\n\nCryptoLib._instance = null;\nClass.register(CryptoLib);\n","/**\n * We don't have support for WebRTC in node.js, none of the methods\n * of this factory should ever be called in production. This may\n * change in the future.\n */\nclass WebRtcFactory {\n    /**\n     * @param {?RTCConfiguration} configuration\n     * @returns {?RTCPeerConnection}\n     */\n    static newPeerConnection(configuration) {\n        return null;\n    }\n\n    /**\n     * @param {*} rtcSessionDescriptionInit\n     * @returns {?RTCSessionDescription}\n     */\n    static newSessionDescription(rtcSessionDescriptionInit) {\n        return null;\n    }\n\n    /**\n     * @param {*} rtcIceCandidateInit\n     * @returns {?RTCIceCandidate}\n     */\n    static newIceCandidate(rtcIceCandidateInit) {\n        return null;\n    }\n}\nClass.register(WebRtcFactory);\n","class WebSocketFactory {\n    /**\n     * @static\n     * @param {NetworkConfig} networkConfig\n     * @return {WebSocketServer}\n     */\n    static newWebSocketServer(networkConfig) {\n        const port = networkConfig.peerAddress.port;\n        const sslConfig = networkConfig.sslConfig;\n\n        const options = {\n            key: fs.readFileSync(sslConfig.key),\n            cert: fs.readFileSync(sslConfig.cert)\n        };\n\n        const httpsServer = https.createServer(options, (req, res) => {\n            res.writeHead(200);\n            res.end('Nimiq NodeJS Client\\n');\n        }).listen(port);\n\n        return new WebSocket.Server({ server: httpsServer });\n    }\n\n    /**\n     * @static\n     * @param {string} url\n     * @param {*} [options]\n     * @return {WebSocket}\n     */\n    static newWebSocket(url, options) {\n        return new WebSocket(url, options);\n    }\n}\nClass.register(WebSocketFactory);\n","class Services {\n    /**\n     * @constructor\n     * @param {number} [provided=Services.NONE] Bitmap of services that can be provided by this node\n     * @param {number} [accepted=Services.NONE] Bitmap of services that can be accepted by this node\n     */\n    constructor(provided = Services.NONE, accepted = Services.NONE) {\n        this._provided = provided;\n        this._accepted = accepted;\n    }\n\n    /**\n     * @type {number}\n     */\n    get provided() {\n        return this._provided;\n    }\n\n    /**\n     * @type {number}\n     */\n    get accepted() {\n        return this._accepted;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be provided\n     */\n    set provided(services) {\n        this._provided = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be accepted\n     */\n    set accepted(services) {\n        this._accepted = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isFullNode(services) {\n        return (services & Services.FULL) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isLightNode(services) {\n        return (services & Services.LIGHT) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isNanoNode(services) {\n        return services === Services.NANO;\n    }\n}\nServices.NONE   = 0;\nServices.NANO   = 1;\nServices.LIGHT  = 2;\nServices.FULL   = 4;\nClass.register(Services);\n","class Synchronizer extends Observable {\n    constructor() {\n        super();\n        this._queue = [];\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(fn) {\n        return new Promise((resolve, reject) => {\n            this._queue.push({fn: fn, resolve: resolve, reject: reject});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(Synchronizer));\n            }\n        });\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const job of this._queue) {\n            if (job.reject) job.reject();\n        }\n        this._queue = [];\n    }\n\n    async _doWork() {\n        this._working = true;\n        this.fire('work-start', this);\n\n        while (this._queue.length) {\n            const job = this._queue.shift();\n            try {\n                const result = await job.fn();\n                job.resolve(result);\n            } catch (e) {\n                if (job.reject) job.reject(e);\n            }\n        }\n\n        this._working = false;\n        this.fire('work-end', this);\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(Synchronizer);\n","class Timers {\n    constructor() {\n        this._timeouts = {};\n        this._intervals = {};\n    }\n\n    setTimeout(key, fn, waitTime) {\n        if (this._timeouts[key]) throw 'Duplicate timeout for key ' + key;\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    clearTimeout(key) {\n        clearTimeout(this._timeouts[key]);\n        delete this._timeouts[key];\n    }\n\n    resetTimeout(key, fn, waitTime) {\n        clearTimeout(this._timeouts[key]);\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    timeoutExists(key) {\n        return this._timeouts[key] !== undefined;\n    }\n\n    setInterval(key, fn, intervalTime) {\n        if (this._intervals[key]) throw 'Duplicate interval for key ' + key;\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    clearInterval(key) {\n        clearInterval(this._intervals[key]);\n        delete this._intervals[key];\n    }\n\n    resetInterval(key, fn, intervalTime) {\n        clearInterval(this._intervals[key]);\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    intervalExists(key) {\n        return this._intervals[key] !== undefined;\n    }\n\n    clearAll() {\n        for (const key in this._timeouts) {\n            this.clearTimeout(key);\n        }\n        for (const key in this._intervals) {\n            this.clearInterval(key);\n        }\n    }\n}\nClass.register(Timers);\n","class Version {\n    static isCompatible(code) {\n        // Allow future, backwards-compatible versions.\n        return code >= Version.CODE;\n    }\n}\nVersion.CODE = 1;\nClass.register(Version);\n","/**\n * This class stores and provides the network time (current system\n * time with an offset calculated from our peer's time)\n */\nclass Time {\n    /**\n     * @constructor\n     * @param {number} [offset=0]\n     */\n    constructor(offset = 0) {\n        this._offset = offset;\n    }\n\n    /**\n     * @param {number} offset\n     */\n    set offset(offset) {\n        this._offset = offset;\n    }\n\n    /**\n     * Returns the current time adjusted with the network's offset\n     * @return {number}\n     */\n    now() {\n        return Date.now() + this._offset;\n    }\n}\nClass.register(Time);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","/**\n * @template K,V\n */\nclass HashMap {\n    constructor(fnHash = HashMap._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {V|*}\n     */\n    get(key) {\n        return this._map.get(this._fnHash(key));\n    }\n\n    /**\n     * @param {K|*} key\n     * @param {V|*} value\n     */\n    put(key, value) {\n        this._map.set(this._fnHash(key), value);\n    }\n\n    /**\n     * @param {K|*} key\n     */\n    remove(key) {\n        this._map.delete(this._fnHash(key));\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {boolean}\n     */\n    contains(key) {\n        return this._map.has(this._fnHash(key));\n    }\n\n    /**\n     * @returns {Array.<K|*>}\n     */\n    keys() {\n        return Array.from(this._map.keys());\n    }\n\n    /**\n     * @returns {Iterator.<K|*>}\n     */\n    keyIterator() {\n        return this._map.keys();\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashMap);\n","/**\n * @template V\n * @implements {Iterable.<V>}\n */\nclass HashSet {\n    constructor(fnHash = HashSet._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    add(value) {\n        this._map.set(this._fnHash(value), value);\n    }\n\n    /**\n     * @param {Iterable.<V|*>} collection\n     */\n    addAll(collection) {\n        for (const value of collection) {\n            this.add(value);\n        }\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {V|*}\n     */\n    get(value) {\n        return this._map.get(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    remove(value) {\n        this._map.delete(this._fnHash(value));\n    }\n\n    /**\n     * @param {Array.<V|*>} collection\n     */\n    removeAll(collection) {\n        for (const value of collection) {\n            this.remove(value);\n        }\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {boolean}\n     */\n    contains(value) {\n        return this._map.has(this._fnHash(value));\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this.valueIterator();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashSet);\n","/**\n * @template T\n * @implements {Iterable.<T>}\n */\nclass LimitIterable {\n    /**\n     * @param {Iterable.<T>|Iterator.<T>} it\n     * @param {number} limit\n     */\n    constructor(it, limit) {\n        /** @type {Iterator.<T>} */\n        this._iterator = it[Symbol.iterator] ? it[Symbol.iterator]() : it;\n        /** @type {number} */\n        this._limit = limit;\n    }\n\n    /**\n     * @returns {{next: function():object}}\n     */\n    [Symbol.iterator]() {\n        return LimitIterable.iterator(this._iterator, this._limit);\n    }\n\n    /**\n     * @template V\n     * @param {Iterator.<V>} iterator\n     * @param {number} limit\n     * @returns {{next: function():object}}\n     */\n    static iterator(iterator, limit) {\n        let count = 0;\n        return {\n            next: () => {\n                const done = count++ >= limit;\n                const next = iterator.next();\n                return {\n                    value: done ? undefined : next.value,\n                    done: done || next.done\n                };\n            }\n        };\n    }\n}\nClass.register(LimitIterable);\n","class Queue {\n    constructor(fnHash) {\n        this._queue = [];\n        this._fnHash = fnHash || Queue._hash;\n    }\n\n    static _hash(o) {\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    enqueue(value) {\n        this._queue.push(value);\n    }\n\n    dequeue() {\n        return this._queue.shift();\n    }\n\n    peek() {\n        return this._queue[0];\n    }\n\n    /**\n     * @param {*} value\n     * @return {number}\n     */\n    indexOf(value) {\n        const hash = this._fnHash(value);\n        for (let i = 0; i < this._queue.length; ++i) {\n            if (hash === this._fnHash(this._queue[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._queue.splice(index, 1);\n        }\n    }\n\n    /**\n     * @param {number} count\n     * @return {Array}\n     */\n    dequeueMulti(count) {\n        return this._queue.splice(0, count);\n    }\n\n    /**\n     * @param {*} value\n     * @return {Array}\n     */\n    dequeueUntil(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            return this._queue.splice(0, index + 1);\n        }\n        return [];\n    }\n\n    clear() {\n        this._queue = [];\n    }\n\n    values() {\n        return this._queue;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n}\nClass.register(Queue);\n","class SortedList {\n    constructor(sortedList = [], compare) {\n        this._list = sortedList;\n        this._compare = compare || SortedList._compare;\n    }\n\n    static _compare(a, b) {\n        return a.compare ? a.compare(b) : (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    indexOf(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                return currentIndex;\n            }\n        }\n\n        return -1;\n    }\n\n    _insertionIndex(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                break;\n            }\n        }\n\n        return a;\n    }\n\n    add(value) {\n        this._list.splice(this._insertionIndex(value), 0, value);\n    }\n\n    shift() {\n        return this._list.shift();\n    }\n\n    pop() {\n        return this._list.pop();\n    }\n\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._list.splice(index, 1);\n        }\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    values() {\n        return this._list;\n    }\n\n    copy() {\n        return new SortedList(this._list.slice(), this._compare);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._list.length;\n    }\n}\nClass.register(SortedList);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) throw new Error(message);\n    }\n}\nClass.register(Assert);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('€', '¤').replace('Š', '¦').replace('š', '¨').replace('Ž', '´')\n            .replace('ž', '¸').replace('Œ', '¼').replace('œ', '½').replace('Ÿ', '¾');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","class Crypto {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorkerImpl>}\n     */\n    static async prepareSyncCryptoWorker() {\n        const impl = IWorker._workerImplementation[CryptoWorker.name];\n        await impl.init('crypto');\n        Crypto._workerSync = impl;\n        return impl;\n    }\n\n    /**\n     * @returns {CryptoWorkerImpl}\n     * @private\n     */\n    static _cryptoWorkerSync() {\n        if (Crypto._workerSync === null) throw new Error('Synchronous crypto worker not yet prepared');\n        return Crypto._workerSync;\n    }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     * @private\n     */\n    static async _cryptoWorkerAsync() {\n        if (!Crypto._workerAsync) {\n            Crypto._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return Crypto._workerAsync;\n    }\n\n\n    /* Public Key */\n\n    static get publicKeyType() {\n        return Uint8Array;\n    }\n\n    static get publicKeySize() {\n        return 32;\n    }\n\n    static publicKeySerialize(key) {\n        // key is already a Uint8Array\n        return key;\n    }\n\n    static publicKeyUnserialize(key) {\n        return key;\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static publicKeyDerive(privateKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.publicKeyDerive(privateKey);\n    }\n\n\n    /* Private Key */\n\n    static get privateKeyType() {\n        return Uint8Array;\n    }\n\n    static get privateKeySize() {\n        return 32;\n    }\n\n    static privateKeySerialize(key) {\n        // already a Uint8Array\n        return key;\n    }\n\n    static privateKeyUnserialize(key) {\n        return key;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    static privateKeyGenerate() {\n        const privateKey = new Uint8Array(Crypto.privateKeySize);\n        Crypto.lib.getRandomValues(privateKey);\n        return privateKey;\n    }\n\n\n    /* Key Pair */\n\n    static get keyPairType() {\n        return Object;\n    }\n\n    /**\n     * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}\n     */\n    static keyPairGenerate() {\n        return Crypto.keyPairDerive(Crypto.privateKeyGenerate());\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}\n     */\n    static keyPairDerive(privateKey) {\n        return {\n            privateKey,\n            publicKey: Crypto.publicKeyDerive(privateKey)\n        };\n    }\n\n    static keyPairPrivate(obj) {\n        return obj.privateKey;\n    }\n\n    static keyPairPublic(obj) {\n        return obj.publicKey;\n    }\n\n    static keyPairFromKeys(privateKey, publicKey) {\n        return { privateKey, publicKey };\n    }\n\n\n    /* Simple Signature */\n\n    static get signatureType() {\n        return Uint8Array;\n    }\n\n    static get signatureSize() {\n        return 64;\n    }\n\n    static signatureSerialize(obj) {\n        return obj;\n    }\n\n    static signatureUnserialize(arr) {\n        return arr;\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static signatureCreate(privateKey, publicKey, data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.signatureCreate(privateKey, publicKey, data);\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} data\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static signatureVerify(publicKey, data, signature) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.signatureVerify(publicKey, data, signature);\n    }\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    static async blockVerify(block, transactionValid, timeNow) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.blockVerify(block, transactionValid, timeNow, Block.GENESIS.HASH.serialize());\n    }\n\n\n    /* Hash Functions */\n\n    static get hashType() {\n        return Uint8Array;\n    }\n\n    /**\n     * @deprecated\n     */\n    static get hashSize() {\n        return 32;\n    }\n\n    static get blake2bSize() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static blake2bSync(data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.computeBlake2b(data);\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async blake2bAsync(data) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.computeBlake2b(data);\n    }\n\n    static get argon2dSize() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async argon2d(data) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.computeArgon2d(data);\n    }\n\n    static get sha256Size() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static sha256(data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.computeSha256(data);\n    }\n\n\n    /* Multi Signature */\n\n    static get randomnessSize() {\n        return 32;\n    }\n\n    static get commitmentPairType() {\n        return Object;\n    }\n\n    /**\n     * @returns {{commitment: Uint8Array, secret: Uint8Array}}\n     */\n    static commitmentPairGenerate() {\n        const randomness = new Uint8Array(Crypto.randomnessSize);\n        Crypto.lib.getRandomValues(randomness);\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.commitmentCreate(randomness);\n    }\n\n    static commitmentPairFromValues(secret, commitment) {\n        return { secret, commitment };\n    }\n\n    static commitmentPairRandomSecret(obj) {\n        return obj.secret;\n    }\n\n    static commitmentPairCommitment(obj) {\n        return obj.commitment;\n    }\n\n    static get randomSecretType() {\n        return Uint8Array;\n    }\n\n    static get randomSecretSize() {\n        return 32;\n    }\n\n    static randomSecretSerialize(key) {\n        // secret is already a Uint8Array\n        return key;\n    }\n\n    static randomSecretUnserialize(key) {\n        return key;\n    }\n\n    static get commitmentType() {\n        return Uint8Array;\n    }\n\n    static get commitmentSize() {\n        return 32;\n    }\n\n    static commitmentSerialize(key) {\n        // commitment is already a Uint8Array\n        return key;\n    }\n\n    static commitmentUnserialize(key) {\n        return key;\n    }\n\n    static get partialSignatureType() {\n        return Uint8Array;\n    }\n\n    static get partialSignatureSize() {\n        return 32;\n    }\n\n    static partialSignatureSerialize(obj) {\n        return obj;\n    }\n\n    static partialSignatureUnserialize(arr) {\n        return arr;\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static hashPublicKeys(publicKeys) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.publicKeysHash(publicKeys);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKey\n     * @returns {Uint8Array}\n     */\n    static delinearizePublicKey(publicKeys, publicKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.publicKeyDelinearize(publicKey, publicKeysHash);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static delinearizePrivateKey(publicKeys, publicKey, privateKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.privateKeyDelinearize(privateKey, publicKey, publicKeysHash);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static delinearizeAndAggregatePublicKeys(publicKeys) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} combinedCommitment\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static delinearizedPartialSignatureCreate(privateKey, publicKey, publicKeys, secret, combinedCommitment, data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, combinedCommitment, data);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    static aggregateCommitments(commitments) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.commitmentsAggregate(commitments);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static aggregatePartialSignatures(partialSignatures) {\n        const worker = Crypto._cryptoWorkerSync();\n        return partialSignatures.reduce((sigA, sigB) => worker.scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Crypto.aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n\n    /* Utils */\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async kdf(key, salt, iterations = 256) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.kdf(key, salt, iterations);\n    }\n\n    /**\n     * @param {Array.<BlockHeader>} headers\n     * @return {Promise.<void>}\n     */\n    static async manyPow(headers) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        const size = worker.poolSize || 1;\n        const partitions = [];\n        let j = 0;\n        for (let i = 0; i < size; ++i) {\n            partitions.push([]);\n            for (; j < ((i + 1) / size) * headers.length; ++j) {\n                partitions[i].push(headers[j].serialize());\n            }\n        }\n        const promises = [];\n        for (const part of partitions) {\n            promises.push(worker.computeArgon2dBatch(part));\n        }\n        const pows = (await Promise.all(promises)).reduce((a, b) => [...a, ...b], []);\n        for(let i = 0; i < headers.length; ++i) {\n            headers[i]._pow = new Hash(pows[i]);\n        }\n    }\n}\n\n/** @type {CryptoWorkerImpl} */\nCrypto._workerSync = null;\n/** @type {CryptoWorker} */\nCrypto._workerAsync = null;\n\nClass.register(Crypto);\n","class CRC32 {\n    static _createTable () {\n        let b;\n        const table = [];\n\n        for (let j = 0; j < 256; ++j) {\n            b = j;\n            for (let k = 0; k < 8; ++k) {\n                b = b & 1 ? CRC32._POLYNOMIAL ^ (b >>> 1) : b >>> 1;\n            }\n            table[j] = b >>> 0;\n        }\n        return table;\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @returns {number}\n     */\n    static compute(buf) {\n        if (!CRC32._table) CRC32._table = CRC32._createTable();\n        if (!CRC32._hex_chars) CRC32._hex_chars = '0123456789abcdef'.split('');\n\n        const message = new Uint8Array(buf);\n        const initialValue = -1;\n\n        let crc = initialValue;\n        let hex = '';\n\n        for (let i = 0; i < message.length; ++i) {\n            crc = CRC32._table[(crc ^ message[i]) & 0xFF] ^ (crc >>> 8);\n        }\n        crc ^= initialValue;\n\n        hex += CRC32._hex_chars[(crc >> 28) & 0x0F] + CRC32._hex_chars[(crc >> 24) & 0x0F] +\n            CRC32._hex_chars[(crc >> 20) & 0x0F] + CRC32._hex_chars[(crc >> 16) & 0x0F] +\n            CRC32._hex_chars[(crc >> 12) & 0x0F] + CRC32._hex_chars[(crc >> 8) & 0x0F] +\n            CRC32._hex_chars[(crc >> 4) & 0x0F] + CRC32._hex_chars[crc & 0x0F];\n\n        return parseInt(hex, 16);\n    }\n}\nCRC32._table = null;\nCRC32._hex_chars = null;\nCRC32._POLYNOMIAL = 0xEDB88320;\nClass.register(CRC32);\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class MerkleProof {\n    /**\n     * @param {Array.<*>} hashes\n     * @param {Array.<MerkleProof.Operation>} operations\n     */\n    constructor(hashes, operations) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint16(hashes.length)) throw new Error('Malformed nodes');\n        if (!Array.isArray(operations) || !NumberUtils.isUint16(operations.length)) throw new Error('Malformed operations');\n        /**\n         * @type {Array.<*>}\n         * @private\n         */\n        this._nodes = hashes;\n        this._operations = operations;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static compute(values, leafValues, fnHash = MerkleTree._hash) {\n        const leafHashes = leafValues.map(fnHash);\n        const {containsLeaf, operations, path, inner} = MerkleProof._compute(values, leafHashes, fnHash);\n        return new MerkleProof(path, operations);\n    }\n\n    /**\n     * Assumes ordered array of values.\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(a: *, b: *):number} fnCompare\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static computeWithAbsence(values, leafValues, fnCompare, fnHash = MerkleTree._hash) {\n        const leaves = new Set();\n        leafValues = leafValues.slice();\n        leafValues.sort(fnCompare);\n        // Find missing leaves and include neighbours instead.\n        let leafIndex = 0, valueIndex = 0;\n        while (valueIndex < values.length && leafIndex < leafValues.length) {\n            const value = values[valueIndex];\n            const comparisonResult = fnCompare(value, leafValues[leafIndex]);\n            // Leave is included.\n            if (comparisonResult === 0) {\n                leaves.add(leafValues[leafIndex]);\n                ++leafIndex;\n            }\n            // Leave should already have been there, so it is missing.\n            else if (comparisonResult > 0) {\n                // Use both, prevValue and value, as a proof of absence.\n                // Special case: prevValue unknown as we're at the first value.\n                if (valueIndex > 0) {\n                    leaves.add(values[valueIndex - 1]);\n                }\n                leaves.add(value);\n                ++leafIndex;\n            }\n            // This value is not interesting for us, skip it.\n            else {\n                ++valueIndex;\n            }\n        }\n        // If we processed all values but not all leaves, these are missing. Add last value as proof.\n        if (leafIndex < leafValues.length && values.length > 0) {\n            leaves.add(values[values.length - 1]);\n        }\n\n        return MerkleProof.compute(values, Array.from(leaves), fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<Hash>} leafHashes\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHashes, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            const isLeaf = leafHashes.some(h => hash.equals(h));\n            return {\n                containsLeaf: isLeaf,\n                operations: [isLeaf ? MerkleProof.Operation.CONSUME_INPUT : MerkleProof.Operation.CONSUME_PROOF],\n                path: isLeaf ? [] : [hash],\n                inner: hash\n            };\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, operations: leftOps, path: leftPath, inner: leftHash} = MerkleProof._compute(left, leafHashes, fnHash);\n        const {containsLeaf: rightLeaf, operations: rightOps, path: rightPath, inner: rightHash} = MerkleProof._compute(right, leafHashes, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        // If a branch does not contain a leaf, we can directly use its hash and discard any inner operations.\n        if (!leftLeaf && !rightLeaf) {\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n\n        // At least one branch contains a leaf, so execute all operations.\n        let operations = leftOps;\n        operations = operations.concat(rightOps);\n        let path = leftPath;\n        path = path.concat(rightPath);\n\n        operations.push(MerkleProof.Operation.HASH);\n\n        return {containsLeaf: true, operations: operations, path: path, inner: hash};\n    }\n\n    /**\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValues, fnHash = MerkleTree._hash) {\n        /** @type {Array.<Hash>} */\n        const inputs = leafValues.map(fnHash);\n        const stack = [];\n        const proofNodes = this._nodes.slice();\n        for (const op of this._operations) {\n            switch (op) {\n                case MerkleProof.Operation.CONSUME_PROOF:\n                    if (proofNodes.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(proofNodes.shift());\n                    break;\n                case MerkleProof.Operation.CONSUME_INPUT:\n                    if (inputs.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(inputs.shift());\n                    break;\n                case MerkleProof.Operation.HASH: {\n                    if (stack.length < 2) {\n                        throw new Error('Invalid operation.');\n                    }\n                    const hashStack = stack.splice(-2, 2);\n                    const concat = new SerialBuffer(hashStack.reduce((size, hash) => size + hash.serializedSize, 0));\n                    const [left, right] = hashStack;\n                    left.serialize(concat);\n                    right.serialize(concat);\n                    stack.push(Hash.light(concat));\n                    break;\n                }\n                default:\n                    throw new Error('Invalid operation.');\n            }\n        }\n\n        // Everything but the root needs to be consumed.\n        if (stack.length !== 1 || proofNodes.length !== 0 || inputs.length !== 0) {\n            throw Error('Did not consume all nodes.');\n        }\n\n        return stack[0];\n    }\n\n    /**\n     * @param {Array.<MerkleProof.Operation>} operations\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(operations) {\n        const count = operations.length;\n        const opBitsSize = Math.ceil(count / 4);\n        const opBits = new Uint8Array(opBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            const op = operations[i] & 0x3;\n            opBits[Math.floor(i / 4)] |= op << (i % 4) * 2;\n        }\n\n        return opBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerkleProof}\n     */\n    static unserialize(buf) {\n        const opCount = buf.readUint16();\n        const opBitsSize = Math.ceil(opCount / 4);\n        const opBits = buf.read(opBitsSize);\n\n        const operations = [];\n        for (let i = 0; i < opCount; i++) {\n            const op = ((opBits[Math.floor(i / 4)] >>> (i % 4) * 2) & 0x3);\n            operations.push(op);\n        }\n\n        const countNodes = buf.readUint16();\n        const hashes = [];\n        for (let i = 0; i < countNodes; i++) {\n            hashes.push(Hash.unserialize(buf));\n        }\n        return new MerkleProof(hashes, operations);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._operations.length);\n        buf.write(MerkleProof._compress(this._operations));\n        buf.writeUint16(this._nodes.length);\n        for (const hash of this._nodes) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const opBitsSize = Math.ceil(this._operations.length / 4);\n        return /*counts*/ 4\n            + opBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerkleProof} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerkleProof\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]))\n            && this._operations.length === o._operations.length\n            && this._operations.every((op, i) => op === o._operations[i]);\n    }\n\n    /** @type {Array.<Hash>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\n/** @enum {number} */\nMerkleProof.Operation = {\n    CONSUME_PROOF: 0,\n    CONSUME_INPUT: 1,\n    HASH: 2\n};\nClass.register(MerkleProof);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class StringUtils {\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isMultibyte(str) {\n        return /[\\uD800-\\uDFFF]/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isHex(str) {\n        return /[0-9A-Fa-f]*/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @param {number} [length]\n     * @returns {boolean}\n     */\n    static isHexBytes(str, length) {\n        if (!StringUtils.isHex(str)) return false;\n        if (str.length % 2 !== 0) return false;\n        if (typeof length === 'number' && str.length / 2 !== length) return false;\n        return true;\n    }\n\n    /**\n     * @param {string} str1\n     * @param {string} str2\n     * @returns {string}\n     */\n    static commonPrefix(str1, str2) {\n        let i = 0;\n        for (; i < str1.length; ++i) {\n            if (str1[i] !== str2[i]) break;\n        }\n        return str1.substr(0, i);\n    }\n\n}\nClass.register(StringUtils);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e6; // 1 MB\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Primitive {\n    /**\n     * @param arg\n     * @param type\n     * @param {?number} length\n     */\n    constructor(arg, type, length) {\n        if (type && !(arg instanceof type)) throw new Error('Primitive: Invalid type');\n        if (length !== undefined && arg.length !== undefined && arg.length !== length) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Primitive && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        if (typeof this._obj.compare === 'function') {\n            return this._obj.compare(o._obj);\n        } else if (this._obj.prototype === o._obj.prototype) {\n            return BufferUtils.compare(this.serialize(), o.serialize());\n        }\n\n        throw new Error(`Incomparable types: ${this._obj.constructor.name} and ${o._obj.constructor.name}`);\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Primitive);\n","class Hash extends Primitive {\n    /**\n     * @param {Hash} o\n     * @returns {Hash}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Hash(obj);\n    }\n\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        }\n        super(arg, Crypto.hashType, Hash.getSize(algorithm));\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Crypto.blake2bSync(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static lightAsync(arr) {\n        return Hash.blake2bAsync(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async blake2bAsync(arr) {\n        return new Hash(await Crypto.blake2bAsync(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await Crypto.argon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Crypto.sha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (!size) throw new Error('Invalid hash algorithm');\n        return size;\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, Crypto.blake2bSize);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, Crypto.argon2dSize);\nHash.SIZE.set(Hash.Algorithm.SHA256, Crypto.sha256Size);\n\nHash.NULL = new Hash(new Uint8Array(Crypto.hashSize));\nClass.register(Hash);\n","class PrivateKey extends Primitive {\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.privateKeyType, Crypto.privateKeySize);\n    }\n\n    /**\n     * @return {PrivateKey}\n     */\n    static generate() {\n        return new PrivateKey(Crypto.privateKeyGenerate());\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PrivateKey}\n     */\n    static unserialize(buf) {\n        return new PrivateKey(Crypto.privateKeyUnserialize(buf.read(Crypto.privateKeySize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.privateKeySerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.privateKeySize;\n    }\n\n    /**\n     * Overwrite this private key with a replacement in-memory\n     * @param {PrivateKey} privateKey\n     */\n    overwrite(privateKey) {\n        this._obj.set(privateKey._obj);\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PrivateKey && super.equals(o);\n    }\n}\n\nClass.register(PrivateKey);\n","class PublicKey extends Primitive {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.publicKeyType, Crypto.publicKeySize);\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(Crypto.publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return new PublicKey(Crypto.delinearizeAndAggregatePublicKeys(publicKeys.map(key => key._obj)));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(Crypto.publicKeyUnserialize(buf.read(Crypto.publicKeySize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.publicKeySerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.publicKeySize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @return {Promise.<Hash>}\n     */\n    hashAsync() {\n        return Hash.lightAsync(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n}\n\nClass.register(PublicKey);\n","class KeyPair extends Primitive {\n    /**\n     * @param arg\n     * @param {boolean} locked\n     * @param {Uint8Array} lockSalt\n     * @private\n     */\n    constructor(arg, locked = false, lockSalt = null) {\n        super(arg, Crypto.keyPairType);\n        /** @type {boolean} */\n        this._locked = locked;\n        /** @type {boolean} */\n        this._lockedInternally = locked;\n        /** @type {Uint8Array} */\n        this._lockSalt = lockSalt;\n        /** @type {PrivateKey} */\n        this._internalPrivateKey = new PrivateKey(Crypto.keyPairPrivate(this._obj));\n    }\n\n    /**\n     * @return {KeyPair}\n     */\n    static generate() {\n        return new KeyPair(Crypto.keyPairGenerate());\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {KeyPair}\n     */\n    static fromPrivateKey(privateKey) {\n        return new KeyPair(Crypto.keyPairDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {KeyPair}\n     */\n    static fromHex(hexBuf) {\n        return KeyPair.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     *\n     * @param {SerialBuffer} buf\n     * @param {Uint8Array} key\n     * @return {Promise<KeyPair>}\n     */\n    static async fromEncrypted(buf, key) {\n        const type = buf.readUint8();\n        if (type !== 1) throw new Error('Unsupported type');\n        const roundsLog = buf.readUint8();\n        if (roundsLog > 32) throw new Error('Rounds out-of-bounds');\n        const rounds = Math.pow(2, roundsLog);\n        const encryptedKey = PrivateKey.unserialize(buf);\n        const salt = buf.read(KeyPair.EXPORT_SALT_LENGTH);\n        const check = buf.read(KeyPair.EXPORT_CHECKSUM_LENGTH);\n\n        const privateKey = new PrivateKey(await KeyPair._otpKdf(encryptedKey.serialize(), key, salt, rounds));\n        const keyPair = KeyPair.fromPrivateKey(privateKey);\n        const pubHash = keyPair.publicKey.hash();\n        if (!BufferUtils.equals(pubHash.subarray(0, 4), check)) {\n            throw new Error('Invalid key');\n        }\n        return keyPair;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {KeyPair}\n     */\n    static unserialize(buf) {\n        const privateKey = PrivateKey.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        let locked = false;\n        let lockSalt = null;\n        if (buf.readPos < buf.byteLength) {\n            const extra = buf.readUint8();\n            if (extra === 1) {\n                locked = true;\n                lockSalt = buf.read(32);\n            }\n        }\n        return new KeyPair(Crypto.keyPairFromKeys(privateKey._obj, publicKey._obj), locked, lockSalt);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._privateKey.serialize(buf);\n        this.publicKey.serialize(buf);\n        if (this._locked) {\n            buf.writeUint8(1);\n            buf.write(this._lockSalt);\n        } else {\n            buf.writeUint8(0);\n        }\n        return buf;\n    }\n\n    /**\n     * The unlocked private key.\n     * @type {PrivateKey}\n     */\n    get privateKey() {\n        if (this.isLocked) throw new Error('Wallet is locked');\n        return this._privateKey;\n    }\n\n    /**\n     * The private key in its current state, i.e., depending on this._locked.\n     * If this._locked, it is the internally locked private key.\n     * If !this._locked, it is either the internally unlocked private key (if !this._lockedInternally)\n     * or this._unlockedPrivateKey.\n     * @type {PrivateKey}\n     */\n    get _privateKey() {\n        return this._unlockedPrivateKey || this._internalPrivateKey;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey || (this._publicKey = new PublicKey(Crypto.keyPairPublic(this._obj)));\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._privateKey.serializedSize + this.publicKey.serializedSize + (this._locked ? this._lockSalt.byteLength + 1 : 1);\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        const wasLocked = this._locked;\n        if (this._locked) {\n            try {\n                await this.unlock(unlockKey || key);\n            } catch (e) {\n                throw new Error('KeyPair is locked and lock key mismatches');\n            }\n        }\n\n        const salt = new Uint8Array(KeyPair.EXPORT_SALT_LENGTH);\n        Crypto.lib.getRandomValues(salt);\n\n        const buf = new SerialBuffer(this.encryptedSize);\n        buf.writeUint8(1); // Argon2 KDF\n        buf.writeUint8(Math.log2(KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(await KeyPair._otpKdf(this.privateKey.serialize(), key, salt, KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(salt);\n        buf.write(this.publicKey.hash().subarray(0, KeyPair.EXPORT_CHECKSUM_LENGTH));\n\n        if (wasLocked) this.relock();\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedSize() {\n        return 2 + this.privateKey.serializedSize + KeyPair.EXPORT_SALT_LENGTH + KeyPair.EXPORT_CHECKSUM_LENGTH;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [lockSalt]\n     */\n    async lock(key, lockSalt) {\n        if (this._locked) throw new Error('KeyPair already locked');\n\n        if (lockSalt) this._lockSalt = lockSalt;\n        if (!this._lockSalt || this._lockSalt.length === 0) {\n            this._lockSalt = new Uint8Array(32);\n            Crypto.lib.getRandomValues(this._lockSalt);\n        }\n\n        this._internalPrivateKey.overwrite(await this._otpPrivateKey(key));\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n        this._lockedInternally = true;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     */\n    async unlock(key) {\n        if (!this._locked) throw new Error('KeyPair not locked');\n\n        const privateKey = await this._otpPrivateKey(key);\n        const verifyPub = PublicKey.derive(privateKey);\n        if (verifyPub.equals(this.publicKey)) {\n            // Only set this._internalPrivateKey, but keep this._obj locked.\n            this._unlockedPrivateKey = privateKey;\n            this._locked = false;\n        } else {\n            throw new Error('Invalid key');\n        }\n    }\n\n    /**\n     * Destroy cached unlocked private key if the internal key is in locked state.\n     */\n    relock() {\n        if (this._locked) throw new Error('KeyPair already locked');\n        if (!this._lockedInternally) throw new Error('KeyPair was never locked');\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n    }\n\n    _clearUnlockedPrivateKey() {\n        // If this wallet is not locked internally and unlocked, this method does not have any effect.\n        if (!this._lockedInternally || this._locked) return;\n\n        // Overwrite cached key in this._unlockedPrivateKey with 0s.\n        this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));\n        // Then, reset it.\n        this._unlockedPrivateKey = null;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @return {Promise<PrivateKey>}\n     * @private\n     */\n    async _otpPrivateKey(key) {\n        return new PrivateKey(await KeyPair._otpKdf(this._privateKey.serialize(), key, this._lockSalt, KeyPair.LOCK_KDF_ROUNDS));\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise<Uint8Array>}\n     * @private\n     */\n    static async _otpKdf(message, key, salt, iterations) {\n        return BufferUtils.xor(message, await Crypto.kdf(key, salt, iterations));\n    }\n\n    get isLocked() {\n        return this._locked;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof KeyPair && super.equals(o);\n    }\n}\nKeyPair.LOCK_KDF_ROUNDS = 256;\nKeyPair.EXPORT_KDF_ROUNDS = 256;\nKeyPair.EXPORT_CHECKSUM_LENGTH = 4;\nKeyPair.EXPORT_SALT_LENGTH = 16;\n\nClass.register(KeyPair);\n","class RandomSecret extends Primitive {\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.randomSecretType, Crypto.randomSecretSize);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {RandomSecret}\n     */\n    static unserialize(buf) {\n        return new RandomSecret(Crypto.randomSecretUnserialize(buf.read(Crypto.randomSecretSize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.randomSecretSerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.randomSecretSize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof RandomSecret && super.equals(o);\n    }\n}\n\nClass.register(RandomSecret);\n","class Commitment extends Primitive {\n    /**\n     * @param {Commitment} o\n     * @returns {Commitment}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Commitment(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Array.<Commitment>} commitments\n     * @return {Commitment}\n     */\n    static sum(commitments) {\n        return new Commitment(Crypto.aggregateCommitments(commitments.map(c => c._obj)));\n    }\n\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.commitmentType, Crypto.commitmentSize);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Commitment}\n     */\n    static unserialize(buf) {\n        return new Commitment(Crypto.commitmentUnserialize(buf.read(Crypto.commitmentSize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.commitmentSerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.commitmentSize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Commitment && super.equals(o);\n    }\n}\n\nClass.register(Commitment);\n","class CommitmentPair extends Primitive {\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.commitmentPairType);\n    }\n\n    /**\n     * @return {CommitmentPair}\n     */\n    static generate() {\n        return new CommitmentPair(Crypto.commitmentPairGenerate());\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {CommitmentPair}\n     */\n    static unserialize(buf) {\n        const secret = RandomSecret.unserialize(buf);\n        const commitment = Commitment.unserialize(buf);\n        return new CommitmentPair(Crypto.commitmentPairFromValues(secret._obj, commitment._obj));\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {CommitmentPair}\n     */\n    static fromHex(hexBuf) {\n        return this.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this.secret.serialize(buf);\n        this.commitment.serialize(buf);\n        return buf;\n    }\n\n    /** @type {RandomSecret} */\n    get secret() {\n        return this._secret || (this._secret = new RandomSecret(Crypto.commitmentPairRandomSecret(this._obj)));\n    }\n\n    /** @type {Commitment} */\n    get commitment() {\n        return this._commitment || (this._commitment = new Commitment(Crypto.commitmentPairCommitment(this._obj)));\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this.secret.serializedSize + this.commitment.serializedSize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof CommitmentPair && super.equals(o);\n    }\n}\nCommitmentPair.SERIALIZED_SIZE = Crypto.randomSecretSize + Crypto.commitmentSize;\nClass.register(CommitmentPair);\n","class Signature extends Primitive {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.signatureType, Crypto.signatureSize);\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Crypto.signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        return new Signature(Crypto.combinePartialSignatures(commitment._obj, signatures.map(s => s._obj)));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(Crypto.signatureUnserialize(buf.read(Crypto.signatureSize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.signatureSerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.signatureSize;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Crypto.signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n}\nClass.register(Signature);\n","class PartialSignature extends Primitive {\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.partialSignatureType, Crypto.partialSignatureSize);\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {RandomSecret} secret\n     * @param {Commitment} aggregateCommitment\n     * @param {Uint8Array} data\n     * @return {PartialSignature}\n     */\n    static create(privateKey, publicKey, publicKeys, secret, aggregateCommitment, data) {\n        return new PartialSignature(Crypto.delinearizedPartialSignatureCreate(privateKey._obj, publicKey._obj,\n            publicKeys.map(o => o._obj), secret._obj, aggregateCommitment._obj, data));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PartialSignature}\n     */\n    static unserialize(buf) {\n        return new PartialSignature(Crypto.partialSignatureUnserialize(buf.read(Crypto.signatureSize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.partialSignatureSerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.partialSignatureSize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PartialSignature && super.equals(o);\n    }\n}\nClass.register(PartialSignature);\n","class Address extends Primitive {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super(arg, Uint8Array, Address.SERIALIZED_SIZE);\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            default:\n                throw new Error('Proof Error!');\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed lowerCap');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Error('Proof Error!');\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class AccountsTreeNode {\n    /**\n     * @param {string} prefix\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    static terminalNode(prefix, account) {\n        return new AccountsTreeNode(AccountsTreeNode.TERMINAL, prefix, account);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<string>} childrenSuffixes\n     * @param {Array.<Hash>} childrenHashes\n     * @returns {AccountsTreeNode}\n     */\n    static branchNode(prefix, childrenSuffixes = [], childrenHashes = []) {\n        if (childrenSuffixes.length !== childrenHashes.length) {\n            throw new Error('Invalid list of children for branch node');\n        }\n        return new AccountsTreeNode(AccountsTreeNode.BRANCH, prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param {AccountsTreeNode} o\n     * @returns {AccountsTreeNode}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return AccountsTreeNode.unserialize(new SerialBuffer(o));\n    }\n\n    /**\n     * @param type\n     * @param {string} prefix\n     * @param {Account|Array.<string>} arg\n     * @param {Array.<Hash>} [arg2]\n     */\n    constructor(type, prefix = '', arg, arg2 = []) {\n        this._type = type;\n        /** @type {string} */\n        this._prefix = prefix;\n        if (this.isBranch()) {\n            /** @type {Array.<string>} */\n            this._childrenSuffixes = arg;\n            /** @type {Array.<Hash>} */\n            this._childrenHashes = arg2;\n        } else if (this.isTerminal()) {\n            /** @type {Account} */\n            this._account = arg;\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isTerminalType(type) {\n        return type === AccountsTreeNode.TERMINAL;\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isBranchType(type) {\n        return type === AccountsTreeNode.BRANCH;\n    }\n\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeNode}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        const prefix = buf.readVarLengthString();\n\n        if (AccountsTreeNode.isTerminalType(type)) {\n            // Terminal node\n            const account = Account.unserialize(buf);\n            return AccountsTreeNode.terminalNode(prefix, account);\n        } else if (AccountsTreeNode.isBranchType(type)) {\n            // Branch node\n            const childrenSuffixes = [], childrenHashes = [];\n            const childCount = buf.readUint8();\n            for (let i = 0; i < childCount; ++i) {\n                const childSuffix = buf.readVarLengthString();\n                const childHash = Hash.unserialize(buf);\n                const childIndex = parseInt(childSuffix[0], 16);\n                childrenSuffixes[childIndex] = childSuffix;\n                childrenHashes[childIndex] = childHash;\n            }\n            return AccountsTreeNode.branchNode(prefix, childrenSuffixes, childrenHashes);\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeVarLengthString(this._prefix);\n        if (this.isTerminal()) {\n            // Terminal node\n            this._account.serialize(buf);\n        } else {\n            // Branch node\n            const childCount = this._childrenSuffixes.reduce((count, child) => count + !!child, 0);\n            buf.writeUint8(childCount);\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                if (this._childrenHashes[i]) {\n                    buf.writeVarLengthString(this._childrenSuffixes[i]);\n                    this._childrenHashes[i].serialize(buf);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let payloadSize;\n        if (this.isTerminal()) {\n            payloadSize = this._account.serializedSize;\n        } else {\n            // The children array contains undefined values for non existing children.\n            // Only count existing ones.\n            const childrenSize = this._childrenHashes.reduce((sum, child, i) => {\n                return sum + (child ? child.serializedSize + SerialBuffer.varLengthStringSize(this._childrenSuffixes[i]) : 0);\n            }, 0);\n            payloadSize = /*childCount*/ 1 + childrenSize;\n        }\n\n        return /*type*/ 1\n            + SerialBuffer.varLengthStringSize(this._prefix)\n            + payloadSize;\n    }\n\n    /**\n     * @returns {SerialBuffer}\n     */\n    stripDown() {\n        return this.serialize();\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?Hash}\n     */\n    getChildHash(prefix) {\n        return this._childrenHashes && this._childrenHashes[this._getChildIndex(prefix)];\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?string}\n     */\n    getChild(prefix) {\n        const suffix = this._childrenSuffixes && this._childrenSuffixes[this._getChildIndex(prefix)];\n        if (suffix) {\n            return this.prefix + suffix;\n        }\n        return suffix;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} childHash\n     * @returns {AccountsTreeNode}\n     */\n    withChild(prefix, childHash) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        childrenSuffixes[this._getChildIndex(prefix)] = prefix.substr(this.prefix.length);\n        childrenHashes[this._getChildIndex(prefix)] = childHash;\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {AccountsTreeNode}\n     */\n    withoutChild(prefix) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        delete childrenSuffixes[this._getChildIndex(prefix)];\n        delete childrenHashes[this._getChildIndex(prefix)];\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasChildren() {\n        return this._childrenSuffixes && this._childrenSuffixes.some(child => !!child);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasSingleChild() {\n        return this._childrenSuffixes && this._childrenSuffixes.reduce((count, child) => count + !!child, 0) === 1;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getFirstChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        const suffix = this._childrenSuffixes.find(child => !!child);\n        return suffix ? this.prefix + suffix : undefined;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getLastChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        for (let i = this._childrenSuffixes.length - 1; i >= 0; --i) {\n            if (this._childrenSuffixes[i]) {\n                return this.prefix + this._childrenSuffixes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @returns {?Array.<string>}\n     */\n    getChildren() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        return this._childrenSuffixes.filter(child => !!child).map(child => this.prefix + child);\n    }\n\n    /** @type {Account} */\n    get account() {\n        return this._account;\n    }\n\n    /** @type {string} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {string} */\n    set prefix(value) {\n        this._prefix = value;\n        this._hash = undefined;\n    }\n\n    /**\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    withAccount(account) {\n        return AccountsTreeNode.terminalNode(this._prefix, account);\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = Hash.light(this.serialize());\n        }\n        return this._hash;\n    }\n\n    /**\n     * Tests if this node is a child of some other node.\n     * @param {AccountsTreeNode} parent\n     * @returns {boolean}\n     */\n    isChildOf(parent) {\n        return parent.getChildren() && parent.getChildren().includes(this._prefix);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTerminal() {\n        return AccountsTreeNode.isTerminalType(this._type);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isBranch() {\n        return AccountsTreeNode.isBranchType(this._type);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {number}\n     * @private\n     */\n    _getChildIndex(prefix) {\n        Assert.that(prefix.substr(0, this.prefix.length) === this.prefix, `Prefix ${prefix} is not a child of the current node ${this.prefix}`);\n        return parseInt(prefix[this.prefix.length], 16);\n    }\n\n    /**\n     * @param {AccountsTreeNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        if (!(o instanceof AccountsTreeNode)) return false;\n        if (!Object.is(this.prefix, o.prefix)) return false;\n        if (this.isTerminal()) {\n            return o.isTerminal() && o._account.equals(this._account);\n        } else {\n            if (!o.isBranch()) return false;\n            if (this._childrenSuffixes.length !== o._childrenSuffixes.length) return false;\n            if (o._childrenSuffixes.length !== o._childrenHashes.length) return false;\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                // hashes of child nodes\n                const ourChild = this._childrenHashes[i];\n                const otherChild = o._childrenHashes[i];\n                if (ourChild) {\n                    if (!otherChild || !ourChild.equals(otherChild)) return false;\n                } else {\n                    if (otherChild) return false;\n                }\n                if (this._childrenSuffixes[i] !== o._childrenSuffixes[i]) return false;\n            }\n        }\n        return true;\n    }\n}\nAccountsTreeNode.BRANCH = 0x00;\nAccountsTreeNode.TERMINAL = 0xff;\nClass.register(AccountsTreeNode);\n","class AccountsTreeStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        jdb.createObjectStore('Accounts', new AccountsTreeStoreCodec());\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {AccountsTreeStore}\n     */\n    static getPersistent(jdb) {\n        return new AccountsTreeStore(jdb.getObjectStore('Accounts'));\n    }\n\n    /**\n     * @returns {AccountsTreeStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new AccountsTreeStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @override\n     * @param {string} key\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async put(node) {\n        const key = node.prefix;\n        await this._store.put(key, node);\n        return key;\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async remove(node) {\n        const key = node.prefix;\n        await this._store.remove(key);\n        return key;\n    }\n\n    /**\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    getRootNode() {\n        return this.get('');\n    }\n\n    /**\n     * @param startPrefix This prefix will *not* be included.\n     * @param size\n     * @returns {Promise.<Array.<AccountsTreeNode>>}\n     */\n    async getTerminalNodes(startPrefix, size) {\n        const relevantKeys = [];\n        await this._store.keyStream(key => {\n            if (key.length === Address.HEX_SIZE) {\n                relevantKeys.push(key);\n                if (relevantKeys.length === size) {\n                    return false;\n                }\n            }\n            return true;\n        }, true, JDB.KeyRange.lowerBound(startPrefix, true));\n        const nodes = [];\n        for (const key of relevantKeys) {\n            nodes.push(this._store.get(key));\n        }\n        return Promise.all(nodes);\n    }\n\n    /**\n     * @param {AccountsTreeStore} [tx]\n     * @returns {AccountsTreeStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new AccountsTreeStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTreeStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new AccountsTreeStore(tx);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {SynchronousAccountsTreeStore}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        return new SynchronousAccountsTreeStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(AccountsTreeStore);\n\n/**\n * @implements {ICodec}\n */\nclass AccountsTreeStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.stripDown();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return AccountsTreeNode.copy(obj);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n","class SynchronousAccountsTreeStore extends AccountsTreeStore {\n    /**\n     * @param {SynchronousTransaction} store\n     */\n    constructor(store) {\n        super(store);\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<string>} keys\n     */\n    async preload(keys) {\n        await this._syncStore.preload(keys);\n    }\n\n    /**\n     * @param {string} key\n     * @param {boolean} [expectedToBePresent]\n     * @returns {AccountsTreeNode}\n     */\n    getSync(key, expectedToBePresent = true) {\n        return this._syncStore.getSync(key, expectedToBePresent);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    putSync(node) {\n        const key = node.prefix;\n        this._syncStore.putSync(key, node);\n        return key;\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    removeSync(node) {\n        const key = node.prefix;\n        this._syncStore.removeSync(key);\n        return key;\n    }\n\n    /**\n     * @returns {AccountsTreeNode}\n     */\n    getRootNodeSync() {\n        return this.getSync('');\n    }\n}\nClass.register(SynchronousAccountsTreeStore);\n","class AccountsProof {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     */\n    constructor(nodes) {\n        if (!nodes || !Array.isArray(nodes) || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode))) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        /** @type {HashMap.<Hash,AccountsTreeNode>} */\n        this._index = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        return size;\n    }\n\n    /**\n     * Assumes nodes to be in post order and hashes nodes to check internal consistency of proof.\n     * XXX Abuse this method to index the nodes contained in the proof. This forces callers to explicitly verify()\n     * the proof before retrieving accounts.\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Array.<AccountsTreeNode>} */\n        const children = [];\n        this._index = new HashMap();\n        for (const node of this._nodes) {\n            // If node is a branch node, validate its children.\n            if (node.isBranch()) {\n                let child;\n                while (child = children.pop()) { // eslint-disable-line no-cond-assign\n                    if (child.isChildOf(node)) {\n                        const hash = child.hash();\n                        // If the child is not valid, return false.\n                        if (!node.getChildHash(child.prefix).equals(hash) || node.getChild(child.prefix) !== child.prefix) {\n                            return false;\n                        }\n                        this._index.put(hash, child);\n                    } else {\n                        children.push(child);\n                        break;\n                    }\n                }\n            }\n\n            // Append child.\n            children.push(node);\n        }\n\n        // The last element must be the root node.\n        return children.length === 1 && children[0].prefix === '' && children[0].isBranch();\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {?Account}\n     */\n    getAccount(address) {\n        Assert.that(!!this._index, 'AccountsProof must be verified before retrieving accounts. Call verify() first.');\n\n        const rootNode = this._nodes[this._nodes.length - 1];\n        const prefix = address.toHex();\n        return this._getAccount(rootNode, prefix);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @returns {?Account}\n     * @private\n     */\n    _getAccount(node, prefix) {\n        // Find common prefix between node and requested address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the prefix does not fully match, the requested account does not exist.\n        if (commonPrefix.length !== node.prefix.length) return null;\n\n        // If the remaining address is empty, we have found the requested node.\n        if (commonPrefix === prefix) return node.account;\n\n        // Descend into the matching child node if one exists.\n        const childKey = node.getChildHash(prefix);\n        if (childKey) {\n            const childNode = this._index.get(childKey);\n\n            // If the child exists but is not part of the proof, fail.\n            if (!childNode) {\n                throw new Error('Requested address not part of AccountsProof');\n            }\n\n            return this._getAccount(childNode, prefix);\n        }\n\n        // No matching child exists, the requested account does not exist.\n        return null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._nodes[this._nodes.length - 1].hash();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length;\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(AccountsProof);\n","class AccountsTreeChunk {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @param {AccountsProof} proof\n     */\n    constructor(nodes, proof) {\n        if (!nodes || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode) || !it.isTerminal())) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunk}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        const proof = AccountsProof.unserialize(buf);\n        return new AccountsTreeChunk(nodes, proof);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        size += this._proof.serializedSize;\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        if (!this._proof.verify()) {\n            return false;\n        }\n\n        let lastPrefix = null;\n        for (let i = 0; i <= this._nodes.length; ++i) {\n            const node = i < this._nodes.length ? this._nodes[i] : this.tail;\n            if (lastPrefix && lastPrefix >= node.prefix) {\n                return false;\n            }\n            lastPrefix = node.prefix;\n        }\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsTreeChunk{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.root();\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get terminalNodes() {\n        return this._nodes.concat([this.tail]);\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._proof;\n    }\n\n    /** @type {AccountsTreeNode} */\n    get head() {\n        return this._nodes[0];\n    }\n\n    /** @type {AccountsTreeNode} */\n    get tail() {\n        return this._proof.nodes[0];\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length + 1;\n    }\n}\nAccountsTreeChunk.SIZE_MAX = 1000;\nAccountsTreeChunk.EMPTY = new AccountsTreeChunk([], new AccountsProof([]));\nClass.register(AccountsTreeChunk);\n","class AccountsTree extends Observable {\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async getPersistent(jdb) {\n        const store = AccountsTreeStore.getPersistent(jdb);\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async createVolatile() {\n        const store = AccountsTreeStore.createVolatile();\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @private\n     * @param {AccountsTreeStore} store\n     * @returns {AccountsTree}\n     */\n    constructor(store) {\n        super();\n        /** @type {AccountsTreeStore} */\n        this._store = store;\n        this._synchronizer = new Synchronizer();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     * @protected\n     */\n    async _init() {\n        let rootNode = await this._store.getRootNode();\n        if (!rootNode) {\n            rootNode = AccountsTreeNode.branchNode(/*prefix*/ '', /*childrenSuffixes*/ [], /*childrenHashes*/ []);\n            await this._store.put(rootNode);\n        }\n        return this;\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     */\n    put(address, account) {\n        return this._synchronizer.push(() => {\n            return this._put(address, account);\n        });\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     * @private\n     */\n    async _put(address, account) {\n        if (account.isInitial() && !(await this.get(address))) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        await this._insert(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _insert(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            const newChildHash = newChild.hash();\n            await this._store.put(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, node.hash())\n                .withChild(newChild.prefix, newChildHash);\n            const newParentHash = newParent.hash();\n            await this._store.put(newParent);\n\n            return this._updateKeys(newParent.prefix, newParentHash, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                await this._store.remove(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._prune(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            const nodeHash = node.hash();\n            await this._store.put(node);\n\n            return this._updateKeys(node.prefix, nodeHash, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = await this._store.get(childPrefix);\n            rootPath.push(node);\n            return this._insert(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        const newChildHash = newChild.hash();\n        await this._store.put(newChild);\n\n        node = node.withChild(newChild.prefix, newChildHash);\n        const nodeHash = node.hash();\n        await this._store.put(node);\n\n        return this._updateKeys(node.prefix, nodeHash, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _prune(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                await this._store.remove(node); // eslint-disable-line no-await-in-loop\n\n                const childPrefix = node.getFirstChild();\n                const childNode = await this._store.get(childPrefix); // eslint-disable-line no-await-in-loop\n\n                await this._store.put(childNode); // eslint-disable-line no-await-in-loop\n                const childHash = childNode.hash();\n                return this._updateKeys(childNode.prefix, childHash, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                const nodeHash = node.hash();\n                await this._store.put(node); // eslint-disable-line no-await-in-loop\n                return this._updateKeys(node.prefix, nodeHash, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} nodeHash\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _updateKeys(prefix, nodeHash, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, nodeHash);\n            await this._store.put(node); // eslint-disable-line no-await-in-loop\n            nodeHash = node.hash();\n            prefix = node.prefix;\n        }\n\n        return nodeHash;\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<?Account>}\n     */\n    async get(address) {\n        const node = await this._store.get(address.toHex());\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    async getAccountsProof(addresses) {\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        const nodes = [];\n        await this._getAccountsProof(rootNode, prefixes, nodes);\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * Constructs the accounts proof in post-order.\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @returns {Promise.<*>}\n     * @private\n     */\n    async _getAccountsProof(node, prefixes, nodes) {\n        // For each prefix, descend the tree individually.\n        let includeNode = false;\n        for (let i = 0; i < prefixes.length; ) {\n            let prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                includeNode = true;\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = await this._store.get(childKey); // eslint-disable-line no-await-in-loop\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                includeNode = (await this._getAccountsProof(childNode, subPrefixes, nodes)) || includeNode; // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                includeNode = true;\n                i++;\n            }\n        }\n\n        // If this branch contained at least one account, we add this node.\n        if (includeNode) {\n            nodes.push(node);\n        }\n\n        return includeNode;\n    }\n\n    /**\n     * @param {string} startPrefix The prefix to start with.\n     * @param {number} size The maximum number of terminal nodes to include.\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    async getChunk(startPrefix, size) {\n        const chunk = await this._store.getTerminalNodes(startPrefix, size);\n        const lastNode = chunk.pop();\n        let /** @type {AccountsProof} */ proof;\n        if (lastNode) {\n            proof = await this.getAccountsProof([Address.fromHex(lastNode.prefix)]);\n        } else {\n            // The proof that the last address does not exist is sufficient to prove that there is no such chunk.\n            proof = await this.getAccountsProof([Address.fromHex('ffffffffffffffffffffffffffffffffffffffff')]);\n        }\n        return new AccountsTreeChunk(chunk, proof);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<AccountsTree>}\n     */\n    transaction(enableWatchdog = true) {\n        const tree = new AccountsTree(this._store.transaction(enableWatchdog));\n        return tree._init();\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<SynchronousAccountsTree>}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        const tree = new SynchronousAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    async partialTree() {\n        const tx = this._store.synchronousTransaction(false);\n        await tx.truncate();\n        const tree = new PartialAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @param {AccountsTree} [tx]\n     * @returns {Promise.<AccountsTree>}\n     */\n    snapshot(tx) {\n        const tree = new AccountsTree(this._store.snapshot(tx ? tx._store : undefined));\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    async commit() {\n        Assert.that(!(await this.root()).equals(new Hash(null)));\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    async root() {\n        const rootNode = await this._store.getRootNode();\n        return rootNode && rootNode.hash();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._store.tx;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async isEmpty() {\n        const rootNode = await this._store.getRootNode();\n        return !rootNode.hasChildren();\n    }\n}\nClass.register(AccountsTree);\n\n","class SynchronousAccountsTree extends AccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     * @returns {SynchronousAccountsTree}\n     */\n    constructor(store) {\n        super(store);\n        /** @type {SynchronousAccountsTreeStore} */\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise}\n     */\n    async preloadAddresses(addresses) {\n        const rootNode = await this._syncStore.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        await this._preloadAddresses(rootNode, prefixes);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @private\n     */\n    async _preloadAddresses(node, prefixes) {\n        if (node.hasChildren()) {\n            await this._syncStore.preload(node.getChildren());\n        }\n        \n        // For each prefix, descend the tree individually.\n        for (let i = 0; i < prefixes.length; ) {\n            const prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = this._syncStore.getSync(childKey);\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                await this._preloadAddresses(childNode, subPrefixes); // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    putSync(address, account) {\n        this.putBatch(address, account);\n        this.finalizeBatch();\n    }\n\n    finalizeBatch() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        this._updateHashes(rootNode);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @private\n     */\n    putBatch(address, account) {\n        if (account.isInitial() && !this.getSync(address, false)) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = this._syncStore.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        this._insertBatch(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @protected\n     */\n    _insertBatch(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            this._syncStore.putSync(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, new Hash(null))\n                .withChild(newChild.prefix, new Hash(null));\n            this._syncStore.putSync(newParent);\n\n            return this._updateKeysBatch(newParent.prefix, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                this._syncStore.removeSync(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._pruneBatch(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            this._syncStore.putSync(node);\n\n            return this._updateKeysBatch(node.prefix, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = this._syncStore.getSync(childPrefix);\n            rootPath.push(node);\n            return this._insertBatch(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        this._syncStore.putSync(newChild);\n\n        node = node.withChild(newChild.prefix, new Hash(null));\n        this._syncStore.putSync(node);\n\n        return this._updateKeysBatch(node.prefix, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _pruneBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                this._syncStore.removeSync(node);\n\n                const childPrefix = node.getFirstChild();\n                const childNode = this._syncStore.getSync(childPrefix);\n\n                this._syncStore.putSync(childNode);\n                return this._updateKeysBatch(childNode.prefix, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                this._syncStore.putSync(node);\n                return this._updateKeysBatch(node.prefix, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _updateKeysBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, new Hash(null));\n            this._syncStore.putSync(node);\n            prefix = node.prefix;\n        }\n    }\n\n    /**\n     * This method updates all empty hashes (and only such).\n     * @param {AccountsTreeNode} node\n     * @protected\n     */\n    _updateHashes(node) {\n        if (node.isTerminal()) {\n            return node.hash();\n        }\n\n        const zeroHash = new Hash(null);\n        // Compute sub hashes if necessary.\n        const subHashes = node.getChildren().map(child => {\n            const currentHash = node.getChildHash(child);\n            if (!currentHash.equals(zeroHash)) {\n                return currentHash;\n            }\n            const childNode = this._syncStore.getSync(child);\n            return this._updateHashes(childNode);\n        });\n\n        // Then prepare new node and update.\n        let newNode = node;\n        node.getChildren().forEach((child, i) => {\n            newNode = newNode.withChild(child, subHashes[i]);\n        });\n        this._syncStore.putSync(newNode);\n        return newNode.hash();\n    }\n\n    /**\n     * @param {Address} address\n     * @param {boolean} [expectedToBePresent]\n     * @returns {?Account}\n     */\n    getSync(address, expectedToBePresent = true) {\n        const node = this._syncStore.getSync(address.toHex(), expectedToBePresent);\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    rootSync() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        return rootNode && rootNode.hash();\n    }\n}\nClass.register(SynchronousAccountsTree);\n\n","class PartialAccountsTree extends SynchronousAccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     */\n    constructor(store) {\n        super(store);\n        this._complete = false;\n        /** @type {string} */\n        this._lastPrefix = '';\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushChunk(chunk) {\n        // First verify the proof.\n        if (!chunk.verify()) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const tx = this.synchronousTransaction();\n\n        // Then apply all\n        tx._putLight(chunk.terminalNodes);\n\n        // Check if proof can be merged.\n        if (!tx._mergeProof(chunk.proof, chunk.tail.prefix)) {\n            await tx.abort();\n            return PartialAccountsTree.Status.ERR_UNMERGEABLE;\n        }\n        this._complete = tx.complete;\n\n        // Now, we can put all nodes into the store.\n        await tx.commit();\n\n        // Update last prefix.\n        this._lastPrefix = chunk.tail.prefix;\n\n        // And return OK code depending on internal state.\n        return this._complete ? PartialAccountsTree.Status.OK_COMPLETE : PartialAccountsTree.Status.OK_UNFINISHED;\n    }\n\n    /**\n     * @param {AccountsProof} proof\n     * @param {string} upperBound\n     * @returns {boolean}\n     * @private\n     */\n    _mergeProof(proof, upperBound) {\n        // Retrieve rightmost path of the in-memory tree.\n        let node = this._store.getRootNodeSync();\n        let nodeChildren = node.getChildren();\n        let complete = true;\n\n        // Iterate over the proof and check for consistency.\n        let j = proof.length - 1;\n        for (; j > 0; --j) {\n            const proofNode = proof.nodes[j];\n            // The node's prefix might be shorter than the proof node's prefix if it is a newly\n            // introduces node in the proof.\n            if (StringUtils.commonPrefix(node.prefix, proofNode.prefix) !== node.prefix) {\n                return false;\n            }\n\n            const proofChildren = proofNode.getChildren();\n\n            // The tree node may not have more children than the proof node.\n            if (nodeChildren.length > proofChildren.length) {\n                return false;\n            }\n\n            // The nextChild we descend to.\n            const nextChild = node.getLastChild();\n            let insertedNode = false;\n\n            // There are three cases:\n            // 1) the child is in our inner tree (so between lower and upper bound), then the hashes must coincide.\n            // 2) the child is left of our chunk, so it must be in the store.\n            // 3) the child is right of our chunk, so it is a dangling reference.\n            let i = 0;\n            for (const proofChild of proofChildren) {\n                const upperBoundPrefix = upperBound.substr(0, proofChild.length);\n                if (proofChild <= upperBoundPrefix) {\n                    // An inner node.\n                    const child = nodeChildren.shift();\n\n                    // This is the next child.\n                    if (StringUtils.commonPrefix(nextChild, proofChild) === proofChild) {\n                        // If it is a real prefix of the next child, we have inserted a new node.\n                        if (proofChild !== nextChild) {\n                            insertedNode = true;\n                        }\n                        continue;\n                    }\n\n                    if (child !== proofChild) {\n                        return false;\n                    }\n                    // The child is equal and not the next child, so the hash must coincide.\n                    const nodeHash = node.getChildHash(child);\n                    const proofHash = proofNode.getChildHash(child);\n                    if (!nodeHash || !proofHash || !nodeHash.equals(proofHash)) {\n                        return false;\n                    }\n                } else {\n                    // The others may be dangling references.\n                    break;\n                }\n                ++i;\n            }\n\n            // We must have consumed all children!\n            if (nodeChildren.length !== 0) {\n                return false;\n            }\n\n            // If not all of the proof children have been tested, we are definitely incomplete.\n            complete = complete && (i === proofChildren.length - 1);\n\n            // If the prefix was the same, we can move on.\n            if (insertedNode) {\n                nodeChildren = [nextChild];\n            } else {\n                // We should never end here with a terminal node.\n                if (node.isTerminal()) {\n                    return false;\n                }\n                node = this._store.getSync(node.getLastChild());\n                nodeChildren = node.getChildren();\n                if (node.isTerminal()) {\n                    break;\n                }\n            }\n        }\n\n        // Check the terminal nodes.\n        if (!node.equals(proof.nodes[0])) {\n            return false;\n        }\n\n        this._complete = complete;\n        return true;\n    }\n\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @private\n     */\n    _putLight(nodes) {\n        Assert.that(nodes.every(node => node.isTerminal()), 'Can only build tree from terminal nodes');\n\n        // Fetch the root node.\n        let rootNode = this._store.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // TODO: Bulk insertion instead of sequential insertion!\n        for (const node of nodes) {\n            this._insertBatch(rootNode, node.prefix, node.account, []);\n            rootNode = this._store.getRootNodeSync();\n            Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n        }\n        this._updateHashes(rootNode);\n    }\n\n    /** @type {boolean} */\n    get complete() {\n        return this._complete;\n    }\n\n    /** @type {string} */\n    get missingPrefix() {\n        return this._lastPrefix;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {PartialAccountsTree}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tree = new PartialAccountsTree(this._store.synchronousTransaction(enableWatchdog));\n        tree._complete = this._complete;\n        tree._lastPrefix = this._lastPrefix;\n        return tree;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTree}\n     */\n    transaction(enableWatchdog = true) {\n        if (!this.complete) {\n            throw new Error('Can only construct AccountsTree from complete PartialAccountsTree');\n        }\n        // Use a synchronous transaction here to enable better caching.\n        return new AccountsTree(this._store.synchronousTransaction(enableWatchdog));\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n}\n\n/**\n * @enum {number}\n */\nPartialAccountsTree.Status = {\n    ERR_HASH_MISMATCH: -3,\n    ERR_INCORRECT_PROOF: -2,\n    ERR_UNMERGEABLE: -1,\n    OK_COMPLETE: 0,\n    OK_UNFINISHED: 1\n};\nClass.register(PartialAccountsTree);\n\n","class Accounts extends Observable {\n    /**\n     * Generate an Accounts object that is persisted to the local storage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async getPersistent(jdb) {\n        const tree = await AccountsTree.getPersistent(jdb);\n        return new Accounts(tree);\n    }\n\n    /**\n     * Generate an Accounts object that loses it's data after usage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async createVolatile() {\n        const tree = await AccountsTree.createVolatile();\n        return new Accounts(tree);\n    }\n\n    /**\n     * @param {AccountsTree} accountsTree\n     */\n    constructor(accountsTree) {\n        super();\n        this._tree = accountsTree;\n\n        // Forward balance change events to listeners registered on this Observable.\n        this.bubble(this._tree, '*');\n    }\n\n    /**\n     * @param {Block} genesisBlock\n     * @param {string} encodedAccounts\n     * @returns {Promise.<void>}\n     */\n    async initialize(genesisBlock, encodedAccounts) {\n        Assert.that(await this._tree.isEmpty());\n\n        const tree = await this._tree.synchronousTransaction();\n        try {\n            const buf = BufferUtils.fromBase64(encodedAccounts);\n            const count = buf.readUint16();\n            for (let i = 0; i < count; i++) {\n                const address = Address.unserialize(buf);\n                const account = Account.unserialize(buf);\n                tree.putSync(address, account);\n            }\n\n            await this._commitBlockBody(tree, genesisBlock.body, genesisBlock.height, new TransactionCache());\n\n            tree.finalizeBatch();\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        const hash = tree.rootSync();\n        if (!genesisBlock.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('Genesis AccountsHash mismatch');\n        }\n\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    getAccountsProof(addresses) {\n        return this._tree.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {string} startPrefix\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    getAccountsTreeChunk(startPrefix) {\n        return this._tree.getChunk(startPrefix, AccountsTreeChunk.SIZE_MAX);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlock(block, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(block.body.getAddresses());\n        try {\n            this._commitBlockBody(tree, block.body, block.height, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        tree.finalizeBatch();\n\n        const hash = tree.rootSync();\n        if (!block.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('AccountsHash mismatch');\n        }\n        return tree.commit();\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._commitBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise<Array.<PrunedAccount>>}\n     */\n    async gatherToBePrunedAccounts(transactions, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        const addresses = [];\n        for (const tx of transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        await tree.preloadAddresses(addresses);\n        try {\n            this._processSenderAccounts(tree, transactions, blockHeight, transactionCache);\n            this._processRecipientAccounts(tree, transactions, blockHeight);\n            this._processContracts(tree, transactions, blockHeight);\n\n            const toBePruned = [];\n            for (const tx of transactions) {\n                const senderAccount = this._getSync(tx.sender, undefined, tree);\n                if (senderAccount.isToBePruned()) {\n                    toBePruned.push(new PrunedAccount(tx.sender, senderAccount));\n                }\n            }\n            return toBePruned.sort((a, b) => a.compare(b));\n        } finally {\n            await tree.abort();\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlock(block, transactionCache) {\n        if (!block) throw new Error('block undefined');\n\n        const hash = await this._tree.root();\n        if (!block.accountsHash.equals(hash)) {\n            throw new Error('AccountsHash mismatch');\n        }\n        return this.revertBlockBody(block.body, block.height, transactionCache);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._revertBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {AccountsTree} [tree]\n     * @return {Promise.<Account>}\n     */\n    async get(address, accountType, tree = this._tree) {\n        const account = await tree.get(address);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {SynchronousAccountsTree} tree\n     * @private\n     * @return {Account}\n     */\n    _getSync(address, accountType, tree) {\n        const account = tree.getSync(address, false);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<Accounts>}\n     */\n    async transaction(enableWatchdog = true) {\n        return new Accounts(await this._tree.transaction(enableWatchdog));\n    }\n\n    /**\n     * @param {Accounts} [tx]\n     * @returns {Promise.<Accounts>}\n     */\n    async snapshot(tx) {\n        return new Accounts(await this._tree.snapshot(tx ? tx._tree : undefined));\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    partialAccountsTree() {\n        return this._tree.partialTree();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        return this._tree.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._tree.abort();\n    }\n\n    /**\n     * Step 1)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processSenderAccounts(tree, transactions, blockHeight, transactionCache, revert = false) {\n        for (const tx of transactions) {\n            const senderAccount = this._getSync(tx.sender, !revert ? tx.senderType : undefined, tree);\n            tree.putBatch(tx.sender, senderAccount.withOutgoingTransaction(tx, blockHeight, transactionCache, revert));\n        }\n    }\n\n    /**\n     * Step 2)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processRecipientAccounts(tree, transactions, blockHeight, revert = false) {\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, undefined, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withIncomingTransaction(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * Step 3)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processContracts(tree, transactions, blockHeight, revert = false) {\n        // TODO: Filter & sort contract command.\n        if (revert) {\n            transactions = transactions.slice().reverse();\n        }\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, !revert ? undefined : tx.recipientType, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withContractCommand(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _commitBlockBody(tree, body, blockHeight, transactionCache) {\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight);\n        this._processContracts(tree, body.transactions, blockHeight);\n\n        const prunedAccounts = body.prunedAccounts.slice();\n        for (const tx of body.transactions) {\n            const senderAccount = this._getSync(tx.sender, undefined, tree);\n            if (senderAccount.isToBePruned()) {\n                const accIdx = prunedAccounts.findIndex((acc) => acc.address.equals(tx.sender));\n                if (accIdx === -1 || !senderAccount.equals(prunedAccounts[accIdx].account)) {\n                    throw new Error('Account was not pruned correctly');\n                } else {\n                    // Pruned accounts are reset to their initial state\n                    tree.putBatch(tx.sender, Account.INITIAL);\n                    prunedAccounts.splice(accIdx, 1);\n                }\n            }\n        }\n        if (prunedAccounts.length > 0) {\n            throw new Error('Account was invalidly pruned');\n        }\n\n        this._rewardMiner(tree, body, blockHeight, false);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _revertBlockBody(tree, body, blockHeight, transactionCache) {\n        this._rewardMiner(tree, body, blockHeight, true);\n\n        for (const acc of body.prunedAccounts) {\n            tree.putBatch(acc.address, acc.account);\n        }\n\n        // Execute transactions in reverse order.\n        this._processContracts(tree, body.transactions, blockHeight, true);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight, true);\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache, true);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _rewardMiner(tree, body, blockHeight, revert = false) {\n        // Sum up transaction fees.\n        const txFees = body.transactions.reduce((sum, tx) => sum + tx.fee, 0);\n\n        // \"Coinbase transaction\"\n        const coinbaseTransaction = new ExtendedTransaction(\n            Address.NULL, Account.Type.BASIC,\n            body.minerAddr, Account.Type.BASIC,\n            txFees + Policy.blockRewardAt(blockHeight),\n            0, // Fee\n            0, // ValidityStartHeight\n            Transaction.Flag.NONE,\n            new Uint8Array(0));\n\n        const recipientAccount = this._getSync(body.minerAddr, undefined, tree);\n        tree.putBatch(body.minerAddr, recipientAccount.withIncomingTransaction(coinbaseTransaction, blockHeight, revert));\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    hash() {\n        return this._tree.root();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._tree.tx;\n    }\n}\nClass.register(Accounts);\n","class BlockHeader {\n    /**\n     * @param {BlockHeader} o\n     * @returns {BlockHeader}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const prevHash = Hash.copy(o._prevHash);\n        const interlinkHash = Hash.copy(o._interlinkHash);\n        const bodyHash = Hash.copy(o._bodyHash);\n        const accountsHash = Hash.copy(o._accountsHash);\n        return new BlockHeader(\n            prevHash, interlinkHash, bodyHash, accountsHash,\n            o._nBits, o._height, o._timestamp, o._nonce, o._version\n        );\n    }\n\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw 'Malformed version';\n        if (!Hash.isHash(prevHash)) throw 'Malformed prevHash';\n        if (!Hash.isHash(interlinkHash)) throw 'Malformed interlinkHash';\n        if (!Hash.isHash(bodyHash)) throw 'Malformed bodyHash';\n        if (!Hash.isHash(accountsHash)) throw 'Malformed accountsHash';\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw 'Malformed nBits';\n        if (!NumberUtils.isUint32(height)) throw 'Invalid height';\n        if (!NumberUtils.isUint32(timestamp)) throw 'Malformed timestamp';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async hashAsync(buf) {\n        this._hash = this._hash || await Hash.lightAsync(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {number} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {number} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\n// FIXME: Clean up for mainnet.\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {BlockInterlink} o\n     * @returns {BlockInterlink}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const hashes = o._hashes.map(it => Hash.copy(it));\n        const repeatBits = new Uint8Array(o._repeatBits);\n        const compressed = o._compressed.map(it => Hash.copy(it));\n        return new BlockInterlink(hashes, undefined, repeatBits, compressed);\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, Block.GENESIS.HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw 'Malformed minerAddr';\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw 'Malformed transactions';\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw 'Malformed extraData';\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToTarget(compact) {\n        return (compact & 0xffffff) * Math.pow(2, (8 * ((compact >> 24) - 3)));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!Number.isFinite(target) || Number.isNaN(target)) throw 'Invalid Target';\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, (size - 3) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        return Math.ceil(Math.log2(target));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX / BlockUtils.compactToTarget(compact);\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX / difficulty;\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX / target;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static hashToTarget(hash) {\n        return parseInt(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return parseInt(hash.toHex(), 16) <= target;\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target >= 1 && target <= Policy.BLOCK_TARGET_MAX;\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {number} deltaTotalDifficulty\n     * @returns {number}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that((headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n            || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty += Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1;\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty / Policy.DIFFICULTY_BLOCK_WINDOW;\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget * adjustment;\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = Math.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = Math.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Subscription {\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    static fromAddresses(addresses) {\n        return new Subscription(Subscription.Type.ADDRESSES, addresses);\n    }\n\n    /**\n     * @param {number} addresses\n     */\n    static fromMinFeePerByte(minFeePerByte) {\n        return new Subscription(Subscription.Type.MIN_FEE, minFeePerByte);\n    }\n\n    /**\n     * @param {Subscription.Type} type\n     * @param {Array.<Address>|number} [filter]\n     */\n    constructor(type, filter=null) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Invalid type');\n        if (type === Subscription.Type.ADDRESSES\n            && (!Array.isArray(filter) || !NumberUtils.isUint16(filter.length)\n            || filter.some(it => !(it instanceof Address)))) throw new Error('Invalid addresses');\n        if (type === Subscription.Type.MIN_FEE && !NumberUtils.isUint64(filter)) throw new Error('Invalid minFeePerByte');\n        this._type = type;\n\n        this._addresses = new HashSet();\n        this._minFeePerByte = 0;\n\n        switch (type) {\n            case Subscription.Type.ADDRESSES:\n                this._addresses.addAll(filter);\n                break;\n            case Subscription.Type.MIN_FEE:\n                this._minFeePerByte = filter;\n                break;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Subscription}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Subscription.Type} */ buf.readUint8();\n        let filter = null;\n        switch (type) {\n            case Subscription.Type.ADDRESSES: {\n                filter = [];\n                const size = buf.readUint16();\n                for (let i = 0; i < size; ++i) {\n                    filter.push(Address.unserialize(buf));\n                }\n                break;\n            }\n            case Subscription.Type.MIN_FEE:\n                filter = buf.readUint64();\n                break;\n        }\n        return new Subscription(type, filter);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                buf.writeUint16(this._addresses.length);\n                for (const address of this._addresses) {\n                    address.serialize(buf);\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                buf.writeUint64(this._minFeePerByte);\n                break;\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let additionalSize = 0;\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                additionalSize = /*length*/ 2;\n                for (const address of this._addresses) {\n                    additionalSize += address.serializedSize;\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                additionalSize = /*minFeePerByte*/ 8;\n                break;\n        }\n        return /*type*/ 1\n            + additionalSize;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    matchesBlock(block) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n            case Subscription.Type.ADDRESSES:\n            case Subscription.Type.MIN_FEE:\n                return true;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    matchesTransaction(transaction) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n                return true;\n            case Subscription.Type.ADDRESSES:\n                return this._addresses.contains(transaction.recipient) || this._addresses.contains(transaction.sender);\n            case Subscription.Type.MIN_FEE:\n                return transaction.fee/transaction.serializedSize >= this._minFeePerByte;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Subscription{type=${this._type}, addresses=[${this._addresses.values()}], minFeePerByte=${this._minFeePerByte}}`;\n    }\n\n    /** @type {Subscription.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses.values();\n    }\n\n    /** @type {number} */\n    get minFeePerByte() {\n        return this._minFeePerByte;\n    }\n}\n/** @enum {number} */\nSubscription.Type = {\n    NONE: 0,\n    ANY: 1,\n    ADDRESSES: 2,\n    MIN_FEE: 3\n};\nSubscription.NONE = new Subscription(Subscription.Type.NONE);\nSubscription.BLOCKS_ONLY = new Subscription(Subscription.Type.ADDRESSES, []);\nSubscription.ANY = new Subscription(Subscription.Type.ANY);\nClass.register(Subscription);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} proof\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        if (this._valid === undefined) {\n            this._valid = this._verify();\n        }\n        return this._valid;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verify() {\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @return {Promise.<Hash>}\n     */\n    async hashAsync() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || await Hash.lightAsync(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize());\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0)) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n","class TransactionsProof {\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {MerkleProof} proof\n     */\n    constructor(transactions, proof) {\n        if (!transactions || !NumberUtils.isUint16(transactions.length)\n            || transactions.some(it => !(it instanceof Transaction))) throw new Error('Malformed transactions');\n        if (!(proof instanceof MerkleProof)) throw new Error('Malformed merkle proof');\n\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {MerkleProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const transactions = [];\n        for (let i = 0; i < count; ++i) {\n            transactions.push(Transaction.unserialize(buf));\n        }\n        const proof = MerkleProof.unserialize(buf);\n        return new TransactionsProof(transactions, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._transactions.length);\n        for (const transaction of this._transactions) {\n            transaction.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._transactions.reduce((sum, transaction) => sum + transaction.serializedSize, 0)\n            + this._proof.serializedSize;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `TransactionsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.computeRoot(this._transactions);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {MerkleProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProof);\n","class TransactionCache {\n    /**\n     * @param {Iterable.<Transaction>} [transactions]\n     * @param {Array.<Block>} [blockOrder]\n     */\n    constructor(transactions = [], blockOrder = []) {\n        /** @type {HashSet.<Transaction>} */\n        this._transactions = new HashSet(tx => tx.hash().toBase64());\n        this._transactions.addAll(transactions);\n        /** @type {Array.<Block>} */\n        this._blockOrder = blockOrder;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    containsTransaction(transaction) {\n        return this._transactions.contains(transaction);\n    }\n\n    /**\n     * @param {Block} block\n     */\n    pushBlock(block) {\n        this._blockOrder.push(block);\n        this._transactions.addAll(block.transactions);\n\n        if (this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            this.shiftBlock();\n        }\n    }\n\n    shiftBlock() {\n        const block = this._blockOrder.shift();\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {number}\n     */\n    revertBlock(block) {\n        if (this._transactions.isEmpty()) {\n            return this.missingBlocks;\n        }\n\n        const blockFromOrder = this._blockOrder.pop();\n        Assert.that(blockFromOrder.equals(block), 'Invalid block to revert');\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n\n        return this.missingBlocks;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     */\n    prependBlocks(blocks) {\n        if (blocks.length + this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            throw new Error('Exceeding transaction cache size');\n        }\n        this._blockOrder.unshift(...blocks);\n        blocks.forEach(b => this._transactions.addAll(b.transactions));\n    }\n\n    /** @type {number} */\n    get missingBlocks() {\n        return Policy.TRANSACTION_VALIDITY_WINDOW - this._blockOrder.length;\n    }\n\n    /** @type {HashSet.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /**\n     * @returns {TransactionCache}\n     */\n    clone() {\n        return new TransactionCache(/** @type {Iterable.<Transaction>} */ this._transactions, this._blockOrder.slice());\n    }\n}\nClass.register(TransactionCache);\n","class TransactionStoreEntry {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {number} blockHeight\n     * @param {Hash} blockHash\n     * @param {number} index\n     */\n    constructor(transactionHash, sender, recipient, blockHeight, blockHash, index) {\n        this._transactionHash = transactionHash;\n        this._sender = sender;\n        this._recipient = recipient;\n        this._blockHeight = blockHeight;\n        this._blockHash = blockHash;\n        this._index = index;\n        this.senderKey = sender.toBase64();\n        this.recipientKey = recipient.toBase64();\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Array.<TransactionStoreEntry>}\n     */\n    static fromBlock(block) {\n        const blockHash = block.hash();\n        /** @type {Array.<TransactionStoreEntry>} */\n        const entries = [];\n        for (let i = 0; i < block.transactions.length; ++i) {\n            const transaction = block.transactions[i];\n            entries.push(new TransactionStoreEntry(transaction.hash(), transaction.sender, transaction.recipient, block.height, blockHash, i));\n        }\n        return entries;\n    }\n\n    /**\n     * @param {string} transactionKey\n     * @param {{senderKey: string, recipientKey: string, blockHeight: number, blockHash: string, index: number}} o\n     * @returns {TransactionStoreEntry}\n     */\n    static fromJSON(transactionKey, o) {\n        return new TransactionStoreEntry(\n            Hash.fromBase64(transactionKey),\n            Address.fromBase64(o.senderKey),\n            Address.fromBase64(o.recipientKey),\n            o.blockHeight,\n            Hash.fromBase64(o.blockHash),\n            o.index\n        );\n    }\n\n    /**\n     * @returns {{senderKey: string, recipientKey: string, blockHeight: number, blockHash: string, index: number}}\n     */\n    toJSON() {\n        return {\n            senderKey: this.senderKey,\n            recipientKey: this.recipientKey,\n            blockHeight: this.blockHeight,\n            blockHash: this.blockHash.toBase64(),\n            index: this.index\n        };\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {number} */\n    get blockHeight() {\n        return this._blockHeight;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {number} */\n    get index() {\n        return this._index;\n    }\n\n    /** @type {string} */\n    get key() {\n        return this.transactionHash.toBase64();\n    }\n}\nClass.register(TransactionStoreEntry);\n","class TransactionStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        const store = jdb.createObjectStore('Transactions', new TransactionStoreCodec());\n        store.createIndex('sender', 'senderKey', true);\n        store.createIndex('recipient', 'recipientKey', true);\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {TransactionStore}\n     */\n    static getPersistent(jdb) {\n        return new TransactionStore(jdb.getObjectStore('Transactions'));\n    }\n\n    /**\n     * @returns {TransactionStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        store.createIndex('sender', 'senderKey', true);\n        store.createIndex('recipient', 'recipientKey', true);\n        return new TransactionStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<TransactionStoreEntry>}\n     */\n    get(transactionHash) {\n        return this._store.get(transactionHash.toBase64());\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    getBySender(sender) {\n        const index = this._store.index('sender');\n        return index.values(JDB.KeyRange.only(sender.toBase64()));\n    }\n\n    /**\n     * @param {Address} recipient\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    getByRecipient(recipient) {\n        const index = this._store.index('recipient');\n        return index.values(JDB.KeyRange.only(recipient.toBase64()));\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async put(block) {\n        const indexedTransactions = await TransactionStoreEntry.fromBlock(block);\n        const tx = this._store.transaction();\n        const promises = [];\n        for (const indexedTransaction of indexedTransactions) {\n            promises.push(tx.put(indexedTransaction.key, indexedTransaction));\n        }\n        await Promise.all(promises);\n        return tx.commit();\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async remove(block) {\n        const tx = this._store.transaction();\n        const promises = [];\n        for (const transaction of block.transactions) {\n            promises.push(tx.remove(transaction.hash().toBase64()));\n        }\n        await Promise.all(promises);\n        return tx.commit();\n    }\n\n    /**\n     * @param {TransactionStore} [tx]\n     * @returns {TransactionStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new TransactionStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {TransactionStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new TransactionStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(TransactionStore);\n\n/**\n * @implements {ICodec}\n */\nclass TransactionStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.toJSON();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return TransactionStoreEntry.fromJSON(key, obj);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n","class TransactionReceipt {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Hash} blockHash\n     */\n    constructor(transactionHash, blockHash) {\n        this._transactionHash = transactionHash;\n        this._blockHash = blockHash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceipt}\n     */\n    static unserialize(buf) {\n        const transactionHash = Hash.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        return new TransactionReceipt(transactionHash, blockHash);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._transactionHash.serialize(buf);\n        this._blockHash.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._transactionHash.serializedSize\n            + this._blockHash.serializedSize;\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(TransactionReceipt);\n","class Block {\n    /**\n     * @param {Block} o\n     * @returns {Block}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Block(\n            BlockHeader.copy(o._header),\n            BlockInterlink.copy(o._interlink),\n            BlockBody.copy(o._body)\n        );\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw 'Malformed header';\n        if (!(interlink instanceof BlockInterlink)) throw 'Malformed interlink';\n        if (body && !(body instanceof BlockBody)) throw 'Malformed body';\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const {valid, pow, interlinkHash, bodyHash} = await Crypto.blockVerify(this.serialize(), transactionValid, time.now());\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!Block.GENESIS.HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    if (!BlockUtils.isProofOfWork(prevPow, Math.pow(2, targetHeight - depth))) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.height.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                }\n                else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        // Compute the depth of this block relative to the next target.\n        const pow = await this.pow();\n        const thisPowDepth = BlockUtils.getTargetDepth(BlockUtils.hashToTarget(pow));\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        let depth = thisPowDepth - nextTargetDepth;\n\n        // Start constructing the next interlink.\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Push the current blockHash depth + 1 times onto the next interlink. If depth < 0, it won't be pushed.\n        for (let i = 0; i <= depth; i++) {\n            hashes.push(hash);\n        }\n\n        // Push the remaining hashes from the current interlink. If the target depth increases (i.e. the difficulty\n        // increases), we omit the block(s) at the beginning of the current interlink as they are not eligible for\n        // inclusion anymore.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const offset = nextTargetDepth - thisTargetDepth;\n        for (let j = depth + offset + 1; j < this.interlink.length; j++) {\n            hashes.push(this.interlink.hashes[j]);\n        }\n        \n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw 'Cannot access body of light block';\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {number}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {number}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n    \n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body.minerAddr;\n    }\n\n    /**\n     * @type {Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body.transactions;\n    }\n\n    /**\n     * @type {number}\n     */\n    get transactionCount() {\n        return this._body.transactionCount;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    hashAsync(buf) {\n        return this._header.hashAsync(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n}\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @interface\n */\nclass IBlockchain extends Observable {\n    /**\n     * @abstract\n     * @type {Block}\n     */\n    get head() {}\n\n    /**\n     * @abstract\n     * @type {Hash}\n     */\n    get headHash() {}\n\n    /**\n     * @abstract\n     * @type {number}\n     */\n    get height() {}\n}\nClass.register(IBlockchain);\n","/**\n * @abstract\n */\nclass BaseChain extends IBlockchain {\n    /**\n     * @param {ChainDataStore} store\n     */\n    constructor(store) {\n        super();\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     */\n    async getBlock(hash, includeForks = false) {\n        const chainData = await this._store.getChainData(hash);\n        return chainData && (chainData.onMainChain || includeForks) ? chainData.head : null;\n    }\n\n    /**\n     * @param {number} height\n     * @returns {Promise.<?Block>}\n     */\n    getBlockAt(height) {\n        return this._store.getBlockAt(height) || null;\n    }\n\n    /**\n     * Computes the target value for the block after the given block or the head of this chain if no block is given.\n     * @param {Block} [block]\n     * @returns {Promise.<number>}\n     */\n    async getNextTarget(block) {\n        /** @type {ChainData} */\n        let headData;\n        if (block) {\n            const hash = block.hash();\n            headData = await this._store.getChainData(hash);\n            Assert.that(!!headData);\n        } else {\n            block = this.head;\n            headData = this._mainChain;\n        }\n\n        // Retrieve the timestamp of the block that appears DIFFICULTY_BLOCK_WINDOW blocks before the given block in the chain.\n        // The block might not be on the main chain.\n        const tailHeight = Math.max(block.height - Policy.DIFFICULTY_BLOCK_WINDOW, 1);\n        /** @type {ChainData} */\n        let tailData;\n        if (headData.onMainChain) {\n            tailData = await this._store.getChainDataAt(tailHeight);\n        } else {\n            let prevData = headData;\n            for (let i = 0; i < Policy.DIFFICULTY_BLOCK_WINDOW && !prevData.onMainChain; i++) {\n                prevData = await this._store.getChainData(prevData.head.prevHash);\n                if (!prevData) {\n                    // Not enough blocks are available to compute the next target, fail.\n                    return -1;\n                }\n            }\n\n            if (prevData.onMainChain && prevData.head.height > tailHeight) {\n                tailData = await this._store.getChainDataAt(tailHeight);\n            } else {\n                tailData = prevData;\n            }\n        }\n\n        if (!tailData || tailData.totalDifficulty < 1) {\n            // Not enough blocks are available to compute the next target, fail.\n            return -1;\n        }\n\n        const deltaTotalDifficulty = headData.totalDifficulty - tailData.totalDifficulty;\n        return BlockUtils.getNextTarget(headData.head.header, tailData.head.header, deltaTotalDifficulty);\n    }\n\n\n\n    /* NIPoPoW Prover functions */\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    async _getChainProof() {\n        const snapshot = this._store.snapshot();\n        const chain = new BaseChainSnapshot(snapshot, this.head);\n        const proof = await chain._prove(Policy.M, Policy.K, Policy.DELTA);\n        snapshot.abort().catch(Log.w.tag(BaseChain));\n        return proof;\n    }\n\n    /**\n     * The \"Prove\" algorithm from the NIPoPow paper.\n     * @param {number} m\n     * @param {number} k\n     * @param {number} delta\n     * @returns {Promise.<ChainProof>}\n     * @private\n     */\n    async _prove(m, k, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        Assert.that(delta > 0, 'delta must be > 0');\n        let prefix = new BlockChain([]);\n\n        // B <- C[0]\n        let startHeight = 1;\n\n        const head = await this.getBlockAt(Math.max(this.height - k, 1)); // C[-k]\n        const maxDepth = Math.max(BlockUtils.getTargetDepth(head.target) + head.interlink.length - 1, 0); // |C[-k].interlink|\n        // for mu = |C[-k].interlink| down to 0 do\n        for (let depth = maxDepth; depth >= 0; depth--) {\n            // alpha = C[:-k]{B:}|^mu\n            const alpha = await this._getSuperChain(depth, head, startHeight); // eslint-disable-line no-await-in-loop\n\n            // pi = pi (union) alpha\n            prefix = BlockChain.merge(prefix, alpha);\n\n            // if good_(delta,m)(C, alpha, mu) then\n            if (BaseChain._isGoodSuperChain(alpha, depth, m, delta)) {\n                Assert.that(alpha.length >= m, `Good superchain expected to be at least ${m} long`);\n                Log.v(BaseChain, `Found good superchain at depth ${depth} with length ${alpha.length} (#${startHeight} - #${head.height})`);\n                // B <- alpha[-m]\n                startHeight = alpha.blocks[alpha.length - m].height;\n            }\n        }\n\n        // X <- C[-k:]\n        const suffix = await this._getHeaderChain(this.height - head.height);\n\n        // return piX\n        return new ChainProof(prefix, suffix);\n    }\n\n    /**\n     * @param {number} depth\n     * @param {Block} [head]\n     * @param {number} [tailHeight]\n     * @returns {Promise.<BlockChain>}\n     * @private\n     */\n    async _getSuperChain(depth, head = this.head, tailHeight = 1) {\n        Assert.that(tailHeight >= 1, 'tailHeight must be >= 1');\n        const blocks = [];\n\n        // Include head if it is at the requested depth or below.\n        const headPow = await head.pow();\n        const headDepth = BlockUtils.getTargetDepth(BlockUtils.hashToTarget(headPow));\n        if (headDepth >= depth) {\n            blocks.push(head.toLight());\n        }\n\n        // Follow the interlink pointers back at the requested depth.\n        let j = Math.max(depth - BlockUtils.getTargetDepth(head.target), -1);\n        while (j < head.interlink.hashes.length && head.height > tailHeight) {\n            const reference = j < 0 ? head.prevHash : head.interlink.hashes[j];\n            head = await this.getBlock(reference); // eslint-disable-line no-await-in-loop\n            if (!head) {\n                // This can happen in the light/nano client if chain superquality is harmed.\n                // Return a best-effort chain in this case.\n                Log.w(BaseChain, `Failed to find block ${reference} while constructing SuperChain at depth ${depth} - returning truncated chain`);\n                break;\n            }\n            blocks.push(head.toLight());\n\n            j = Math.max(depth - BlockUtils.getTargetDepth(head.target), -1);\n        }\n\n        if ((blocks.length === 0 || blocks[blocks.length - 1].height > 1) && tailHeight === 1) {\n            blocks.push(Block.GENESIS.toLight());\n        }\n\n        return new BlockChain(blocks.reverse());\n    }\n\n    /**\n     * @param {BlockChain} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     */\n    static _isGoodSuperChain(superchain, depth, m, delta) {\n        // TODO multilevel quality\n        return BaseChain._hasSuperQuality(superchain, depth, m, delta);\n    }\n\n    /**\n     * @param {BlockChain} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _hasSuperQuality(superchain, depth, m, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        if (superchain.length < m) {\n            return false;\n        }\n\n        for (let i = m; i <= superchain.length; i++) {\n            const underlyingLength = superchain.head.height - superchain.blocks[superchain.length - i].height + 1;\n            if (!BaseChain._isLocallyGood(i, underlyingLength, depth, delta)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {number} superLength\n     * @param {number} underlyingLength\n     * @param {number} depth\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _isLocallyGood(superLength, underlyingLength, depth, delta) {\n        // |C'| > (1 - delta) * 2^(-mu) * |C|\n        return superLength > (1 - delta) * Math.pow(2, -depth) * underlyingLength;\n    }\n\n    /**\n     * @param {number} length\n     * @param {Block} [head]\n     * @returns {Promise.<HeaderChain>}\n     * @private\n     */\n    async _getHeaderChain(length, head = this.head) {\n        const headers = [];\n        while (head && headers.length < length) {\n            headers.push(head.header);\n            head = await this.getBlock(head.prevHash); // eslint-disable-line no-await-in-loop\n        }\n        return new HeaderChain(headers.reverse());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {BlockHeader} header\n     * @param {boolean} [failOnBadness]\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    async _extendChainProof(proof, header, failOnBadness = true) {\n        // Append new header to proof suffix.\n        const suffix = proof.suffix.headers.slice();\n        suffix.push(header);\n\n        // If the suffix is not long enough (short chain), we're done.\n        const prefix = proof.prefix.blocks.slice();\n        if (suffix.length <= Policy.K) {\n            return new ChainProof(new BlockChain(prefix), new HeaderChain(suffix));\n        }\n\n        // Cut the tail off the suffix.\n        const suffixTail = suffix.shift();\n\n        // Construct light block out of the old suffix tail.\n        const interlink = await proof.prefix.head.getNextInterlink(suffixTail.target, suffixTail.version);\n        const prefixHead = new Block(suffixTail, interlink);\n\n        // Append old suffix tail block to prefix.\n        prefix.push(prefixHead);\n\n        // Extract layered superchains from prefix. Make a copy because we are going to change the chains array.\n        const chains = (await proof.getSuperChains()).slice();\n\n        // Append new prefix head to chains.\n        const target = BlockUtils.hashToTarget(await prefixHead.pow());\n        const depth = BlockUtils.getTargetDepth(target);\n        for (let i = depth; i >= 0; i--) {\n            // Append block. Don't modify the chain, create a copy.\n            if (!chains[i]) {\n                chains[i] = new BlockChain([prefixHead]);\n            } else {\n                chains[i] = new BlockChain([...chains[i].blocks, prefixHead]);\n            }\n        }\n\n        // If the new header isn't a superblock, we're done.\n        if (depth - BlockUtils.getTargetDepth(prefixHead.target) <= 0) {\n            return new ChainProof(new BlockChain(prefix), new HeaderChain(suffix), chains);\n        }\n\n        // Prune unnecessary blocks if the chain is good.\n        // Try to extend proof if the chain is bad.\n        const deletedBlockHeights = new Set();\n        for (let i = depth; i >= 0; i--) {\n            const superchain = chains[i];\n            if (superchain.length < Policy.M) {\n                continue;\n            }\n\n            if (BaseChain._isGoodSuperChain(superchain, i, Policy.M, Policy.DELTA)) {\n                // Remove all blocks in lower chains up to (including) superchain[-m].\n                const referenceBlock = superchain.blocks[superchain.length - Policy.M];\n                for (let j = i - 1; j >= 0; j--) {\n                    let numBlocksToDelete = 0;\n                    let candidateBlock = chains[j].blocks[numBlocksToDelete];\n                    while (candidateBlock.height <= referenceBlock.height) {\n                        const candidateTarget = BlockUtils.hashToTarget(await candidateBlock.pow());\n                        const candidateDepth = BlockUtils.getTargetDepth(candidateTarget);\n                        if (candidateDepth === j && candidateBlock.height > 1) {\n                            deletedBlockHeights.add(candidateBlock.height);\n                        }\n\n                        numBlocksToDelete++;\n                        candidateBlock = chains[j].blocks[numBlocksToDelete];\n                    }\n\n                    if (numBlocksToDelete > 0) {\n                        // Don't modify the chain, create a copy.\n                        chains[j] = new BlockChain(chains[j].blocks.slice(numBlocksToDelete));\n                    }\n                }\n            } else {\n                Log.w(BaseChain, `Chain quality badness detected at depth ${i}`);\n                // TODO extend superchains at lower levels\n                if (failOnBadness) {\n                    return null;\n                }\n            }\n        }\n\n        // Remove all deleted blocks from prefix.\n        const newPrefix = new BlockChain(prefix.filter(block => !deletedBlockHeights.has(block.height)));\n\n        // Return the extended proof.\n        return new ChainProof(newPrefix, new HeaderChain(suffix), chains);\n    }\n\n\n    /* NiPoPoW Verifier functions */\n\n    /**\n     * @param {ChainProof} proof1\n     * @param {ChainProof} proof2\n     * @param {number} m\n     * @returns {boolean}\n     */\n    static async isBetterProof(proof1, proof2, m) {\n        const lca = BlockChain.lowestCommonAncestor(proof1.prefix, proof2.prefix);\n        const score1 = await NanoChain._getProofScore(proof1.prefix, lca, m);\n        const score2 = await NanoChain._getProofScore(proof2.prefix, lca, m);\n        return score1 === score2\n            ? proof1.suffix.totalDifficulty() >= proof2.suffix.totalDifficulty()\n            : score1 > score2;\n    }\n\n    /**\n     *\n     * @param {BlockChain} chain\n     * @param {Block} lca\n     * @param {number} m\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    static async _getProofScore(chain, lca, m) {\n        const counts = [];\n        for (const block of chain.blocks) {\n            if (block.height < lca.height) {\n                continue;\n            }\n\n            const target = BlockUtils.hashToTarget(await block.pow()); // eslint-disable-line no-await-in-loop\n            const depth = BlockUtils.getTargetDepth(target);\n            counts[depth] = counts[depth] ? counts[depth] + 1 : 1;\n        }\n\n        let sum = 0;\n        let depth;\n        for (depth = counts.length - 1; sum < m && depth >= 0; depth--) {\n            sum += counts[depth] ? counts[depth] : 0;\n        }\n\n        let maxScore = Math.pow(2, depth + 1) * sum;\n        let length = sum;\n        for (let i = depth; i >= 0; i--) {\n            length += counts[i] ? counts[i] : 0;\n            const score = Math.pow(2, i) * length;\n            maxScore = Math.max(maxScore, score);\n        }\n\n        return maxScore;\n    }\n}\nClass.register(BaseChain);\n\nclass BaseChainSnapshot extends BaseChain {\n    /**\n     * @param {ChainDataStore} store\n     * @param {Block} head\n     */\n    constructor(store, head) {\n        super(store);\n        this._head = head;\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._head;\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._head.height;\n    }\n}\nClass.register(BaseChainSnapshot);\n","class BlockChain {\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {BlockChain}\n     */\n    static merge(chain1, chain2) {\n        const merged = [];\n        let i1 = 0, i2 = 0;\n        while (i1 < chain1.length && i2 < chain2.length) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.height === block2.height) {\n                Assert.that(block1.equals(block2), 'Encountered different blocks at same height during chain merge');\n                merged.push(block1);\n                i1++;\n                i2++;\n            } else if (block1.height < block2.height) {\n                merged.push(block1);\n                i1++;\n            } else {\n                merged.push(block2);\n                i2++;\n            }\n        }\n\n        for (; i1 < chain1.length; i1++) {\n            merged.push(chain1.blocks[i1]);\n        }\n        for (; i2 < chain2.length; i2++) {\n            merged.push(chain2.blocks[i2]);\n        }\n\n        return new BlockChain(merged);\n    }\n\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {?Block}\n     */\n    static lowestCommonAncestor(chain1, chain2) {\n        let i1 = chain1.length - 1;\n        let i2 = chain2.length - 1;\n        while (i1 >= 0 && i2 >= 0) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.equals(block2)) {\n                return block1;\n            } else if (block1.height > block2.height) {\n                i1--;\n            } else {\n                i2--;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     */\n    constructor(blocks) {\n        if (!blocks || !NumberUtils.isUint16(blocks.length)\n            || blocks.some(it => !(it instanceof Block) || !it.isLight())) throw new Error('Malformed blocks');\n\n        /** @type {Array.<Block>} */\n        this._blocks = blocks;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const blocks = [];\n        for (let i = 0; i < count; i++) {\n            blocks.push(Block.unserialize(buf));\n        }\n        return new BlockChain(blocks);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._blocks.length);\n        for (const block of this._blocks) {\n            block.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._blocks.reduce((sum, block) => sum + block.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all blocks in the chain are valid successors of one another.\n        for (let i = this._blocks.length - 1; i >= 1; i--) {\n            if (!(await this._blocks[i].isSuccessorOf(this._blocks[i - 1]))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array.<Block>}\n     */\n    denseSuffix() {\n        // Compute the dense suffix.\n        const denseSuffix = [this.head];\n        let denseSuffixHead = this.head;\n        for (let i = this.length - 2; i >= 0; i--) {\n            const block = this.blocks[i];\n            const hash = block.hash();\n            if (!hash.equals(denseSuffixHead.prevHash)) {\n                break;\n            }\n\n            denseSuffix.push(block);\n            denseSuffixHead = block;\n        }\n        denseSuffix.reverse();\n        return denseSuffix;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAnchored() {\n        return Block.GENESIS.HASH.equals(this.tail.hash());\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `BlockChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._blocks.length;\n    }\n\n    /** @type {Array.<Block>} */\n    get blocks() {\n        return this._blocks;\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._blocks[this.length - 1];\n    }\n\n    /** @type {Block} */\n    get tail() {\n        return this._blocks[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._blocks.reduce((sum, block) => sum + BlockUtils.targetToDifficulty(block.target), 0);\n    }\n}\nClass.register(BlockChain);\n","class HeaderChain {\n    /**\n     * @param {Array.<BlockHeader>} headers\n     */\n    constructor(headers) {\n        if (!headers || !Array.isArray(headers) || !NumberUtils.isUint16(headers.length)\n            || headers.some(it => !(it instanceof BlockHeader))) throw new Error('Malformed headers');\n\n        /** @type {Array.<BlockHeader>} */\n        this._headers = headers;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {HeaderChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const headers = [];\n        for (let i = 0; i < count; i++) {\n            headers.push(BlockHeader.unserialize(buf));\n        }\n        return new HeaderChain(headers);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._headers.length);\n        for (const header of this._headers) {\n            header.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._headers.reduce((sum, header) => sum + header.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all headers in the chain are valid successors of one another.\n        for (let i = this._headers.length - 1; i >= 1; i--) {\n            if (!this._headers[i].isImmediateSuccessorOf(this._headers[i - 1])) {\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `HeaderChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._headers.length;\n    }\n\n    /** @type {Array.<BlockHeader>} */\n    get headers() {\n        return this._headers;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._headers[this.length - 1];\n    }\n\n    /** @type {BlockHeader} */\n    get tail() {\n        return this._headers[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._headers.reduce((sum, header) => sum + BlockUtils.targetToDifficulty(header.target), 0);\n    }\n}\nClass.register(HeaderChain);\n","class ChainProof {\n    /**\n     * @param {BlockChain} prefix\n     * @param {HeaderChain} suffix\n     * @param {Array.<BlockChain>} [superChains]\n     */\n    constructor(prefix, suffix, superChains) {\n        if (!(prefix instanceof BlockChain) || !prefix.length) throw new Error('Malformed prefix');\n        if (!(suffix instanceof HeaderChain)) throw new Error('Malformed suffix');\n\n        /** @type {BlockChain} */\n        this._prefix = prefix;\n        /** @type {HeaderChain} */\n        this._suffix = suffix;\n        /** @type {?Array.<BlockChain>} */\n        this._chains = superChains;\n    }\n\n    static unserialize(buf) {\n        const prefix = BlockChain.unserialize(buf);\n        const suffix = HeaderChain.unserialize(buf);\n        return new ChainProof(prefix, suffix);\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._prefix.serialize(buf);\n        this._suffix.serialize(buf);\n        return buf;\n    }\n\n    get serializedSize() {\n        return this._prefix.serializedSize\n            + this._suffix.serializedSize;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // Check that the prefix chain is anchored.\n        if (!this._prefix.isAnchored()) {\n            return false;\n        }\n\n        // Check that both prefix and suffix are valid chains.\n        if (!(await this._prefix.verify()) || !(await this._suffix.verify())) {\n            return false;\n        }\n\n        // Check that the suffix connects to the prefix.\n        if (this._suffix.length > 0 && !this._suffix.tail.isImmediateSuccessorOf(this._prefix.head.header)) {\n            return false;\n        }\n\n        // Verify the block targets where possible.\n        if (!this._verifyDifficulty()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyDifficulty() {\n        // Extract the dense suffix of the prefix.\n        /** Array.<BlockHeader> */\n        const denseSuffix = this.prefix.denseSuffix().map(block => block.header);\n        /** Array.<BlockHeader> */\n        const denseChain = denseSuffix.concat(this.suffix.headers);\n\n        // Compute totalDifficulty for each block of the dense chain.\n        let totalDifficulty = 0;\n        const totalDifficulties = [];\n        for (let i = 0; i < denseChain.length; i++) {\n            totalDifficulty += denseChain[i].difficulty;\n            totalDifficulties[i] = totalDifficulty;\n        }\n\n        let headIndex = denseChain.length - 2;\n        let tailIndex = headIndex - Policy.DIFFICULTY_BLOCK_WINDOW;\n        while (tailIndex >= 0 && headIndex >= 0) {\n            const headBlock = denseChain[headIndex];\n            const tailBlock = denseChain[tailIndex];\n            const deltaTotalDifficulty = totalDifficulties[headIndex] - totalDifficulties[tailIndex];\n            const target = BlockUtils.getNextTarget(headBlock, tailBlock, deltaTotalDifficulty);\n            const nBits = BlockUtils.targetToCompact(target);\n\n            /** @type {BlockHeader} */\n            const checkBlock = denseChain[headIndex + 1];\n            if (checkBlock.nBits !== nBits) {\n                Log.w(ChainProof, `Block target mismatch: expected=${nBits}, got=${checkBlock.nBits}`);\n                return false;\n            }\n\n            --headIndex;\n            if (tailIndex !== 0 || tailBlock.height !== 1) {\n                --tailIndex;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {Promise.<Array.<BlockChain>>}\n     */\n    async getSuperChains() {\n        if (!this._chains) {\n            this._chains = [];\n            for (let i = 0; i < this._prefix.length; i++) {\n                const block = this._prefix.blocks[i];\n                const target = BlockUtils.hashToTarget(await block.pow());\n                const depth = BlockUtils.getTargetDepth(target);\n\n                if (this._chains[depth]) {\n                    this._chains[depth].blocks.push(block);\n                } else if (!this._chains[depth]) {\n                    this._chains[depth] = new BlockChain([block]);\n                }\n\n                for (let j = depth - 1; j >= 0; j--) {\n                    if (this._chains[j]) {\n                        this._chains[j].blocks.push(block);\n                    } else {\n                        this._chains[j] = new BlockChain([]);\n                    }\n                }\n            }\n        }\n        return this._chains;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ChainProof{prefix=${this._prefix.length}, suffix=${this._suffix.length}, height=${this.head.height}}`;\n    }\n\n    /** @type {BlockChain} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {HeaderChain} */\n    get suffix() {\n        return this._suffix;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._suffix.length > 0 ? this._suffix.head : this._prefix.head.header;\n    }\n}\nClass.register(ChainProof);\n","class ChainData {\n    /**\n     * @param {ChainData} o\n     * @returns {ChainData}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const head = Block.unserialize(new SerialBuffer(o._head));\n        head.header._pow = Hash.unserialize(new SerialBuffer(o._pow));\n        return new ChainData(\n            head,\n            o._totalDifficulty,\n            o._totalWork,\n            o._onMainChain\n        );\n    }\n\n    /**\n     * @param {Block} head\n     * @param {number} totalDifficulty\n     * @param {number} totalWork\n     * @param {boolean} onMainChain\n     */\n    constructor(head, totalDifficulty, totalWork, onMainChain = false) {\n        this._head = head;\n        this._totalDifficulty = totalDifficulty;\n        this._totalWork = totalWork;\n        this._onMainChain = onMainChain;\n        this._height = head.height;\n    }\n\n    stripDown() {\n        Assert.that(this._head.header._pow instanceof Hash, 'Expected cashed PoW hash');\n        return {\n            _head: this._head.serialize(),\n            _totalDifficulty: this._totalDifficulty,\n            _totalWork: this._totalWork,\n            _onMainChain: this._onMainChain,\n            _height: this._height,\n            _pow: this._head.header._pow.serialize()\n        };\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._head;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._totalWork;\n    }\n\n    /** @type {boolean} */\n    get onMainChain() {\n        return this._onMainChain;\n    }\n\n    /** @type {boolean} */\n    set onMainChain(onMainChain) {\n        this._onMainChain = onMainChain;\n    }\n}\nClass.register(ChainData);\n","class ChainDataStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        const store = jdb.createObjectStore('ChainData', new ChainDataStoreCodec());\n        ChainDataStore._createIndexes(store);\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {ChainDataStore}\n     */\n    static getPersistent(jdb) {\n        return new ChainDataStore(jdb.getObjectStore('ChainData'));\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        ChainDataStore._createIndexes(store);\n        return new ChainDataStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     * @private\n     */\n    static _createIndexes(store) {\n        store.createIndex('height', ['_height']);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        /** @type {IObjectStore} */\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {Promise.<ChainData>}\n     */\n    getChainData(key) {\n        return this._store.get(key.toBase64());\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {ChainData} chainData\n     * @returns {Promise.<void>}\n     */\n    putChainData(key, chainData) {\n        return this._store.put(key.toBase64(), chainData);\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {Block}\n     */\n    async getBlock(key) {\n        const chainData = await this.getChainData(key);\n        return chainData ? chainData.head : undefined;\n    }\n\n    /**\n     * @param {number} height\n     * @returns {Promise.<?ChainData>}\n     */\n    async getChainDataAt(height) {\n        /** @type {Array.<ChainData>} */\n        const candidates = await this._store.values(JDB.Query.eq('height', height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                return chainData;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param {number} height\n     * @returns {Promise.<?Block>}\n     */\n    async getBlockAt(height) {\n        const chainData = await this.getChainDataAt(height);\n        return chainData ? chainData.head : undefined;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [lower]\n     * @returns {Promise.<?Block>}\n     */\n    async getNearestBlockAt(height, lower=true) {\n        const index = this._store.index('height');\n        /** @type {Array.<ChainData>} */\n        const candidates = lower ?\n            await index.maxValues(JDB.KeyRange.upperBound(height)) :\n            await index.minValues(JDB.KeyRange.lowerBound(height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                return chainData.head;\n            }\n        }\n\n        // TODO handle corrupted storage\n        throw new Error(`Failed to find main chain block at height ${height}`);\n    }\n\n    /**\n     * @param {number} startHeight\n     * @param {number} [count]\n     * @param {boolean} [forward]\n     * @returns {Promise.<Array.<Block>>}\n     */\n    async getBlocks(startHeight, count = 500, forward = true) {\n        if (count <= 0) {\n            return [];\n        }\n        if (!forward) {\n            startHeight = startHeight - count;\n        }\n        /** @type {Array.<ChainData>} */\n        let candidates = await this._store.values(JDB.Query.within('height', startHeight, startHeight + count - 1));\n        candidates = candidates\n            .filter(chainData => chainData.onMainChain)\n            .map(chainData => chainData.head);\n        const sortNumber = forward ? ((a, b) => a.height - b.height) : ((a, b) => b.height - a.height);\n        candidates.sort(sortNumber);\n        return candidates;\n    }\n\n    /**\n     * @returns {Promise.<Hash|undefined>}\n     */\n    async getHead() {\n        const key = await this._store.get('main');\n        return key ? Hash.fromBase64(key) : undefined;\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {Promise.<void>}\n     */\n    setHead(key) {\n        return this._store.put('main', key.toBase64());\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {ChainDataStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new ChainDataStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    snapshot() {\n        const snapshot = this._store.snapshot();\n        return new ChainDataStore(snapshot);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(ChainDataStore);\n\n/**\n * @implements {ICodec}\n */\nclass ChainDataStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return typeof obj === 'string' ? obj : obj.stripDown();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return typeof obj === 'string' ? obj : ChainData.copy(obj);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n","class MempoolTransactionSet {\n    /**\n     * @param {Array.<Transaction>} [sortedTransactions]\n     */\n    constructor(sortedTransactions) {\n        /** @type {SortedList.<Transaction>} */\n        this._transactions = new SortedList(sortedTransactions);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    add(transaction) {\n        this._transactions.add(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    remove(transaction) {\n        this._transactions.remove(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    copyAndAdd(transaction) {\n        const transactions = this._transactions.copy();\n        transactions.add(transaction);\n        return new MempoolTransactionSet(transactions.values());\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions.values();\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].sender : null;\n    }\n\n    /** @type {?Account.Type} */\n    get senderType() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].senderType : undefined;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /**\n     * @param {number} feePerByte\n     * @return {number}\n     */\n    numBelowFeePerByte(feePerByte) {\n        return this._transactions.values().filter(t => t.fee / t.serializedSize < feePerByte).length;\n    }\n\n    toString() {\n        return `MempoolTransactionSet{length=${this.length}}`;\n    }\n}\n\nClass.register(MempoolTransactionSet);\n","class Mempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     */\n    constructor(blockchain, accounts) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n\n        // Our pool of transactions.\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetByAddress = new HashMap();\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        // Listen for changes in the blockchain head to evict transactions that\n        // have become invalid.\n        blockchain.on('head-changed', () => this._evictTransactions());\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<Mempool.ReturnCode>}\n     */\n    pushTransaction(transaction) {\n        return this._synchronizer.push(() => this._pushTransaction(transaction));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<Mempool.ReturnCode>}\n     * @private\n     */\n    async _pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            Log.v(Mempool, () => `Ignoring known transaction ${hash.toBase64()}`);\n            return Mempool.ReturnCode.KNOWN;\n        }\n\n        const set = this._transactionSetByAddress.get(transaction.sender) || new MempoolTransactionSet();\n        // Check limit for free transactions.\n        if (transaction.fee / transaction.serializedSize < Mempool.TRANSACTION_RELAY_FEE_MIN\n            && set.numBelowFeePerByte(Mempool.TRANSACTION_RELAY_FEE_MIN) >= Mempool.FREE_TRANSACTIONS_PER_SENDER_MAX) {\n            return Mempool.ReturnCode.FEE_TOO_LOW;\n        }\n\n        // Intrinsic transaction verification\n        if (!transaction.verify()) {\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve recipient account and test incoming transaction.\n        /** @type {Account} */\n        let recipientAccount;\n        try {\n            recipientAccount = await this._accounts.get(transaction.recipient);\n            recipientAccount.withIncomingTransaction(transaction, this._blockchain.height + 1);\n        } catch (e) {\n            Log.w(Mempool, `Rejected transaction - ${e.message}`, transaction);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve sender account.\n        /** @type {Account} */\n        let senderAccount;\n        try {\n            senderAccount = await this._accounts.get(transaction.sender, transaction.senderType);\n        } catch (e) {\n            Log.w(Mempool, `Rejected transaction - ${e.message}`, transaction);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Add new transaction to the sender's pending transaction set. Then re-check all transactions in the set\n        // in fee/byte order against the sender account state. Adding high fee transactions may thus invalidate\n        // low fee transactions in the set.\n        const transactions = [];\n        let tmpAccount = senderAccount;\n        for (const tx of set.copyAndAdd(transaction).transactions) {\n            try {\n                tmpAccount = tmpAccount.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n                transactions.push(tx);\n            } catch (e) {\n                // If the rejected transaction is the one we're pushing, fail.\n                // Otherwise, evict the rejected transaction from the mempool.\n                if (tx.equals(transaction)) {\n                    Log.w(Mempool, `Rejected transaction - ${e.message}`, transaction);\n                    return Mempool.ReturnCode.INVALID;\n                } else {\n                    this._transactionsByHash.remove(tx.hash());\n                }\n            }\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByHash.put(hash, transaction);\n        this._transactionSetByAddress.put(transaction.sender, new MempoolTransactionSet(transactions));\n\n        // Tell listeners about the new valid transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return Mempool.ReturnCode.ACCEPTED;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} [maxSize]\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxSize = Infinity) {\n        const transactions = [];\n        let size = 0;\n        for (const tx of this._transactionsByHash.values().sort((a, b) => a.compare(b))) {\n            const txSize = tx.serializedSize;\n            if (size + txSize >= maxSize) continue;\n\n            transactions.push(tx);\n            size += txSize;\n        }\n\n        return transactions;\n    }\n\n    /**\n     * @param {number} maxSize\n     */\n    async getTransactionsForBlock(maxSize) {\n        const transactions = this.getTransactions(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        const prunedAccountsSize = prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n\n        let size = prunedAccountsSize + transactions.reduce((sum, tx) => sum + tx.serializedSize, 0); \n        while (size > maxSize) {\n            size -= transactions.pop().serializedSize;\n        }\n\n        transactions.sort((a, b) => a.compareBlockOrder(b));\n        return transactions;\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        const set = this._transactionSetByAddress.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    _evictTransactions() {\n        return this._synchronizer.push(() => this.__evictTransactions());\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    async __evictTransactions() {\n        // Evict all transactions from the pool that have become invalid due\n        // to changes in the account state (i.e. typically because the were included\n        // in a newly mined block). No need to re-check signatures.\n        for (const sender of this._transactionSetByAddress.keys()) {\n            /** @type {MempoolTransactionSet} */\n            const set = this._transactionSetByAddress.get(sender);\n\n            try {\n                const senderAccount = await this._accounts.get(set.sender, set.senderType);\n\n                // If a transaction in the set is not valid anymore,\n                // we try to construct a new set based on the heuristic of including\n                // high fee/byte transactions first.\n                const transactions = [];\n                let account = senderAccount;\n                for (const tx of set.transactions) {\n                    try {\n                        const tmpAccount = account.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n\n                        const recipientAccount = await this._accounts.get(tx.recipient);\n                        recipientAccount.withIncomingTransaction(tx, this._blockchain.height + 1);\n\n                        transactions.push(tx);\n                        account = tmpAccount;\n                    } catch (e) {\n                        this._transactionsByHash.remove(tx.hash());\n                    }\n                }\n                if (transactions.length === 0) {\n                    this._transactionSetByAddress.remove(sender);\n                } else {\n                    this._transactionSetByAddress.put(sender, new MempoolTransactionSet(transactions));\n                }\n            } catch (e) {\n                // In case of an error, remove all transactions of this set.\n                for (const tx of set.transactions) {\n                    this._transactionsByHash.remove(tx.hash());\n                }\n                this._transactionSetByAddress.remove(sender);\n            }\n        }\n\n        // Tell listeners that the pool has updated after a blockchain head change.\n        /**\n         * @event Mempool#transactions-ready\n         */\n        this.fire('transactions-ready');\n    }\n}\n\nMempool.TRANSACTION_RELAY_FEE_MIN = 1; // sat/byte; transactions below that threshold are considered \"free\"\nMempool.FREE_TRANSACTIONS_PER_SENDER_MAX = 10; // max number of transactions considered free per sender\n\n/** @enum {number} */\nMempool.ReturnCode = {\n    FEE_TOO_LOW: -2,\n    INVALID: -1,\n\n    ACCEPTED: 1,\n    KNOWN: 2\n};\n\nClass.register(Mempool);\n","/**\n * @abstract\n */\nclass BaseConsensusAgent extends Observable {\n    /**\n     * @param {Peer} peer\n     */\n    constructor(peer) {\n        super();\n        /** @type {Peer} */\n        this._peer = peer;\n\n        // Flag indicating that have synced our blockchain with the peer's.\n        /** @type {boolean} */\n        this._synced = false;\n\n        // Set of all objects (InvVectors) that we think the remote peer knows.\n        /** @type {HashSet.<InvVector>} */\n        this._knownObjects = new HashSet();\n        this._knownObjects.add(new InvVector(InvVector.Type.BLOCK, peer.headHash));\n\n        // InvVectors we want to request via getData are collected here and\n        // periodically requested.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsToRequest = new HashSet();\n\n        // Objects that are currently being requested from the peer.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsInFlight = new HashSet();\n\n        // All objects that were requested from the peer but not received yet.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsThatFlew = new HashSet();\n\n        // Objects that are currently being processed by the blockchain/mempool.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsProcessing = new HashSet();\n\n        // A Subscription object specifying which objects should be announced to the peer.\n        // Initially, we don't announce anything to the peer until it tells us otherwise.\n        /** @type {Subscription} */\n        this._remoteSubscription = Subscription.NONE;\n\n        // Helper object to keep track of timeouts & intervals.\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        // Queue of transaction inv vectors waiting to be sent out\n        /** @type {Queue.<InvVector>} */\n        this._waitingInvVectors = new Queue();\n        this._timers.setInterval('invVectors', () => this._sendWaitingInvVectors(), BaseConsensusAgent.TRANSACTION_RELAY_INTERVAL);\n\n        // Queue of \"free\" transaction inv vectors waiting to be sent out\n        /** @type {Queue.<{serializedSize:number, vector:InvVector}>} */\n        this._waitingFreeInvVectors = new Queue();\n        this._timers.setInterval('freeInvVectors', () => this._sendFreeWaitingInvVectors(), BaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL);\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('inv', msg => this._onInv(msg));\n        peer.channel.on('block', msg => this._onBlock(msg));\n        peer.channel.on('header', msg => this._onHeader(msg));\n        peer.channel.on('tx', msg => this._onTx(msg));\n        peer.channel.on('not-found', msg => this._onNotFound(msg));\n\n        peer.channel.on('subscribe', msg => this._onSubscribe(msg));\n        peer.channel.on('get-data', msg => this._onGetData(msg));\n        peer.channel.on('get-header', msg => this._onGetHeader(msg));\n\n        // Clean up when the peer disconnects.\n        peer.channel.on('close', () => this._onClose());\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    relayBlock(block) {\n        // Don't relay block if have not synced with the peer yet.\n        if (!this._synced) {\n            return false;\n        }\n\n        // Only relay block if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesBlock(block)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromBlock(block);\n\n        // Don't relay block to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay block to peer.\n        this._peer.channel.inv([vector, ...this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT - 1)]);\n\n        // Assume that the peer knows this block now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    _sendWaitingInvVectors() {\n        const invVectors = this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT);\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    _sendFreeWaitingInvVectors() {\n        const invVectors = [];\n        let size = 0;\n        while (invVectors.length <= BaseInventoryMessage.VECTORS_MAX_COUNT && this._waitingFreeInvVectors.length > 0\n            && size < BaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL) {\n            const {serializedSize, vector} = this._waitingFreeInvVectors.dequeue();\n            invVectors.push(vector);\n            size += serializedSize;\n        }\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    relayTransaction(transaction) {\n        // Only relay transaction if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesTransaction(transaction)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromTransaction(transaction);\n\n        // Don't relay transaction to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay transaction to peer later.\n        const serializedSize = transaction.serializedSize;\n        if (transaction.fee/serializedSize < BaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN) {\n            this._waitingFreeInvVectors.enqueue({serializedSize, vector});\n        } else {\n            this._waitingInvVectors.enqueue(vector);\n        }\n\n        // Assume that the peer knows this transaction now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {boolean}\n     */\n    knowsBlock(blockHash) {\n        const vector = new InvVector(InvVector.Type.BLOCK, blockHash);\n        return this._knownObjects.contains(vector);\n    }\n\n    /**\n     * @param {SubscribeMessage} msg\n     * @protected\n     */\n    _onSubscribe(msg) {\n        Log.d(BaseConsensusAgent, `[SUBSCRIBE] ${this._peer.peerAddress} ${msg.subscription}`);\n        this._remoteSubscription = msg.subscription;\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _onInv(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n            this._waitingInvVectors.remove(vector);\n        }\n\n        // Check which of the advertised objects we know\n        // Request unknown objects, ignore known ones.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            // Ignore objects that we are currently requesting / processing.\n            if (this._objectsInFlight.contains(vector) || this._objectsProcessing.contains(vector)) {\n                continue;\n            }\n\n            // Filter out objects that we are not interested in.\n            if (!this._shouldRequestData(vector)) {\n                continue;\n            }\n\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash, /*includeForks*/ true); // eslint-disable-line no-await-in-loop\n                    if (!block) {\n                        unknownObjects.push(vector);\n                        this._onNewBlockAnnounced(vector.hash);\n                    } else {\n                        this._onKnownBlockAnnounced(vector.hash, block);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const transaction = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (!transaction) {\n                        unknownObjects.push(vector);\n                        this._onNewTransactionAnnounced(vector.hash);\n                    } else {\n                        this._onKnownTransactionAnnounced(vector.hash, transaction);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        Log.v(BaseConsensusAgent, `[INV] ${msg.vectors.length} vectors (${unknownObjects.length} new) received from ${this._peer.peerAddress}`);\n\n        if (unknownObjects.length > 0) {\n            // Store unknown vectors in objectsToRequest.\n            this._objectsToRequest.addAll(unknownObjects);\n\n            // Clear the request throttle timeout.\n            this._timers.clearTimeout('inv');\n\n            // If there are enough objects queued up, send out a getData request.\n            if (this._objectsToRequest.length >= BaseConsensusAgent.REQUEST_THRESHOLD) {\n                this._requestData();\n            }\n            // Otherwise, wait a short time for more inv messages to arrive, then request.\n            else {\n                this._timers.setTimeout('inv', () => this._requestData(), BaseConsensusAgent.REQUEST_THROTTLE);\n            }\n        } else {\n            this._onNoUnknownObjects();\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     */\n    _shouldRequestData(vector) {\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @abstract\n     */\n    _getBlock(hash, includeForks = false) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @abstract\n     */\n    _getTransaction(hash) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewBlockAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     */\n    _onKnownBlockAnnounced(hash, block) {\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewTransactionAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {void}\n     * @protected\n     */\n    _onKnownTransactionAnnounced(hash, transaction) {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _requestData() {\n        // Only one request at a time.\n        if (!this._objectsInFlight.isEmpty()) return;\n\n        // Don't do anything if there are no objects queued to request.\n        if (this._objectsToRequest.isEmpty()) return;\n\n        // Request queued objects from the peer. Only request up to VECTORS_MAX_COUNT objects at a time.\n        const vectorsMaxCount = BaseInventoryMessage.VECTORS_MAX_COUNT;\n        /** @type {Array.<InvVector>} */\n        const vectors = Array.from(new LimitIterable(this._objectsToRequest.valueIterator(), vectorsMaxCount));\n\n        // Mark the requested objects as in-flight.\n        this._objectsInFlight.addAll(vectors);\n\n        // Remove requested objects from queue.\n        this._objectsToRequest.removeAll(vectors);\n\n        // Request data from peer.\n        this._doRequestData(vectors);\n\n        // Set timer to detect end of request / missing objects\n        this._timers.setTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     */\n    _doRequestData(vectors) {\n        this._peer.channel.getData(vectors);\n    }\n\n    /**\n     * @param {BlockMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onBlock(msg) {\n        const hash = msg.block.hash();\n\n        // Check if we have requested this block.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited block ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Reuse already known (verified) transactions\n        const transactions = msg.block.isFull() ? msg.block.body.transactions : [];\n        const transactionPromises = transactions.map(t => this._getTransaction(t.hash()));\n        for (let i = 0; i < transactions.length; i++) {\n            const transaction = await transactionPromises[i]; // eslint-disable-line no-await-in-loop\n            if (transaction) {\n                transactions[i] = transaction;\n            }\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process block.\n        this._objectsProcessing.add(vector);\n        await this._processBlock(hash, msg.block);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processBlock(hash, block) {\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onHeader(msg) {\n        const hash = msg.header.hash();\n\n        // Check if we have requested this header.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process header.\n        this._objectsProcessing.add(vector);\n        await this._processHeader(hash, msg.header);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processHeader(hash, header) {\n    }\n\n    /**\n     * @param {TxMessage} msg\n     * @return {Promise}\n     * @protected\n     */\n    async _onTx(msg) {\n        const hash = msg.transaction.hash();\n        //Log.d(BaseConsensusAgent, () => `[TX] Received transaction ${hash} from ${this._peer.peerAddress}`);\n\n        // Check if we have requested this transaction.\n        const vector = new InvVector(InvVector.Type.TRANSACTION, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited transaction ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process transaction.\n        this._objectsProcessing.add(vector);\n        await this._processTransaction(hash, msg.transaction);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processTransaction(hash, transaction) {\n    }\n\n    /**\n     * @param {NotFoundMessage} msg\n     * @returns {void}\n     * @protected\n     */\n    _onNotFound(msg) {\n        Log.d(BaseConsensusAgent, `[NOTFOUND] ${msg.vectors.length} unknown objects received from ${this._peer.peerAddress}`);\n\n        // Remove unknown objects from in-flight list.\n        for (const vector of msg.vectors) {\n            if (!this._objectsInFlight.contains(vector)) {\n                continue;\n            }\n\n            // Mark object as received.\n            this._onObjectReceived(vector);\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectReceived(vector) {\n        if (this._objectsInFlight.isEmpty()) return;\n\n        // Remove the vector from objectsInFlight.\n        this._objectsInFlight.remove(vector);\n\n        // Reset the request timeout if we expect more objects to come.\n        if (!this._objectsInFlight.isEmpty()) {\n            this._timers.resetTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n        } else {\n            this._noMoreData();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _noMoreData() {\n        // Cancel the request timeout timer.\n        this._timers.clearTimeout('getData');\n\n        // Reset objects in flight.\n        this._objectsThatFlew.addAll(this._objectsInFlight.values());\n        this._objectsInFlight.clear();\n\n        // If there are more objects to request, request them.\n        if (!this._objectsToRequest.isEmpty()) {\n            this._requestData();\n        } else {\n            this._onAllObjectsReceived();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onNoUnknownObjects() {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsReceived() {\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectProcessed(vector) {\n        // Remove the vector from objectsProcessing.\n        this._objectsProcessing.remove(vector);\n\n        if (this._objectsProcessing.isEmpty()) {\n            this._onAllObjectsProcessed();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsProcessed() {\n    }\n\n    /**\n     * @param {GetDataMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetData(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (block && block.isFull()) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.block(block);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const tx = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (tx) {\n                        // We have found a requested transaction, send it back to the sender.\n                        this._peer.channel.tx(tx);\n                    } else {\n                        // Requested transaction is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @param {GetHeaderMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetHeader(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (block) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.header(block.header);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION:\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onClose() {\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n\n        // Notify listeners that the peer has disconnected.\n        this.fire('close', this);\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @type {boolean} */\n    get synced() {\n        return this._synced;\n    }\n}\n/**\n * Number of InvVectors in invToRequest pool to automatically trigger a getData request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THRESHOLD = 50;\n/**\n * Time (ms) to wait after the last received inv message before sending getData.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THROTTLE = 500;\n/**\n * Maximum time (ms) to wait after sending out getData or receiving the last object for this request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_TIMEOUT = 1000 * 10;\n/**\n * Time interval (ms) to wait between sending out transactions.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_INTERVAL = 5000;\n/**\n * Time interval (ms) to wait between sending out \"free\" transactions.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL = 6000;\n/**\n * Soft limit for the total size (bytes) of free transactions per relay interval.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL = 15000; // ~100 legacy transactions\n/**\n * Minimum fee per byte (sat/byte) such that a transaction is not considered free.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN = 1;\nClass.register(BaseConsensusAgent);\n","/**\n * An anchored, contiguous chain of full blocks.\n */\nclass FullChain extends BaseChain {\n    /**\n     * @param {JungleDB} jdb\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static getPersistent(jdb, accounts, time, transactionStore) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static createVolatile(accounts, time, transactionStore) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {FullChain}\n     */\n    constructor(store, accounts, time, transactionStore) {\n        super(store);\n        this._accounts = accounts;\n        this._time = time;\n\n        /** @type {HashMap.<Hash,Accounts>} */\n        this._snapshots = new HashMap();\n        /** @type {Array.<Hash>} */\n        this._snapshotOrder = [];\n\n        /** @type {ChainData} */\n        this._mainChain = null;\n\n        /** @type {ChainProof} */\n        this._proof = null;\n\n        /** @type {TransactionCache} */\n        this._transactionCache = new TransactionCache();\n\n        /** @type {TransactionStore} */\n        this._transactionStore = transactionStore;\n\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        /** @type {number} */\n        this._blockKnownCount = this._blockInvalidCount = this._blockOrphanCount = this._blockExtendedCount = this._blockRebranchedCount = this._blockForkedCount = 0;\n    }\n\n    /**\n     * @returns {Promise.<FullChain>}\n     * @protected\n     */\n    async _init() {\n        this._headHash = await this._store.getHead();\n        if (this._headHash) {\n            // Load main chain from store.\n            this._mainChain = await this._store.getChainData(this._headHash);\n            Assert.that(!!this._mainChain, 'Failed to load main chain from storage');\n\n            // TODO Check if chain/accounts state is consistent!\n            Assert.that(this._mainChain.head.accountsHash.equals(await this._accounts.hash()), 'Corrupted store: Inconsistent chain/accounts state');\n\n            // Initialize TransactionCache.\n            const blocks = await this.getBlocks(this.head.height, this._transactionCache.missingBlocks - 1, false);\n            this._transactionCache.prependBlocks([...blocks.reverse(), this._mainChain.head]);\n        } else {\n            // Initialize chain & accounts with Genesis block.\n            this._mainChain = new ChainData(Block.GENESIS, Block.GENESIS.difficulty, BlockUtils.realDifficulty(await Block.GENESIS.pow()), true);\n            this._headHash = Block.GENESIS.HASH;\n\n            const tx = this._store.transaction();\n            await tx.putChainData(Block.GENESIS.HASH, this._mainChain);\n            await tx.setHead(Block.GENESIS.HASH);\n            await tx.commit();\n\n            await this._accounts.initialize(Block.GENESIS, Accounts.GENESIS);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    pushBlock(block) {\n        return this._synchronizer.push(() => {\n            return this._pushBlock(block);\n        });\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    async _pushBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            Log.v(FullChain, `Ignoring known block ${hash}`);\n            this._blockKnownCount++;\n            return FullChain.OK_KNOWN;\n        }\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(FullChain, 'Rejecting block - body missing');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        // if (!(await this._verifyInterlink(block))) {\n        //     Log.w(FullChain, 'Rejecting block - interlink verification failed');\n        //     return FullChain.ERR_INVALID;\n        // }\n\n        // Check if the block's immediate predecessor is part of the chain.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(FullChain, 'Rejecting block - unknown predecessor');\n            this._blockOrphanCount++;\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(FullChain, 'Rejecting block - not a valid immediate successor');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        Assert.that(BlockUtils.isValidTarget(nextTarget), 'Failed to compute next target in FullChain');\n        if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n            Log.w(FullChain, 'Rejecting block - difficulty mismatch');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Block looks good, create ChainData.\n        const totalDifficulty = prevData.totalDifficulty + block.difficulty;\n        const totalWork = prevData.totalWork + BlockUtils.realDifficulty(await block.pow());\n        const chainData = new ChainData(block, totalDifficulty, totalWork);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            if (!(await this._extend(hash, chainData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockExtendedCount++;\n            return FullChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (totalDifficulty > this.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            if (!(await this._rebranch(hash, chainData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockRebranchedCount++;\n            return FullChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(FullChain, `Creating/extending fork with block ${hash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(hash, chainData);\n\n        this._blockForkedCount++;\n        return FullChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _verifyInterlink(block) {\n        // Check that all blocks referenced in the interlink of the given block are valid predecessors of that block.\n        for (let i = 0; i < block.interlink.length; i++) {\n            const predecessor = await this._store.getBlock(block.interlink.hashes[i]); // eslint-disable-line no-await-in-loop\n            if (!predecessor || !(await block.isInterlinkSuccessorOf(predecessor))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @fires FullChain#head-changed\n     * @private\n     */\n    async _extend(blockHash, chainData) {\n        const accountsTx = await this._accounts.transaction();\n        try {\n            await accountsTx.commitBlock(chainData.head, this._transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(FullChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            accountsTx.abort().catch(Log.w.tag(FullChain));\n            return false;\n        }\n\n        chainData.onMainChain = true;\n\n        const tx = await this._store.transaction();\n        await tx.putChainData(blockHash, chainData);\n        await tx.setHead(blockHash);\n\n        if (this._transactionStore) {\n            const transactionStoreTx = this._transactionStore.transaction();\n            await transactionStoreTx.put(chainData.head);\n            await JDB.JungleDB.commitCombined(tx.tx, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(tx.tx, accountsTx.tx);\n        }\n\n        // New block on main chain, so store a new snapshot.\n        await this._saveSnapshot(blockHash);\n\n        // Update transactions cache.\n        this._transactionCache.pushBlock(chainData.head);\n\n        // Update chain proof if we have cached one.\n        if (this._proof) {\n            this._proof = await this._extendChainProof(this._proof, chainData.head.header);\n        }\n\n        // Update head.\n        this._mainChain = chainData;\n        this._headHash = blockHash;\n\n        // Tell listeners that the head of the chain has changed.\n        this.fire('head-changed', this.head, /*rebranching*/ false);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(FullChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Drop all snapshots.\n        for (const hash of this._snapshotOrder) {\n            const snapshot = this._snapshots.get(hash);\n            snapshot.abort(); // We do not need to wait for the abortion as long as it has been triggered.\n        }\n        this._snapshots.clear();\n        this._snapshotOrder = [];\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        const forkChain = [];\n        const forkHashes = [];\n\n        let curData = chainData;\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            // TODO FIXME This can fail in the light client. It might not have the requested block at all or only the light block.\n            curData = await this._store.getChainData(curHash); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Corrupted store: Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(FullChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        // Validate all accountsHashes on the fork. Revert the AccountsTree to the common ancestor state first.\n        const accountsTx = await this._accounts.transaction(false);\n        const transactionCacheTx = this._transactionCache.clone();\n        // Also update transactions in index.\n        const transactionStoreTx = this._transactionStore ? this._transactionStore.transaction() : null;\n\n        let headHash = this._headHash;\n        let head = this._mainChain.head;\n        while (!headHash.equals(curHash)) {\n            try {\n                // This only works if we revert less than Policy.TRANSACTION_VALIDITY_WINDOW blocks.\n                await accountsTx.revertBlock(head, transactionCacheTx);\n                transactionCacheTx.revertBlock(head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.remove(head);\n                }\n            } catch (e) {\n                Log.e(FullChain, 'Failed to revert main chain while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n\n            headHash = head.prevHash;\n            head = await this._store.getBlock(headHash);\n            Assert.that(!!head, 'Corrupted store: Failed to find main chain predecessor while rebranching');\n            Assert.that(head.accountsHash.equals(await accountsTx.hash()), 'Failed to revert main chain - inconsistent state');\n        }\n\n        // Try to fetch missing transactions for the cache.\n        // TODO FIXME The light client might not have all necessary blocks.\n        const numMissingBlocks = transactionCacheTx.missingBlocks;\n        const blocks = await this.getBlocks(head.height, numMissingBlocks, false);\n        transactionCacheTx.prependBlocks(blocks.reverse());\n\n        // Try to apply all fork blocks.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            try {\n                await accountsTx.commitBlock(forkChain[i].head, transactionCacheTx);\n                transactionCacheTx.pushBlock(forkChain[i].head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.put(forkChain[i].head);\n                }\n            } catch (e) {\n                // A fork block is invalid.\n                // TODO delete invalid block and its successors from store.\n                Log.e(FullChain, 'Failed to apply fork block while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n        }\n\n        // Fork looks good. Unset onMainChain flag on the current main chain up to (excluding) the common ancestor.\n        const chainTx = this._store.transaction(false);\n        headHash = this._headHash;\n        let headData = this._mainChain;\n        while (!headHash.equals(curHash)) {\n            headData.onMainChain = false;\n            await chainTx.putChainData(headHash, headData);\n\n            headHash = headData.head.prevHash;\n            headData = await chainTx.getChainData(headHash);\n            Assert.that(!!headData, 'Corrupted store: Failed to find main chain predecessor while rebranching');\n        }\n\n        // Set onMainChain flag on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            await chainTx.putChainData(forkHashes[i], forkData);\n        }\n\n        // Update head & commit transactions.\n        await chainTx.setHead(blockHash);\n        if (this._transactionStore) {\n            await JDB.JungleDB.commitCombined(chainTx.tx, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(chainTx.tx, accountsTx.tx);\n        }\n        this._transactionCache = transactionCacheTx;\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Fire head-changed event for each fork block.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param {number} startHeight\n     * @param {number} count\n     * @param {boolean} forward\n     * @returns {Promise.<Array.<Block>>}\n     */\n    getBlocks(startHeight, count = 500, forward = true) {\n        return this._store.getBlocks(startHeight, count, forward);\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    async getChainProof() {\n        if (!this._proof) {\n            this._proof = await this._getChainProof();\n        }\n        return this._proof;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @returns {Promise.<?AccountsTreeChunk>}\n     */\n    async getAccountsTreeChunk(blockHash, startPrefix) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsTreeChunk(startPrefix);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?AccountsProof>}\n     */\n    async getAccountsProof(blockHash, addresses) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?TransactionsProof>}\n     */\n    async getTransactionsProof(blockHash, addresses) {\n        const block = await this.getBlock(blockHash);\n        if (!block || !block.isFull()) {\n            return null;\n        }\n\n        const matches = [];\n        const addressesSet = new HashSet();\n        addressesSet.addAll(addresses);\n        for (const transaction of block.transactions) {\n            if (addressesSet.contains(transaction.sender) || addressesSet.contains(transaction.recipient)) {\n                matches.push(transaction);\n            }\n        }\n\n        const proof = MerkleProof.compute(block.body.getMerkleLeafs(), matches);\n        return new TransactionsProof(matches, proof);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     */\n    async getTransactionReceiptsByAddress(address) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const transactionReceipts = [];\n\n        const entriesBySender = await this._transactionStore.getBySender(address);\n        const entriesByRecipient = await this._transactionStore.getByRecipient(address);\n\n        entriesBySender.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash));\n        });\n\n        entriesByRecipient.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash));\n        });\n\n        return transactionReceipts;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<?TransactionStoreEntry>}\n     */\n    async getTransactionInfoByHash(transactionHash) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const txStoreEntry = await this._transactionStore.get(transactionHash);\n        if (!txStoreEntry) {\n            return null;\n        }\n\n        return txStoreEntry;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<?Accounts>}\n     */\n    _getSnapshot(blockHash) {\n        return this._synchronizer.push(async () => {\n            const block = await this.getBlock(blockHash);\n            // Check if blockHash is a block on the main chain within the allowed window.\n            if (!block || this._mainChain.head.height - block.height > Policy.NUM_SNAPSHOTS_MAX) {\n                return null;\n            }\n\n            // Check if there already is a snapshot, otherwise create it.\n            let snapshot = null;\n            if (!this._snapshots.contains(blockHash)) {\n                const tx = await this._accounts.transaction();\n                const transactionsTx = this._transactionCache.clone();\n                let currentHash = this._headHash;\n                // Save all snapshots up to blockHash (and stop when its predecessor would be next).\n                while (!block.prevHash.equals(currentHash)) {\n                    const currentBlock = await this.getBlock(currentHash);\n\n                    if (!this._snapshots.contains(currentHash)) {\n                        snapshot = await this._accounts.snapshot(tx);\n                        this._snapshots.put(currentHash, snapshot);\n                        this._snapshotOrder.unshift(currentHash);\n                    }\n\n                    await tx.revertBlock(currentBlock, transactionsTx);\n                    transactionsTx.revertBlock(currentBlock);\n                    currentHash = currentBlock.prevHash;\n                }\n                await tx.abort();\n            } else {\n                snapshot = this._snapshots.get(blockHash);\n            }\n\n            Assert.that(block.accountsHash.equals(await snapshot.hash()), 'AccountsHash mismatch for snapshot of block ${blockHash}');\n\n            return snapshot;\n        });\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _saveSnapshot(blockHash) {\n        // Replace oldest snapshot if possible.\n        // This ensures snapshots are only created lazily.\n        if (this._snapshotOrder.length > 0) {\n            const oldestHash = this._snapshotOrder.shift();\n            // If the hash is not reused, remove it.\n            const oldestSnapshot = this._snapshots.get(oldestHash);\n            if (oldestSnapshot) {\n                await oldestSnapshot.abort();\n            } else {\n                Log.e(FullChain, () => `Snapshot with hash ${oldestHash.toBase64()} not found.`);\n            }\n            this._snapshots.remove(oldestHash);\n\n            // Add new snapshot.\n            const snapshot = await this._accounts.snapshot();\n            this._snapshots.put(blockHash, snapshot);\n            this._snapshotOrder.push(blockHash);\n        }\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    get height() {\n        return this._mainChain.head.height;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._mainChain.totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._mainChain.totalWork;\n    }\n\n    /** @type {Accounts} */\n    // XXX Do we really want to expose this?\n    get accounts() {\n        return this._accounts;\n    }\n\n    /** @type {TransactionCache} */\n    get transactionCache() {\n        return this._transactionCache;\n    }\n\n    /** @type {number} */\n    get blockForkedCount() {\n        return this._blockForkedCount;\n    }\n\n    /** @type {number} */\n    get blockRebranchedCount() {\n        return this._blockRebranchedCount;\n    }\n\n    /** @type {number} */\n    get blockExtendedCount() {\n        return this._blockExtendedCount;\n    }\n\n    /** @type {number} */\n    get blockOrphanCount() {\n        return this._blockOrphanCount;\n    }\n\n    /** @type {number} */\n    get blockInvalidCount() {\n        return this._blockInvalidCount;\n    }\n\n    /** @type {number} */\n    get blockKnownCount() {\n        return this._blockKnownCount;\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    // XXX Do we really want to expose this?\n    accountsHash() {\n        return this._accounts.hash();\n    }\n}\n\nFullChain.ERR_ORPHAN = -2;\nFullChain.ERR_INVALID = -1;\nFullChain.OK_KNOWN = 0;\nFullChain.OK_EXTENDED = 1;\nFullChain.OK_REBRANCHED = 2;\nFullChain.OK_FORKED = 3;\nClass.register(FullChain);\n","class FullConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Peer} peer\n     */\n    constructor(blockchain, mempool, peer) {\n        super(peer);\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // The number of blocks that extended our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksExtending = -1;\n        // The number of blocks that forked our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksForking = -1;\n        // The last fork block the peer has sent us.\n        /** @type {Block} */\n        this._forkHead = null;\n\n        // The number of failed blockchain sync attempts.\n        /** @type {number} */\n        this._failedSyncs = 0;\n\n        // The block hash that we want to learn to consider the sync complete.\n        /** @type {Hash} */\n        this._syncTarget = peer.headHash;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('get-blocks', msg => this._onGetBlocks(msg));\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n        peer.channel.on('get-accounts-proof', msg => this._onGetAccountsProof(msg));\n        peer.channel.on('get-accounts-tree-chunk', msg => this._onGetAccountsTreeChunk(msg));\n        peer.channel.on('get-transactions-proof', msg => this._onGetTransactionsProof(msg));\n        peer.channel.on('get-transaction-receipts', msg => this._onGetTransactions(msg));\n        peer.channel.on('mempool', msg => this._onMempool(msg));\n    }\n\n    async syncBlockchain() {\n        this._syncing = true;\n\n        // We only sync with other full nodes.\n        if (!Services.isFullNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // If we know our sync target block, the sync process is finished.\n        const head = await this._blockchain.getBlock(this._syncTarget, /*includeForks*/ true);\n        if (head) {\n            this._syncFinished();\n            return;\n        }\n\n        // If the peer didn't send us any blocks that extended our chain, count it as a failed sync attempt.\n        // This sets a maximum length for forks that the full client will accept:\n        //   FullConsensusAgent.SYNC_ATTEMPTS_MAX * BaseInvectoryMessage.VECTORS_MAX_COUNT\n        if (this._numBlocksExtending === 0 && ++this._failedSyncs >= FullConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            return;\n        }\n\n        // We don't know the peer's head block, request blocks from it.\n        this._requestBlocks().catch(Log.w.tag(FullConsensusAgent));\n    }\n\n    _syncFinished() {\n        // Subscribe to all announcements from the peer.\n        this._peer.channel.subscribe(Subscription.ANY);\n\n        // Request the peer's mempool.\n        // XXX Use a random delay here to prevent requests to multiple peers at once.\n        const delay = FullConsensusAgent.MEMPOOL_DELAY_MIN\n            + Math.random() * (FullConsensusAgent.MEMPOOL_DELAY_MAX - FullConsensusAgent.MEMPOOL_DELAY_MIN);\n        setTimeout(() => this._peer.channel.mempool(), delay);\n\n        this._syncing = false;\n        this._synced = true;\n\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n        this._forkHead = null;\n        this._failedSyncs = 0;\n\n        this.fire('sync');\n    }\n\n    async _requestBlocks(maxInvSize) {\n        // Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            Log.e(FullConsensusAgent, 'Duplicate _requestBlocks()');\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        // Set timeout early to prevent re-entering the method.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Check if the peer is sending us a fork.\n        const onFork = this._forkHead && this._numBlocksExtending === 0 && this._numBlocksForking > 0;\n\n        /** @type {Array.<Hash>} */\n        const locators = [];\n        if (onFork) {\n            // Only send the fork head as locator if the peer is sending us a fork.\n            locators.push(this._forkHead.hash());\n        } else {\n            // Request blocks starting from our hardest chain head going back to\n            // the genesis block. Push top 10 hashes first, then back off exponentially.\n            locators.push(this._blockchain.headHash);\n\n            let block = this._blockchain.head;\n            for (let i = Math.min(10, this._blockchain.height) - 1; i > 0; i--) {\n                if (!block) {\n                    break;\n                }\n                locators.push(block.prevHash);\n                block = await this._blockchain.getBlock(block.prevHash); // eslint-disable-line no-await-in-loop\n            }\n\n            let step = 2;\n            for (let i = this._blockchain.height - 10 - step; i > 0; i -= step) {\n                block = await this._blockchain.getBlockAt(i); // eslint-disable-line no-await-in-loop\n                if (block) {\n                    locators.push(block.hash()); // eslint-disable-line no-await-in-loop\n                }\n                step *= 2;\n            }\n\n            // Push the genesis block hash.\n            if (locators.length === 0 || !locators[locators.length - 1].equals(Block.GENESIS.HASH)) {\n                locators.push(Block.GENESIS.HASH);\n            }\n        }\n\n        // Reset block counters.\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(locators, maxInvSize);\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise}\n     * @protected\n     * @override\n     */\n    _onInv(msg) {\n        return super._onInv(msg);\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     * @override\n     */\n    _shouldRequestData(vector) {\n        // Ignore block announcements from nano clients as they will ignore our getData requests anyways (they only know headers).\n        return !(Services.isNanoNode(this._peer.peerAddress.services) && vector.type === InvVector.Type.BLOCK);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false) {\n        return this._blockchain.getBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (!this._syncing) return;\n\n        this._numBlocksForking++;\n        this._forkHead = block;\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onNoUnknownObjects() {\n        // The peer does not have any new inv vectors for us.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsReceived() {\n        // If all objects have been received, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        // Ignore header messages.\n        Log.w(FullConsensusAgent, `Unsolicited header message received from ${this._peer.peerAddress}, discarding`);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushBlock(block);\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case FullChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n\n            case FullChain.OK_KNOWN:\n                Log.v(FullConsensusAgent, `Received known block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @protected\n     */\n    _onOrphanBlock(hash, block) {\n        // Ignore orphan blocks if we're not synced yet. This shouldn't happen.\n        if (!this._synced) {\n            Log.w(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) while syncing`);\n            return;\n        }\n\n        // The peer has announced an orphaned block after the initial sync. We're probably out of sync.\n        Log.d(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n\n        // Disable announcements from the peer once.\n        if (!this._timers.timeoutExists('outOfSync')) {\n            this._peer.channel.subscribe(Subscription.NONE);\n        }\n\n        // Set the orphaned block as the new sync target.\n        this._syncTarget = hash;\n\n        // Wait a short time for:\n        // - our (un-)subscribe message to be sent\n        // - potentially more orphaned blocks to arrive\n        this._timers.resetTimeout('outOfSync', () => this._outOfSync(), FullConsensusAgent.RESYNC_THROTTLE);\n    }\n\n    /**\n     * @private\n     */\n    _outOfSync() {\n        this._timers.clearTimeout('outOfSync');\n\n        this._synced = false;\n\n        this.fire('out-of-sync');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<boolean>}\n     * @protected\n     * @override\n     */\n    async _processTransaction(hash, transaction) {\n        const result = await this._mempool.pushTransaction(transaction);\n        switch (result) {\n            case Mempool.ReturnCode.ACCEPTED:\n                return true;\n            case Mempool.ReturnCode.KNOWN:\n                return false;\n            case Mempool.ReturnCode.FEE_TOO_LOW:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INSUFFICIENT_FEE,\n                    'Sender has too many free transactions', transaction.hash().serialize());\n                return false;\n            case Mempool.ReturnCode.INVALID:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INVALID, 'Invalid transaction',\n                    transaction.hash().serialize());\n                return false;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsProcessed() {\n        // If all objects have been processed, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n\n    /* Request endpoints */\n\n    /**\n     * @param {GetBlocksMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onGetBlocks(msg) {\n        Log.v(FullConsensusAgent, `[GETBLOCKS] ${msg.locators.length} block locators maxInvSize ${msg.maxInvSize} received from ${this._peer.peerAddress}`);\n\n        // A peer has requested blocks. Check all requested block locator hashes\n        // in the given order and pick the first hash that is found on our main\n        // chain, ignore the rest. If none of the requested hashes is found,\n        // pick the genesis block hash. Send the main chain starting from the\n        // picked hash back to the peer.\n        let startBlock = Block.GENESIS;\n        for (const locator of msg.locators) {\n            const block = await this._blockchain.getBlock(locator);\n            if (block) {\n                // We found a block, ignore remaining block locator hashes.\n                startBlock = block;\n                break;\n            }\n        }\n\n        // Collect up to GETBLOCKS_VECTORS_MAX inventory vectors for the blocks starting right\n        // after the identified block on the main chain.\n        const blocks = await this._blockchain.getBlocks(startBlock.height + 1,\n            Math.min(msg.maxInvSize, FullConsensusAgent.GETBLOCKS_VECTORS_MAX),\n            msg.direction === GetBlocksMessage.Direction.FORWARD);\n        const vectors = [];\n        for (const block of blocks) {\n            vectors.push(InvVector.fromBlock(block));\n        }\n\n        // Send the vectors back to the requesting peer.\n        this._peer.channel.inv(vectors);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        const proof = await this._blockchain.getChainProof();\n        this._peer.channel.chainProof(proof);\n    }\n\n    /**\n     * @param {GetAccountsProofMessage} msg\n     * @private\n     */\n    async _onGetAccountsProof(msg) {\n        const proof = await this._blockchain.getAccountsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.accountsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetTransactionsProofMessage} msg\n     * @private\n     */\n    async _onGetTransactionsProof(msg) {\n        const proof = await this._blockchain.getTransactionsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.transactionsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetAccountsTreeChunkMessage} msg\n     * @private\n     */\n    async _onGetAccountsTreeChunk(msg) {\n        const chunk = await this._blockchain.getAccountsTreeChunk(msg.blockHash, msg.startPrefix);\n        this._peer.channel.accountsTreeChunk(msg.blockHash, chunk);\n    }\n\n    /**\n     * @param {GetTransactionReceiptsMessage} msg\n     * @private\n     */\n    async _onGetTransactions(msg) {\n        const transactionReceipts = await this._blockchain.getTransactionReceiptsByAddress(msg.address);\n\n        let i = 0;\n        while (i < TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) {\n            const receipts = transactionReceipts.slice(i, i + TransactionReceiptsMessage.RECEIPTS_MAX_COUNT);\n            this._peer.channel.transactionReceipts(receipts);\n            i += TransactionReceiptsMessage.RECEIPTS_MAX_COUNT;\n        }\n    }\n\n    /**\n     * @param {MempoolMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onMempool(msg) {\n        // Query mempool for transactions\n        const allTransactions = this._mempool.getTransactions();\n        const transactions = new LimitIterable(allTransactions, FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n\n        // Send an InvVector for each transaction in the mempool.\n        // Split into multiple Inv messages if the mempool is large.\n        let vectors = [];\n        for (const tx of transactions) {\n            vectors.push(InvVector.fromTransaction(tx));\n\n            if (vectors.length >= BaseInventoryMessage.VECTORS_MAX_COUNT) {\n                this._peer.channel.inv(vectors);\n                vectors = [];\n                await new Promise((resolve) => setTimeout(resolve, FullConsensusAgent.MEMPOOL_THROTTLE));\n            }\n        }\n\n        if (vectors.length > 0) {\n            this._peer.channel.inv(vectors);\n        }\n    }\n}\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * XXX If the peer is on a long fork, it will count as a failed sync attempt\n * if our blockchain doesn't switch to the fork within 500 (max InvVectors returned by getBlocks)\n * blocks.\n * @type {number}\n */\nFullConsensusAgent.SYNC_ATTEMPTS_MAX = 25;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nFullConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\n/**\n * Time {ms} to wait before triggering a blockchain re-sync with the peer.\n * @type {number}\n */\nFullConsensusAgent.RESYNC_THROTTLE = 1000 * 3; // 3 seconds\n/**\n * Minimum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MIN = 1000 * 2; // 2 seconds\n/**\n * Maximum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MAX = 1000 * 20; // 20 seconds\n/**\n * Time {ms} to wait between sending full inv vectors of transactions during Mempool request\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_THROTTLE = 1000;\n/**\n * Number of transaction vectors to send\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_ENTRIES_MAX = 10000;\nClass.register(FullConsensusAgent);\n","class FullConsensus extends Observable {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super();\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n        /** @type {Network} */\n        this._network = network;\n\n        /** @type {HashMap.<Peer, FullConsensusAgent>} */\n        this._agents = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {boolean} */\n        this._established = false;\n\n        /** @type {Peer} */\n        this._syncPeer = null;\n\n        network.on('peer-joined', peer => this._onPeerJoined(peer));\n        network.on('peer-left', peer => this._onPeerLeft(peer));\n\n        // Notify peers when our blockchain head changes.\n        blockchain.on('head-changed', head => {\n            // Don't announce head changes if we are not synced yet.\n            if (!this._established) return;\n\n            for (const agent of this._agents.values()) {\n                agent.relayBlock(head);\n            }\n        });\n\n        // Relay new (verified) transactions to peers.\n        mempool.on('transaction-added', tx => {\n            // Don't relay transactions if we are not synced yet.\n            if (!this._established) return;\n\n            for (const agent of this._agents.values()) {\n                agent.relayTransaction(tx);\n            }\n        });\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerJoined(peer) {\n        // Create a ConsensusAgent for each peer that connects.\n        const agent = new FullConsensusAgent(this._blockchain, this._mempool, peer);\n        this._agents.put(peer.id, agent);\n\n        // Register agent event listeners.\n        agent.on('close', () => this._onPeerLeft(agent.peer));\n        agent.on('sync', () => this._onPeerSynced(agent.peer));\n        agent.on('out-of-sync', () => this._onPeerOutOfSync(agent.peer));\n\n        // If no more peers connect within the specified timeout, start syncing.\n        this._timers.resetTimeout('sync', this._syncBlockchain.bind(this), FullConsensus.SYNC_THROTTLE);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerLeft(peer) {\n        // Reset syncPeer if it left during the sync.\n        if (peer.equals(this._syncPeer)) {\n            Log.w(FullConsensus, `Peer ${peer.peerAddress} left during sync`);\n            this._syncPeer = null;\n        }\n\n        this._agents.remove(peer.id);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @private\n     */\n    _syncBlockchain() {\n        // Wait for ongoing sync to finish.\n        if (this._syncPeer) {\n            return;\n        }\n\n        // Choose a random peer which we aren't sync'd with yet.\n        const agent = ArrayUtils.randomElement(this._agents.values().filter(agent => !agent.synced));\n        if (!agent) {\n            // We are synced with all connected peers.\n            if (this._agents.length > 0) {\n                // Report consensus-established if we have at least one connected peer.\n                // TODO !!! Check peer types (at least one full node, etc.) !!!\n                if (!this._established) {\n                    Log.i(FullConsensus, `Synced with all connected peers (${this._agents.length}), consensus established.`);\n                    Log.d(FullConsensus, `Blockchain: height=${this._blockchain.height}, headHash=${this._blockchain.headHash}`);\n\n                    this._established = true;\n                    this.fire('established');\n                }\n            } else {\n                // We are not connected to any peers anymore. Report consensus-lost.\n                this._established = false;\n                this.fire('lost');\n            }\n\n            return;\n        }\n\n        this._syncPeer = agent.peer;\n\n        // Notify listeners when we start syncing and have not established consensus yet.\n        if (!this._established) {\n            this.fire('syncing');\n        }\n\n        Log.v(FullConsensus, `Syncing blockchain with peer ${agent.peer.peerAddress}`);\n        agent.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerSynced(peer) {\n        // Reset syncPeer if we finished syncing with it.\n        if (peer.equals(this._syncPeer)) {\n            Log.v(FullConsensus, `Finished sync with peer ${peer.peerAddress}`);\n            this._syncPeer = null;\n        }\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerOutOfSync(peer) {\n        Log.w(FullConsensus, `Peer ${peer.peerAddress} out of sync, resyncing`);\n        this._syncBlockchain();\n    }\n\n    /** @type {boolean} */\n    get established() {\n        return this._established;\n    }\n\n    /** @type {IBlockchain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n\n    /** @type {Network} */\n    get network() {\n        return this._network;\n    }\n}\nFullConsensus.SYNC_THROTTLE = 1500; // ms\nClass.register(FullConsensus);\n","/**\n * A LightChain is initialized by using NiPoPoWs instead of the full\n * blockchain history, but after initialization, it behaves as a regular\n * full blockchain.\n */\nclass LightChain extends FullChain {\n    /**\n    * @param {JungleDB} jdb\n    * @param {Accounts} accounts\n    * @param {Time} time\n    * @returns {Promise.<LightChain>}\n    */\n    static getPersistent(jdb, accounts, time) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {Promise.<LightChain>}\n     */\n    static createVolatile(accounts, time) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time) {\n        super(store, accounts, time);\n    }\n\n    /**\n     * @override\n     * @protected\n     */\n    async _init() {\n        // FIXME: this is a workaround as Babel doesn't understand await super().\n        await FullChain.prototype._init.call(this);\n        if (!this._proof) {\n            this._proof = await this._getChainProof();\n        }\n        return this;\n    }\n\n    /**\n     * @return {PartialLightChain}\n     */\n    async partialChain() {\n        const proof = await this.getChainProof();\n        const partialChain = new PartialLightChain(this._store, this._accounts, this._time, proof);\n        partialChain.on('committed', async (proof, headHash, mainChain) => {\n            this._proof = proof;\n            this._headHash = headHash;\n            this._mainChain = mainChain;\n            this.fire('head-changed', this.head);\n        });\n        await partialChain._init();\n        return partialChain;\n    }\n}\nClass.register(LightChain);\n","class LightConsensusAgent extends FullConsensusAgent {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Peer} peer\n     */\n    constructor(blockchain, mempool, peer) {\n        super(blockchain, mempool, peer);\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {PartialLightChain} */\n        this._partialChain = null;\n\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // Flag indicating whether we do a full catchup or request a proof.\n        /** @type {boolean} */\n        this._catchup = false;\n\n        // Flag indicating whether we believe to be on the main chain of the client.\n        /** @type {boolean} */\n        this._onMainChain = false;\n\n        /** @type {Array.<Block>} */\n        this._orphanedBlocks = [];\n\n        /** @type {boolean} */\n        this._busy = false;\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-tree-chunk', msg => this._onAccountsTreeChunk(msg));\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @override\n     */\n    async syncBlockchain() {\n        // We only sync with other full nodes.\n        if (Services.isNanoNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // Ban peer if the sync failed more often than allowed.\n        if (this._failedSyncs >= LightConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            if (this._partialChain) {\n                await this._partialChain.abort();\n                this._partialChain = null;\n            }\n            return;\n        }\n\n        // Check if we know head block.\n        const block = await this._blockchain.getBlock(this._syncTarget);\n\n        /*\n         * Three cases:\n         * 1) We know block and are not yet syncing: All is done.\n         * 2) We don't know the block and are not yet syncing: Start syncing.\n         *    and determine sync mode (full catchup or not).\n         * 3) We are syncing. Behave differently based on sync mode.\n         *    Note that we can switch from catchup to proof if we notice that\n         *    we're on a fork and get an INV vector starting from the genesis block.\n         */\n\n        // Case 1: We're up to date.\n        if (block && !this._syncing) {\n            this._syncFinished();\n            return;\n        }\n\n        // Case 2: Check header.\n        if (!block && !this._syncing) {\n            this._syncing = true;\n            this._onMainChain = false;\n\n            let header;\n            try {\n                header = await this.getHeader(this._syncTarget);\n            } catch(err) {\n                this._peer.channel.close(CloseType.DID_NOT_GET_REQUESTED_HEADER, 'Did not get requested header');\n                return;\n            }\n\n            // Check how to sync based on heuristic:\n            this._catchup = header.height - this._blockchain.height <= Policy.NUM_BLOCKS_VERIFICATION;\n            Log.d(LightConsensusAgent, `Start syncing, catchup mode: ${this._catchup}`);\n        }\n\n        // Case 3: We are are syncing.\n        if (this._syncing && !this._busy) {\n            if (this._catchup) {\n                await FullConsensusAgent.prototype.syncBlockchain.call(this);\n            } else {\n                // Initialize partial chain on first call.\n                if (!this._partialChain) {\n                    await this._initChainProofSync();\n                }\n\n                switch (this._partialChain.state) {\n                    case PartialLightChain.State.PROVE_CHAIN:\n                        this._requestChainProof();\n                        this.fire('sync-chain-proof', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_ACCOUNTS_TREE:\n                        this._requestAccountsTree();\n                        this.fire('sync-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_BLOCKS:\n                        this._requestProofBlocks();\n                        this.fire('verify-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.COMPLETE:\n                        // Commit state on success.\n                        this.fire('sync-finalize', this._peer.peerAddress);\n                        this._busy = true;\n                        await this._partialChain.commit();\n                        await this._applyOrphanedBlocks();\n                        this._syncFinished();\n                        break;\n                    case PartialLightChain.State.ABORTED:\n                        this._peer.channel.close(CloseType.ABORTED_SYNC, 'aborted sync');\n                        break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _initChainProofSync() {\n        // Subscribe to all announcements from the peer.\n        this._peer.channel.subscribe(Subscription.ANY);\n\n        this._syncing = true;\n        this._synced = false;\n        this._catchup = false;\n        this._onMainChain = true;\n\n        if (this._partialChain) {\n            await this._partialChain.abort();\n        }\n\n        this._partialChain = await this._blockchain.partialChain();\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        if (this._partialChain) {\n            this._partialChain = null;\n        }\n\n        this._busy = false;\n        super._syncFinished();\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const block of this._orphanedBlocks) {\n            const status = await this._blockchain.pushBlock(block);\n            if (status === LightChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    // Syncing stages.\n    // Stage 1: Chain proof.\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Assert.that(!this._requestedChainProof);\n        this._busy = true;\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        // TODO should we ban here instead?\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, LightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, LightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Log.d(LightConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested an interlink chain, reject unsolicited ones.\n        if (!this._requestedChainProof) {\n            Log.w(LightConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the LightChain.\n        if (!(await this._partialChain.pushProof(msg.proof))) {\n            Log.w(LightConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 2: Request AccountsTree.\n    /**\n     * @private\n     */\n    _requestAccountsTree() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n        Assert.that(!this._accountsRequest);\n        this._busy = true;\n\n        const startPrefix = this._partialChain.getMissingAccountsPrefix();\n        const headHash = this._partialChain.headHash;\n        Log.d(LightConsensusAgent, `Requesting AccountsTreeChunk starting at ${startPrefix} from ${this._peer.peerAddress}`);\n\n        this._accountsRequest = {\n            startPrefix: startPrefix,\n            blockHash: headHash\n        };\n\n        // Request AccountsProof from peer.\n        this._peer.channel.getAccountsTreeChunk(headHash, startPrefix);\n\n        // Drop the peer if it doesn't send the accounts proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.ACCOUNTS_TREE_CHUNK, () => {\n            this._peer.channel.close(CloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT, 'getAccountsTreeChunk timeout');\n        }, LightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {AccountsTreeChunkMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsTreeChunk(msg) {\n        Log.d(LightConsensusAgent, `[ACCOUNTS-TREE-CHUNK] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.chunk}`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(LightConsensusAgent, `Unsolicited accounts tree chunk received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n\n        const startPrefix = this._accountsRequest.startPrefix;\n        const blockHash = this._accountsRequest.blockHash;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasChunk()) {\n            // Restart syncing.\n            await this._partialChain.abort();\n            this._partialChain = null;\n            this._busy = false;\n            this._failedSyncs++;\n            return;\n        }\n\n        // Check that we know the reference block.\n        if (!blockHash.equals(msg.blockHash) || msg.chunk.head.prefix <= startPrefix) {\n            Log.w(LightConsensusAgent, `Received AccountsTreeChunk for block != head or wrong start prefix from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Verify the proof.\n        const chunk = msg.chunk;\n        if (!chunk.verify()) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = chunk.root();\n        const block = await this._partialChain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n            return;\n        }\n\n        // Return the retrieved accounts.\n        const result = await this._partialChain.pushAccountsTreeChunk(chunk);\n\n        // Something went wrong!\n        if (result < 0) {\n            // TODO maybe ban?\n            Log.e(`AccountsTree sync failed with error code ${result} from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n        }\n\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 3: Request proof blocks.\n    /**\n     * @private\n     */\n    _requestProofBlocks() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_BLOCKS);\n\n        // If nothing happend since the last request, increase failed syncs.\n        if (this._lastChainHeight === this._partialChain.proofHeadHeight) {\n            this._failedSyncs++;\n        }\n        this._lastChainHeight = this._partialChain.proofHeadHeight;\n\n        // XXX Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            Log.e(LightConsensusAgent, 'Duplicate _requestProofBlocks()');\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(this._partialChain.getBlockLocators(), this._partialChain.numBlocksNeeded(), false);\n    }\n\n    // Block processing.\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    _requestBlocks() {\n        // If we are syncing and not yet sure whether our blocks are on the main chain, just sync one block for now.\n        if (this._syncing && !this._onMainChain) {\n            return super._requestBlocks(1);\n        }\n        return super._requestBlocks();\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // If we find that we are on a fork far away from our chain, resync.\n        if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n            && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n            this._onMainChain = false;\n            await this._initChainProofSync();\n            this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n            return;\n        } else {\n            this._onMainChain = true;\n        }\n\n        // Put block into blockchain.\n        const status = await this._chain.pushBlock(block);\n\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case LightChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (this._syncing && this._catchup) {\n            // If we find that we are on a fork far away from our chain, resync.\n            if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n                && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n                this._onMainChain = false;\n                await this._initChainProofSync();\n                this.syncBlockchain().catch(e => Log.e(LightConsensusAgent, e));\n                return;\n            } else {\n                this._onMainChain = true;\n            }\n\n            FullConsensusAgent.prototype._onKnownBlockAnnounced.call(this, hash, block);\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @private\n     * @override\n     */\n    _onOrphanBlock(hash, block) {\n        if (this._syncing && !this._catchup) {\n            this._orphanedBlocks.push(block);\n        } else {\n            super._onOrphanBlock(hash, block);\n        }\n    }\n\n    // Header processing.\n    /**\n     * @param {Hash} hash\n     * @return {Promise.<BlockHeader>}\n     */\n    getHeader(hash) {\n        Assert.that(!this._headerRequest);\n\n        return new Promise((resolve, reject) => {\n            const vector = new InvVector(InvVector.Type.BLOCK, hash);\n            this._headerRequest = {\n                hash: hash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            this._peer.channel.getHeader([vector]);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.HEADER, () => {\n                this._headerRequest = null;\n                this._peer.channel.close(CloseType.GET_HEADER_TIMEOUT, 'getHeader timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, BaseConsensusAgent.REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        const header = msg.header;\n        const hash = header.hash();\n\n        // Check if we have requested this block.\n        if (!this._headerRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            // TODO What should happen here? ban? drop connection?\n            return;\n        }\n\n        const requestedHash = this._headerRequest.hash;\n        const resolve = this._headerRequest.resolve;\n        const reject = this._headerRequest.reject;\n\n        // Check that it is the correct hash.\n        if (!requestedHash.equals(hash)) {\n            Log.w(LightConsensusAgent, `Received wrong header from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.RECEIVED_WRONG_HEADER, 'Received wrong header');\n            reject(new Error('Received wrong header'));\n            return;\n        }\n\n        resolve(header);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        if (this._partialChain) {\n            this._partialChain.abort().catch(Log.w.tag(LightConsensusAgent));\n        }\n\n        super._onClose();\n    }\n\n    /** @type {LightChain} */\n    get _chain() {\n        if (this._syncing && !this._catchup && this._partialChain) {\n            return this._partialChain;\n        }\n        return this._blockchain;\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-tree-chunk after sending out get-accounts-tree-chunk before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT = 1000 * 8;\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * XXX If the peer is on a long fork, it will count as a failed sync attempt\n * if our blockchain doesn't switch to the fork within 500 (max InvVectors returned by getBlocks)\n * blocks.\n * @type {number}\n */\nLightConsensusAgent.SYNC_ATTEMPTS_MAX = 5;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nLightConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\nClass.register(LightConsensusAgent);\n","class LightConsensus extends Observable {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super();\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n        /** @type {Network} */\n        this._network = network;\n\n        /** @type {HashMap.<Peer, LightConsensusAgent>} */\n        this._agents = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {boolean} */\n        this._established = false;\n\n        /** @type {Peer} */\n        this._syncPeer = null;\n\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        network.on('peer-joined', peer => this._onPeerJoined(peer));\n        network.on('peer-left', peer => this._onPeerLeft(peer));\n\n        // Notify peers when our blockchain head changes.\n        blockchain.on('head-changed', head => {\n            // Don't announce head changes if we are not synced yet.\n            if (!this._established) return;\n\n            for (const agent of this._agents.values()) {\n                agent.relayBlock(head);\n            }\n        });\n\n        // Relay new (verified) transactions to peers.\n        mempool.on('transaction-added', tx => {\n            // Don't relay transactions if we are not synced yet.\n            if (!this._established) return;\n\n            for (const agent of this._agents.values()) {\n                agent.relayTransaction(tx);\n            }\n        });\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerJoined(peer) {\n        // Create a ConsensusAgent for each peer that connects.\n        const agent = new LightConsensusAgent(this._blockchain, this._mempool, peer);\n        this._agents.put(peer.id, agent);\n\n        // Register agent event listeners.\n        agent.on('close', () => this._onPeerLeft(agent.peer));\n        agent.on('sync', () => this._onPeerSynced(agent.peer));\n        agent.on('out-of-sync', () => this._onPeerOutOfSync(agent.peer));\n\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof', 'sync-accounts-tree', 'verify-accounts-tree', 'sync-finalize');\n\n        // If no more peers connect within the specified timeout, start syncing.\n        this._timers.resetTimeout('sync', this._syncBlockchain.bind(this), LightConsensus.SYNC_THROTTLE);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerLeft(peer) {\n        // Reset syncPeer if it left during the sync.\n        if (peer.equals(this._syncPeer)) {\n            Log.w(LightConsensus, `Peer ${peer.peerAddress} left during sync`);\n            this._syncPeer = null;\n            this.fire('sync-failed', peer.peerAddress);\n        }\n\n        this._agents.remove(peer.id);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @private\n     */\n    _syncBlockchain() {\n        return this._synchronizer.push(() => {\n            // Wait for ongoing sync to finish.\n            if (this._syncPeer) {\n                return;\n            }\n\n            // Choose a random peer which we aren't sync'd with yet.\n            const agents = this._agents.values().filter(agent => !agent.synced);\n            const agent = ArrayUtils.randomElement(agents);\n            if (!agent) {\n                // We are synced with all connected peers.\n                if (this._agents.length > 0) {\n                    // Report consensus-established if we have at least one connected peer.\n                    // TODO !!! Check peer types (at least one full node, etc.) !!!\n                    if (!this._established) {\n                        Log.i(LightConsensus, `Synced with all connected peers (${this._agents.length}), consensus established.`);\n                        Log.d(LightConsensus, `Blockchain: height=${this._blockchain.height}, headHash=${this._blockchain.headHash}`);\n\n                        this._established = true;\n                        this.fire('established');\n                    }\n                } else {\n                    // We are not connected to any peers anymore. Report consensus-lost.\n                    this._established = false;\n                    this.fire('lost');\n                }\n\n                return;\n            }\n\n            this._syncPeer = agent.peer;\n\n            // Notify listeners when we start syncing and have not established consensus yet.\n            if (!this._established) {\n                this.fire('syncing', agent.peer.peerAddress, agents.length - 1);\n            }\n\n            Log.v(LightConsensus, `Syncing blockchain with peer ${agent.peer.peerAddress}`);\n            agent.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n        });\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerSynced(peer) {\n        // Reset syncPeer if we finished syncing with it.\n        if (peer.equals(this._syncPeer)) {\n            Log.v(LightConsensus, `Finished sync with peer ${peer.peerAddress}`);\n            this._syncPeer = null;\n            this.fire('sync-finished', peer.peerAddress);\n        }\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerOutOfSync(peer) {\n        Log.w(LightConsensus, `Peer ${peer.peerAddress} out of sync, resyncing`);\n        this._syncBlockchain();\n    }\n\n    /** @type {boolean} */\n    get established() {\n        return this._established;\n    }\n\n    /** @type {IBlockchain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n\n    /** @type {Network} */\n    get network() {\n        return this._network;\n    }\n}\nLightConsensus.SYNC_THROTTLE = 1000; // ms\nClass.register(LightConsensus);\n","class PartialLightChain extends LightChain {\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {ChainProof} proof\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time, proof) {\n        const tx = store.transaction(false);\n        super(tx, accounts, time);\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n\n        /** @type {PartialLightChain.State} */\n        this._state = PartialLightChain.State.PROVE_CHAIN;\n        /** @type {PartialAccountsTree} */\n        this._partialTree = null;\n        /** @type {Accounts} */\n        this._accountsTx = null;\n        /** @type {ChainData} */\n        this._proofHead = null;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        return this._synchronizer.push(() => {\n            return this._pushProof(proof);\n        });\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await Crypto.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(PartialLightChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(PartialLightChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(PartialLightChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(PartialLightChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(PartialLightChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = await this.getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        } else {\n            await this.abort();\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _acceptProof(proof, suffix) {\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Put all other prefix blocks in the store as well (so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = new ChainData(tailEnd, tailEnd.difficulty, BlockUtils.realDifficulty(await tailEnd.pow()), true);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n\n        this._state = PartialLightChain.State.PROVE_ACCOUNTS_TREE;\n        this._partialTree = await this._accounts.partialAccountsTree();\n        this._proofHead = this._mainChain;\n        await this._store.setHead(this.headHash);\n\n        this._proof = proof;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushLightBlock(block) {\n        // Check if we already know this header/block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const totalDifficulty = prevData.totalDifficulty + block.difficulty;\n        const totalWork = prevData.totalWork + BlockUtils.realDifficulty(await block.pow());\n        const chainData = new ChainData(block, totalDifficulty, totalWork);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            await this._store.putChainData(blockHash, chainData);\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    _pushBlock(block) {\n        // Queue new blocks while syncing.\n        if (this._state === PartialLightChain.State.PROVE_BLOCKS) {\n            const blockHash = block.hash();\n            if (this._proofHead.head.prevHash.equals(blockHash)) {\n                return this._pushBlockBackwards(block);\n            } else if (this._proofHead.head.hash().equals(blockHash)) {\n                return this._pushHeadBlock(block);\n            }\n        }\n\n        return FullChain.ERR_ORPHAN;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeadBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(PartialLightChain, 'Rejecting block - unknown predecessor');\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate successor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(PartialLightChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const totalDifficulty = prevData.totalDifficulty + block.difficulty;\n        const totalWork = prevData.totalWork + BlockUtils.realDifficulty(await block.pow());\n        const chainData = new ChainData(block, totalDifficulty, totalWork);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        this._mainChain = chainData;\n        this._proofHead = chainData; // So now it is a full block.\n        this._headHash = hash;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockBackwards(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        if (!(await this._proofHead.head.isImmediateSuccessorOf(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate predecessor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(block);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (this._proofHead.head.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const totalDifficulty = this._proofHead.totalDifficulty - this._proofHead.head.difficulty;\n        const totalWork = this._proofHead.totalWork - BlockUtils.realDifficulty(await this._proofHead.head.pow());\n        const chainData = new ChainData(block, totalDifficulty, totalWork);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _prepend(blockHash, chainData) {\n        try {\n            const transactionCache = new TransactionCache();\n            await this._accountsTx.revertBlock(chainData.head, transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(PartialLightChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            return false;\n        }\n\n        chainData.onMainChain = true;\n\n        await this._store.putChainData(blockHash, chainData);\n\n        this._proofHead = chainData;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushAccountsTreeChunk(chunk) {\n        if (this._state !== PartialLightChain.State.PROVE_ACCOUNTS_TREE) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const result = await this._partialTree.pushChunk(chunk);\n\n        // If we're done, prepare next phase.\n        if (result === PartialAccountsTree.Status.OK_COMPLETE) {\n            this._state = PartialLightChain.State.PROVE_BLOCKS;\n            this._accountsTx = new Accounts(this._partialTree.transaction(false));\n        }\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _complete() {\n        this._state = PartialLightChain.State.COMPLETE;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n            this._accountsTx = null;\n        }\n\n        const currentProof = await this.getChainProof();\n        this.fire('complete', currentProof, this._headHash, this._mainChain);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async commit() {\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n\n        const result = await JDB.JungleDB.commitCombined(this._store.tx, this._partialTree.tx);\n        this._partialTree = null;\n\n        const currentProof = await this.getChainProof();\n        this.fire('committed', currentProof, this._headHash, this._mainChain);\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async abort() {\n        this._state = PartialLightChain.State.ABORTED;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n        if (this._partialTree) {\n            await this._partialTree.abort();\n        }\n        await this._store.abort();\n        this.fire('aborted');\n    }\n\n    /**\n     * @returns {string}\n     */\n    getMissingAccountsPrefix() {\n        if (this._partialTree) {\n            return this._partialTree.missingPrefix;\n        }\n        return '';\n    }\n\n    /**\n     * @returns {Array.<Hash>}\n     */\n    getBlockLocators() {\n        return this._proofHead ? [this._proofHead.head.hash()] : [this.headHash];\n    }\n\n    /**\n     * @returns {number}\n     */\n    numBlocksNeeded() {\n        if (!this._proofHead) {\n            return Policy.NUM_BLOCKS_VERIFICATION;\n        }\n        let numBlocks = Policy.NUM_BLOCKS_VERIFICATION - (this.height - this._proofHead.head.height + 1);\n        // If we begin syncing, we need one block additionally.\n        if (!this._proofHead.head.isFull()) {\n            numBlocks++;\n        }\n        return numBlocks;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsMoreBlocks() {\n        return this.numBlocksNeeded() > 0;\n    }\n\n    /** @type {PartialLightChain.State} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {number} */\n    get proofHeadHeight() {\n        return this._proofHead.head.height;\n    }\n}\n/**\n * @enum {number}\n */\nPartialLightChain.State = {\n    ABORTED: -1,\n    PROVE_CHAIN: 0,\n    PROVE_ACCOUNTS_TREE: 1,\n    PROVE_BLOCKS: 2,\n    COMPLETE: 3\n};\nClass.register(PartialLightChain);\n","class NanoChain extends BaseChain {\n    /**\n     * @param {Time} time\n     * @returns {Promise.<NanoChain>}\n     */\n    constructor(time) {\n        super(ChainDataStore.createVolatile());\n\n        this._time = time;\n\n        this._proof = new ChainProof(new BlockChain([Block.GENESIS.toLight()]), new HeaderChain([]));\n\n        this._headHash = Block.GENESIS.HASH;\n\n        this._synchronizer = new Synchronizer();\n\n        return this._init();\n    }\n\n    async _init() {\n        this._mainChain = new ChainData(Block.GENESIS, Block.GENESIS.difficulty, BlockUtils.realDifficulty(await Block.GENESIS.pow()), true);\n        await this._store.putChainData(Block.GENESIS.HASH, this._mainChain);\n\n        return this;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        return this._synchronizer.push(() => {\n            return this._pushProof(proof);\n        });\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await Crypto.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(NanoChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(NanoChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(NanoChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(NanoChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(NanoChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = await this.getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _acceptProof(proof, suffix) {\n        this._proof = proof;\n\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Put all other prefix blocks in the store as well (so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = new ChainData(tailEnd, tailEnd.difficulty, BlockUtils.realDifficulty(await tailEnd.pow()), true);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlock(block) {\n        // Check if we already know this header/block.\n        const hash = await block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     */\n    pushHeader(header) {\n        return this._synchronizer.push(() => {\n            return this._pushHeader(header);\n        });\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeader(header) {\n        // Check if we already know this header/block.\n        const hash = header.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Verify proof of work.\n        if (!(await header.verifyProofOfWork())) {\n            Log.w(NanoChain, 'Rejecting header - PoW verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(header.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            Log.w(NanoChain, 'Rejecting header - unknown predecessor');\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is valid successor to its predecessor.\n        /** @type {Block} */\n        const predecessor = prevData.head;\n        if (!header.isImmediateSuccessorOf(predecessor.header)) {\n            Log.w(NanoChain, 'Rejecting header - not a valid successor');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct (if we can compute the next target)\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (header.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(NanoChain, 'Rejecting header - difficulty mismatch');\n                return NanoChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Compute and verify interlink.\n        const interlink = await predecessor.getNextInterlink(header.target, header.version);\n        const interlinkHash = interlink.hash();\n        if (!interlinkHash.equals(header.interlinkHash)) {\n            Log.w(NanoChain, 'Rejecting header - interlink verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        const block = new Block(header, interlink);\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const totalDifficulty = prevData.totalDifficulty + block.difficulty;\n        const totalWork = prevData.totalWork + BlockUtils.realDifficulty(await block.pow());\n        const chainData = new ChainData(block, totalDifficulty, totalWork);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            await this._store.putChainData(blockHash, chainData);\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise}\n     * @private\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(NanoChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        const forkChain = [];\n        const forkHashes = [];\n\n        let curData = chainData;\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            curData = await this._store.getChainData(curHash); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(NanoChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        // Unset onMainChain flag on the current main chain up to (excluding) the common ancestor.\n        let headHash = this._headHash;\n        let headData = this._mainChain;\n        while (!headHash.equals(curHash)) {\n            headData.onMainChain = false;\n            await this._store.putChainData(headHash, headData);\n\n            headHash = headData.head.prevHash;\n            headData = await this._store.getChainData(headHash);\n            Assert.that(!!headData, 'Failed to find main chain predecessor while rebranching');\n        }\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Set onMainChain flag on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            await this._store.putChainData(forkHashes[i], forkData);\n\n            // Fire head-changed event for each fork block.\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    async getChainProof() {\n        if (!this._proof) {\n            this._proof = await this._getChainProof();\n        }\n        return this._proof;\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._mainChain.head.height;\n    }\n}\nNanoChain.ERR_ORPHAN = -2;\nNanoChain.ERR_INVALID = -1;\nNanoChain.OK_KNOWN = 0;\nNanoChain.OK_EXTENDED = 1;\nNanoChain.OK_REBRANCHED = 2;\nNanoChain.OK_FORKED = 3;\nClass.register(NanoChain);\n","class NanoConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     */\n    constructor(blockchain, mempool, time, peer) {\n        super(peer);\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n        /** @type {Time} */\n        this._time = time;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        /** @type {Array.<BlockHeader>} */\n        this._orphanedBlocks = [];\n\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Helper object to keep track of the transactions we're requesting from the peer.\n        this._transactionsRequest = null;\n\n        // Helper object to keep track of full blocks we're requesting from the peer.\n        this._blockRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Flag to track transaction receipts requests.\n        this._requestedTransactionReceipts = false;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-proof', msg => this._onAccountsProof(msg));\n        peer.channel.on('transactions-proof', msg => this._onTransactionsProof(msg));\n        peer.channel.on('transaction-receipts', msg => this._onTransactionReceipts(msg));\n\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n\n        // Subscribe to all announcements from the peer.\n        /** @type {Subscription} */\n        this._localSubscription = Subscription.BLOCKS_ONLY;\n        this._peer.channel.subscribe(this._localSubscription);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    subscribeAccounts(addresses) {\n        this._localSubscription = Subscription.fromAddresses(addresses);\n        this._peer.channel.subscribe(Subscription.BLOCKS_ONLY);\n        \n        this._timers.resetTimeout('subscription-change', () => {\n            this._peer.channel.subscribe(this._localSubscription);\n        }, NanoConsensusAgent.SUBSCRIPTION_CHANGE_THROTTLE);\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async syncBlockchain() {\n        this._syncing = true;\n\n        const headBlock = await this._blockchain.getBlock(this._peer.headHash);\n        if (!headBlock) {\n            this._requestChainProof();\n            this.fire('sync-chain-proof', this._peer.peerAddress);\n        } else {\n            this._syncFinished();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        this._syncing = false;\n        this._synced = true;\n        this.fire('sync');\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        // Only one chain proof request at a time.\n        if (this._requestedChainProof) {\n            return;\n        }\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, NanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, NanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Log.d(NanoConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested a chain proof, reject unsolicited ones.\n        // FIXME\n        if (!this._requestedChainProof) {\n            Log.w(NanoConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the NanoChain.\n        if (!(await this._blockchain.pushProof(msg.proof))) {\n            Log.w(NanoConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n\n        // Apply any orphaned blocks we received while waiting for the chain proof.\n        await this._applyOrphanedBlocks();\n\n        if (this._syncing) {\n            this._syncFinished();\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const header of this._orphanedBlocks) {\n            const status = await this._blockchain.pushHeader(header);\n            if (status === NanoChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _doRequestData(vectors) {\n        /** @type {Array.<InvVector>} */\n        const blocks = [];\n        /** @type {Array.<InvVector>} */\n        const transactions = [];\n        for (const vector of vectors) {\n            if (vector.type === InvVector.Type.BLOCK) {\n                blocks.push(vector);\n            } else {\n                transactions.push(vector);\n            }\n        }\n\n        // Request headers and transactions from peer.\n        this._peer.channel.getHeader(blocks);\n        this._peer.channel.getData(transactions);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false) {\n        return this._blockchain.getBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processHeader(hash, header) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushHeader(header);\n        if (status === NanoChain.ERR_INVALID) {\n            this._peer.channel.close(CloseType.RECEIVED_INVALID_HEADER, 'received invalid header');\n        }\n        // Re-sync with this peer if it starts sending orphan blocks after the initial sync.\n        else if (status === NanoChain.ERR_ORPHAN) {\n            this._orphanedBlocks.push(header);\n            if (this._synced) {\n                this._requestChainProof();\n            }\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _processTransaction(hash, transaction) {\n        if (!this._localSubscription.matchesTransaction(transaction)) {\n            this._peer.channel.close(CloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION, 'received transaction not matching our subscription');\n        }\n        return this._mempool.pushTransaction(transaction);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        const proof = await this._blockchain.getChainProof();\n        if (proof) {\n            this._peer.channel.chainProof(proof);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Account>>}\n     */\n    getAccounts(blockHash, addresses) {\n        return this._synchronizer.push(() => {\n            return this._getAccounts(blockHash, addresses);\n        });\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array<Account>>}\n     * @private\n     */\n    _getAccounts(blockHash, addresses) {\n        Assert.that(this._accountsRequest === null);\n\n        Log.d(NanoConsensusAgent, `Requesting AccountsProof for ${addresses} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._accountsRequest = {\n                addresses: addresses,\n                blockHash: blockHash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            // Request AccountsProof from peer.\n            this._peer.channel.getAccountsProof(blockHash, addresses);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.ACCOUNTS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_ACCOUNTS_PROOF_TIMEOUT, 'getAccountsProof timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, NanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {AccountsProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsProof(msg) {\n        Log.d(NanoConsensusAgent, `[ACCOUNTS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited accounts proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const addresses = this._accountsRequest.addresses;\n        const blockHash = this._accountsRequest.blockHash;\n        const resolve = this._accountsRequest.resolve;\n        const reject = this._accountsRequest.reject;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasProof()) {\n            reject(new Error('Accounts request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!blockHash.equals(msg.blockHash)) {\n            Log.w(NanoConsensusAgent, `Received AccountsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!proof.verify()) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_PROOF, 'Invalid AccountsProof');\n            reject(new Error('Invalid AccountsProof'));\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = proof.root();\n        const block = await this._blockchain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH, 'AccountsProof root hash mismatch');\n            reject(new Error('AccountsProof root hash mismatch'));\n            return;\n        }\n\n        // Check that all requested accounts are part of this proof.\n        // XXX return a map address -> account instead?\n        const accounts = [];\n        for (const address of addresses) {\n            try {\n                const account = proof.getAccount(address);\n                accounts.push(account);\n            } catch (e) {\n                Log.w(NanoConsensusAgent, `Incomplete AccountsProof received from ${this._peer.peerAddress}`);\n                // TODO ban instead?\n                this._peer.channel.close(CloseType.INCOMPLETE_ACCOUNTS_PROOF, 'Incomplete AccountsProof');\n                reject(new Error('Incomplete AccountsProof'));\n                return;\n            }\n        }\n\n        // Return the retrieved accounts.\n        resolve(accounts);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Transaction>>}\n     */\n    getTransactionsProof(blockHash, addresses) {\n        return this._synchronizer.push(() => {\n            return this._getTransactionsProof(blockHash, addresses);\n        });\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array<Transaction>>}\n     * @private\n     */\n    async _getTransactionsProof(blockHash, addresses) {\n        Assert.that(this._transactionsRequest === null);\n\n        Log.d(NanoConsensusAgent, `Requesting TransactionsProof for ${addresses} from ${this._peer.peerAddress}`);\n\n        /** @type {Block} */\n        const block = await this._blockchain.getBlock(blockHash);\n        if (!block) {\n            Log.d(NanoConsensusAgent, `Requested block with hash ${blockHash} not found`);\n            return [];\n        }\n\n        return new Promise((resolve, reject) => {\n            this._transactionsRequest = {\n                addresses: addresses,\n                blockHash: blockHash,\n                header: block.header,\n                resolve: resolve,\n                reject: reject\n            };\n\n            // Request AccountsProof from peer.\n            this._peer.channel.getTransactionsProof(blockHash, addresses);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.TRANSACTIONS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_TRANSACTIONS_PROOF_TIMEOUT, 'getTransactionsProof timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, NanoConsensusAgent.TRANSACTIONSPROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {TransactionsProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onTransactionsProof(msg) {\n        Log.d(NanoConsensusAgent, `[TRANSACTIONS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, transactions=${msg.transactions}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested a transactions proof, reject unsolicited ones.\n        if (!this._transactionsRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited transactions proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const blockHash = this._transactionsRequest.blockHash;\n        /** @type {BlockHeader} */\n        const header = this._transactionsRequest.header;\n        const resolve = this._transactionsRequest.resolve;\n        const reject = this._transactionsRequest.reject;\n\n        // Reset transactionsRequest.\n        this._transactionsRequest = null;\n\n        if (!msg.hasProof()) {\n            Log.w(NanoConsensusAgent, `TransactionsProof request was rejected by ${this._peer.peerAddress}`);\n            reject(new Error('TransactionsProof request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!blockHash.equals(msg.blockHash)) {\n            Log.w(NanoConsensusAgent, `Received TransactionsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!header.bodyHash.equals(proof.root())) {\n            Log.w(NanoConsensusAgent, `Invalid TransactionsProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_TRANSACTION_PROOF, 'Invalid TransactionsProof');\n            reject(new Error('Invalid TransactionsProof'));\n            return;\n        }\n\n        // Return the retrieved transactions.\n        resolve(proof.transactions);\n    }\n\n    /**\n     * @param {Address} address\n     */\n    getTransactionReceipts(address) {\n        this._peer.channel.getTransactionReceipts(address);\n        this._requestedTransactionReceipts = true;\n\n        this._peer.channel.expectMessage(Message.Type.TRANSACTION_RECEIPTS, () => {\n            this._peer.channel.close(CloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT, 'getTransactionReceipts timeout');\n        }, NanoConsensusAgent.TRANSACTIONS_REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {TransactionReceiptsMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onTransactionReceipts(msg) {\n        Log.d(NanoConsensusAgent, `[TRANSACTION-RECEIPTS] Received from ${this._peer.peerAddress}: ${msg.transactionReceipts.length}`);\n\n        // Check if we have requested transaction receipts, reject unsolicited ones.\n        if (!this._requestedTransactionReceipts) {\n            Log.w(NanoConsensusAgent, `Unsolicited transaction receipts received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedTransactionReceipts = false;\n\n        this.fire('transaction-receipts', msg.transactionReceipts);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<Block>}\n     */\n    getFullBlock(hash) {\n        // TODO we can use a different synchronizer here, no need to synchronize with getAccounts().\n        return this._synchronizer.push(() => {\n            return this._getFullBlock(hash);\n        });\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<Block>}\n     * @private\n     */\n    _getFullBlock(hash) {\n        Assert.that(this._blockRequest === null);\n\n        Log.d(NanoConsensusAgent, `Requesting full block ${hash} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._blockRequest = {\n                hash: hash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            // Request full block from peer.\n            const vector = new InvVector(InvVector.Type.BLOCK, hash);\n            this._peer.channel.getData([vector]);\n\n            // Drop the peer if it doesn't send the block within the timeout.\n            this._peer.channel.expectMessage([Message.Type.BLOCK, Message.Type.NOT_FOUND], () => {\n                reject(new Error('timeout')); // TODO error handling\n            }, BaseConsensusAgent.REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {BlockMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _onBlock(msg) {\n        // Ignore all block messages that we didn't request.\n        if (!this._blockRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited block message received from ${this._peer.peerAddress}, discarding`);\n            // TODO close/ban?\n            return;\n        }\n\n        const blockHash = this._blockRequest.hash;\n        const resolve = this._blockRequest.resolve;\n        const reject = this._blockRequest.reject;\n\n        // Reset blockRequest.\n        this._blockRequest = null;\n\n        // Check if we asked for this specific block.\n        const hash = msg.block.hash();\n        if (!hash.equals(blockHash)) {\n            Log.w(NanoConsensusAgent, `Unexpected block received from ${this._peer.peerAddress}, discarding`);\n            // TODO close/ban?\n            reject(new Error('Unexpected block'));\n            return;\n        }\n\n        // Verify block.\n        // TODO should we let the caller do that instead?\n        if (!(await msg.block.verify(this._time))) {\n            Log.w(NanoConsensusAgent, `Invalid block received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_BLOCK, 'Invalid block');\n            reject(new Error('Invalid block'));\n            return;\n        }\n\n        // Return the retrieved block.\n        resolve(msg.block);\n    }\n\n    /**\n     * @param {NotFoundMessage} msg\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onNotFound(msg) {\n        // Check if this notfound message corresponds to our block request.\n        if (this._blockRequest && msg.vectors.length === 1 && msg.vectors[0].hash.equals(this._blockRequest.hash)) {\n            const reject = this._blockRequest.reject;\n            this._blockRequest = null;\n\n            reject(new Error('Block not found'));\n        }\n\n        super._onNotFound(msg);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        // Clear the synchronizer queue.\n        this._synchronizer.clear();\n        super._onClose();\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-proof after sending out get-accounts-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT = 1000 * 5;\nNanoConsensusAgent.TRANSACTIONSPROOF_REQUEST_TIMEOUT = 1000 * 10;\nNanoConsensusAgent.TRANSACTIONS_REQUEST_TIMEOUT = 1000 * 15;\nNanoConsensusAgent.SUBSCRIPTION_CHANGE_THROTTLE = 1000 * 2;\nClass.register(NanoConsensusAgent);\n","class NanoConsensus extends Observable {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super();\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n        /** @type {Network} */\n        this._network = network;\n\n        /** @type {HashMap.<Peer, NanoConsensusAgent>} */\n        this._agents = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {boolean} */\n        this._established = false;\n\n        /** @type {Peer} */\n        this._syncPeer = null;\n\n        /** @type {Array.<Address>} */\n        this._addresses = [];\n\n        network.on('peer-joined', peer => this._onPeerJoined(peer));\n        network.on('peer-left', peer => this._onPeerLeft(peer));\n\n        // Notify peers when our blockchain head changes.\n        blockchain.on('head-changed', head => this._onHeadChanged(head));\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerJoined(peer) {\n        // Create a ConsensusAgent for each peer that connects.\n        const agent = new NanoConsensusAgent(this._blockchain, this._mempool, this._network.time, peer);\n        this._agents.put(peer.id, agent);\n\n        // Register agent event listeners.\n        agent.on('close', () => this._onPeerLeft(agent.peer));\n        agent.on('sync', () => this._onPeerSynced(agent.peer));\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof');\n\n        // Subscribe to transaction announcements for our accounts.\n        agent.subscribeAccounts(this._addresses);\n\n        // If no more peers connect within the specified timeout, start syncing.\n        this._timers.resetTimeout('sync', this._syncBlockchain.bind(this), NanoConsensus.SYNC_THROTTLE);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerLeft(peer) {\n        // Reset syncPeer if it left during the sync.\n        if (peer.equals(this._syncPeer)) {\n            Log.w(NanoConsensus, `Peer ${peer.peerAddress} left during sync`);\n            this._syncPeer = null;\n            this.fire('sync-failed', peer.peerAddress);\n        }\n\n        this._agents.remove(peer.id);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @private\n     */\n    _syncBlockchain() {\n        // Wait for ongoing sync to finish.\n        if (this._syncPeer) {\n            return;\n        }\n\n        // Choose a random peer which we aren't sync'd with yet.\n        const agents = this._agents.values().filter(agent => !agent.synced);\n        const agent = ArrayUtils.randomElement(agents);\n        if (!agent) {\n            // We are synced with all connected peers.\n            if (this._agents.length > 0) {\n                // Report consensus-established if we have at least one connected peer.\n                // TODO !!! Check peer types (at least one full node, etc.) !!!\n                if (!this._established) {\n                    Log.i(NanoConsensus, `Synced with all connected peers (${this._agents.length}), consensus established.`);\n                    Log.d(NanoConsensus, `Blockchain: height=${this._blockchain.height}, headHash=${this._blockchain.headHash}`);\n\n                    this._established = true;\n                    this.fire('established');\n                }\n            } else {\n                // We are not connected to any peers anymore. Report consensus-lost.\n                this._established = false;\n                this.fire('lost');\n            }\n\n            return;\n        }\n\n        this._syncPeer = agent.peer;\n\n        // Notify listeners when we start syncing and have not established consensus yet.\n        if (!this._established) {\n            this.fire('syncing', agent.peer.peerAddress, agents.length - 1);\n        }\n\n        Log.v(NanoConsensus, `Syncing blockchain with peer ${agent.peer.peerAddress}`);\n        agent.syncBlockchain().catch(Log.w.tag(NanoConsensusAgent));\n    }\n\n    /**\n     * @param {Peer} peer\n     * @private\n     */\n    _onPeerSynced(peer) {\n        // Reset syncPeer if we finished syncing with it.\n        if (peer.equals(this._syncPeer)) {\n            Log.v(NanoConsensus, `Finished sync with peer ${peer.peerAddress}`);\n            this._syncPeer = null;\n            this.fire('sync-finished', peer.peerAddress);\n        }\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Block} head\n     * @private\n     */\n    async _onHeadChanged(head) {\n        // Don't announce head changes if we are not synced yet.\n        if (!this._established) return;\n\n        for (const agent of this._agents.values()) {\n            agent.relayBlock(head);\n        }\n\n        const includedTransactions = await this.getTransactionsProof(this._addresses, head.hash());\n        this._mempool.changeHead(head, includedTransactions);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Account>}\n     */\n    async getAccount(address, blockHash=null) {\n        return (await this.getAccounts([address], blockHash))[0];\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Array<Account>>}\n     */\n    async getAccounts(addresses, blockHash=null) {\n        blockHash = blockHash ? blockHash : this._blockchain.headHash;\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && agent.knowsBlock(blockHash)\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        for (const agent of agents) {\n            try {\n                return await agent.getAccounts(blockHash, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(NanoConsensus, `Failed to retrieve accounts ${addresses} from ${agent.peer.peerAddress}: ${e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve accounts ${addresses}`);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    subscribeAccounts(addresses) {\n        this._addresses = addresses;\n        for (const /** @type {NanoConsensusAgent} */ agent of this._agents.values()) {\n            agent.subscribeAccounts(this._addresses);\n        }\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Array<Transaction>>}\n     */\n    async getTransactionsProof(addresses, blockHash=null) {\n        blockHash = blockHash ? blockHash : this._blockchain.headHash;\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && agent.knowsBlock(blockHash)\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        for (const agent of agents) {\n            try {\n                return await agent.getTransactionsProof(blockHash, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(NanoConsensus, `Failed to retrieve transactions for ${addresses} from ${agent.peer.peerAddress}: ${e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve transactions for ${addresses}`);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     */\n    async relayTransaction(transaction) {\n        // Fail if we are not connected to at least one full/light node.\n        if (!this._agents.values().some(agent => !Services.isNanoNode(agent.peer.peerAddress.services))) {\n            throw new Error('Failed to relay transaction - only nano nodes connected');\n        }\n\n        // Store transaction in mempool.\n        if (!(await this._mempool.pushTransaction(transaction))) {\n            throw new Error('Failed to relay transaction - mempool rejected transaction');\n        }\n\n        // Relay transaction to all connected peers.\n        let relayed = false;\n        for (const agent of this._agents.values()) {\n            relayed = agent.relayTransaction(transaction) || relayed;\n        }\n\n        // Fail if the transaction was not relayed.\n        if (!relayed) {\n            throw new Error('Failed to relay transaction - no agent relayed transaction');\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<Block>}\n     */\n    async getFullBlock(hash) {\n        // Filter agents that aren't synced or that are nano clients\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        for (const agent of agents) {\n            try {\n                return await agent.getFullBlock(hash); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(NanoConsensus, `Failed to retrieve full block ${hash} from ${agent.peer.peerAddress}: ${e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested block, fail.\n        throw new Error(`Failed to retrieve block ${hash}`);\n    }\n\n    /** @type {boolean} */\n    get established() {\n        return this._established;\n    }\n\n    // TODO confidence level?\n\n    /** @type {IBlockchain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {NanoMempool} */\n    get mempool() {\n        return this._mempool;\n    }\n\n    /** @type {Network} */\n    get network() {\n        return this._network;\n    }\n}\nNanoConsensus.SYNC_THROTTLE = 1000; // ms\nClass.register(NanoConsensus);\n","class NanoMempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     */\n    constructor(blockchain) {\n        super();\n\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n\n        // Our pool of transactions.\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetByAddress = new HashMap();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<boolean>}\n     */\n    async pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            Log.v(Mempool, () => `Ignoring known transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Check validity based on startHeight.\n        if (this._blockchain.height >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n            Log.v(Mempool, () => `Ignoring expired transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Verify transaction.\n        if (!transaction.verify()) {\n            return false;\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByHash.put(hash, transaction);\n        const set = this._transactionSetByAddress.get(transaction.sender) || new MempoolTransactionSet();\n        set.add(transaction);\n        this._transactionSetByAddress.put(transaction.sender, set);\n\n        // Tell listeners about the new transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} maxCount\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxCount = 5000) {\n        return this._transactionsByHash.values().sort((a, b) => a.compare(b)).slice(0, maxCount);\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        const set = this._transactionSetByAddress.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Transaction>} transactions\n     */\n    changeHead(block, transactions) {\n        this._evictTransactions(block.height, transactions);\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @param {Array.<Transaction>} transactions\n     * @private\n     */\n    _evictTransactions(blockHeight, transactions) {\n        // Remove expired transactions.\n        for (const /** @type {Transaction} */ tx of this._transactionsByHash.values()) {\n            const txHash = tx.hash();\n            if (blockHeight >= tx.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-expired', tx);\n            }\n        }\n\n        // Remove mined transactions.\n        for (const /** @type {Transaction} */ tx of transactions) {\n            const txHash = tx.hash();\n            if (this._transactionsByHash.contains(txHash)) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-mined', tx);\n            }\n        }\n    }\n}\nClass.register(NanoMempool);\n","class ConsensusDB extends JDB.JungleDB {\n    /**\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getFull() {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB('full-consensus');\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getLight() {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB('light-consensus');\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @param {string} dbName\n     * @returns {Promise.<ConsensusDB>}\n     */\n    constructor(dbName) {\n        super(dbName, ConsensusDB.VERSION);\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<ConsensusDB>}\n     * @private\n     */\n    async _init() {\n        // Initialize object stores.\n        AccountsTreeStore.initPersistent(this);\n        ChainDataStore.initPersistent(this);\n        TransactionStore.initPersistent(this);\n\n        // Establish connection to database.\n        await this.connect();\n\n        return this;\n    }\n}\nConsensusDB._instance = null;\nConsensusDB.VERSION = 3;\nClass.register(ConsensusDB);\n","class Consensus {\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async full(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getFull();\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.getPersistent(db);\n        /** @type {FullChain} */\n        const blockchain = await FullChain.getPersistent(db, accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async light(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getLight();\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {LightChain} */\n        const blockchain = await LightChain.getPersistent(db, accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async nano(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async volatileFull(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.createVolatile();\n        /** @type {FullChain} */\n        const blockchain = await FullChain.createVolatile(accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n        /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async volatileLight(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {LightChain} */\n        const blockchain = await LightChain.createVolatile(accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async volatileNano(netconfig = NetworkConfig.getDefault()) {\n        await Crypto.prepareSyncCryptoWorker();\n\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n}\n\nClass.register(Consensus);\n","/* Genesis Block */\nBlock.GENESIS = new Block(\n    new BlockHeader(\n        new Hash(null),\n        new Hash(null),\n        Hash.fromBase64('giOIYTBojKQPmBLq5msCgObOL3KnQ9CKrIGb5HWz7E8='),\n        Hash.fromBase64('xexmOOk+2oLBIhwkCD+caw2FsifB0U6tXlles8Tycts='),\n        BlockUtils.difficultyToCompact(1),\n        1,\n        0,\n        104295,\n        BlockHeader.Version.V1),\n    new BlockInterlink([], new Hash(null)),\n    new BlockBody(Address.fromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA='), [])\n);\nBlock.GENESIS.HASH = Hash.fromBase64('ykmTb222PK189z6x6dpT3Ul607cGjzFzECR4WXO+m+Y=');\n\n/* Genesis Accounts */\nAccounts.GENESIS =\n    'AAIP7R94Gl77Xrk4xvszHLBXdCzC9AAAAHKYqT3gAAh2jadJcsL852C50iDDRIdlFjsNAAAAcpipPeAA';\n","class Protocol {\n}\nProtocol.DUMB = 0;\nProtocol.WS = 1;\nProtocol.RTC = 2;\nClass.register(Protocol);\n","class Message {\n    /**\n     * Create a new Message instance. This is usually not called directly but by subclasses.\n     * @param {Message.Type} type Message type\n     */\n    constructor(type) {\n        if (!NumberUtils.isUint64(type)) throw new Error('Malformed type');\n        /** @type {Message.Type} */\n        this._type = type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type.\n        const type = buf.readVarUint();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {number}\n     */\n    static peekLength(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type and ignore it.\n        buf.readVarUint();\n        // Read the length.\n        const length = buf.readUint32();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return length;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static unserialize(buf) {\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.readPos === 0, 'Message.unserialize() requires buf.readPos == 0');\n\n        const magic = buf.readUint32();\n        const type = buf.readVarUint();\n        buf.readUint32(); // length is ignored\n        const checksum = buf.readUint32();\n\n        // Validate magic.\n        if (magic !== Message.MAGIC) throw 'Malformed magic';\n\n        // Validate checksum.\n        Message._writeChecksum(type, buf, 0);\n        const calculatedChecksum = CRC32.compute(buf);\n        if (checksum !== calculatedChecksum) throw new Error('Invalid checksum');\n\n        return new Message(type);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.writePos === 0, 'Message.serialize() requires buf.writePos == 0');\n\n        buf.writeUint32(Message.MAGIC);\n        buf.writeVarUint(this._type);\n        buf.writeUint32(this.serializedSize);\n        buf.writeUint32(0); // written later by _setChecksum()\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(this._type)\n            + /*length*/ 4\n            + /*checksum*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {void}\n     * @protected\n     */\n    _setChecksum(buf) {\n        const checksum = CRC32.compute(buf);\n        Message._writeChecksum(this._type, buf, checksum);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {SerialBuffer} buf\n     * @param {number} value\n     * @returns {void}\n     * @private\n     */\n    static _writeChecksum(type, buf, value) {\n        // Store current write position.\n        const pos = buf.writePos;\n\n        // Set write position past the magic, type, and length fields to the\n        // beginning of the checksum value.\n        buf.writePos = /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(type)\n            + /*length*/ 4;\n\n        // Write the checksum value.\n        buf.writeUint32(value);\n\n        // Reset the write position to original.\n        buf.writePos = pos;\n    }\n\n    /** @type {Message.Type} */\n    get type() {\n        return this._type;\n    }\n}\nMessage.MAGIC = 0x42042042;\n/**\n * Enum for message types.\n * @enum {number}\n */\nMessage.Type = {\n    VERSION:    0,\n    INV:        1,\n    GET_DATA:   2,\n    GET_HEADER: 3,\n    NOT_FOUND:  4,\n    GET_BLOCKS: 5,\n    BLOCK:      6,\n    HEADER:     7,\n    TX:         8,\n    MEMPOOL:    9,\n    REJECT:     10,\n    SUBSCRIBE:  11,\n\n    ADDR:       20,\n    GET_ADDR:   21,\n    PING:       22,\n    PONG:       23,\n\n    SIGNAL:     30,\n\n    GET_CHAIN_PROOF:            40,\n    CHAIN_PROOF:                41,\n    GET_ACCOUNTS_PROOF:         42,\n    ACCOUNTS_PROOF:             43,\n    GET_ACCOUNTS_TREE_CHUNK:    44,\n    ACCOUNTS_TREE_CHUNK:        45,\n    GET_TRANSACTIONS_PROOF:     47,\n    TRANSACTIONS_PROOF:         48,\n    GET_TRANSACTION_RECEIPTS:           49,\n    TRANSACTION_RECEIPTS:        50,\n\n    VERACK:   90\n};\nClass.register(Message);\n","class AddrMessage extends Message {\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     */\n    constructor(addresses) {\n        super(Message.Type.ADDR);\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof PeerAddress))) throw 'Malformed addresses';\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {AddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; ++i) {\n            addresses.push(PeerAddress.unserialize(buf));\n        }\n        return new AddrMessage(addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const addr of this._addresses) {\n            addr.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const addr of this._addresses) {\n            size += addr.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<PeerAddress>} */\n    get addresses() {\n        return this._addresses;\n    }\n}\nClass.register(AddrMessage);\n","class BlockMessage extends Message {\n    /**\n     * @param {Block} block\n     */\n    constructor(block) {\n        super(Message.Type.BLOCK);\n        // TODO Bitcoin block messages start with a block version\n        /** @type {Block} */\n        this._block = block;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const block = Block.unserialize(buf);\n        return new BlockMessage(block);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._block.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._block.serializedSize;\n    }\n\n    /** @type {Block} */\n    get block() {\n        return this._block;\n    }\n}\nClass.register(BlockMessage);\n","class GetAddrMessage extends Message {\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     */\n    constructor(protocolMask, serviceMask) {\n        super(Message.Type.GET_ADDR);\n        if (!NumberUtils.isUint8(protocolMask)) throw 'Malformed protocolMask';\n        if (!NumberUtils.isUint32(serviceMask)) throw 'Malformed serviceMask';\n        this._protocolMask = protocolMask;\n        this._serviceMask = serviceMask;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetAddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const protocolMask = buf.readUint8();\n        const serviceMask = buf.readUint32();\n        return new GetAddrMessage(protocolMask, serviceMask);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint8(this._protocolMask);\n        buf.writeUint32(this._serviceMask);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*protocolMask*/ 1\n            + /*serviceMask*/ 4;\n    }\n\n    /** @type {number} */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /** @type {number} */\n    get serviceMask() {\n        return this._serviceMask;\n    }\n}\nClass.register(GetAddrMessage);\n","class GetBlocksMessage extends Message {\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {GetBlocksMessage.Direction} direction\n     */\n    constructor(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, direction=GetBlocksMessage.Direction.FORWARD) {\n        super(Message.Type.GET_BLOCKS);\n        if (!locators || !NumberUtils.isUint16(locators.length)\n            || locators.some(it => !Hash.isHash(it))) throw 'Malformed locators';\n        if (!NumberUtils.isUint16(maxInvSize)) throw 'Malformed maxInvSize';\n        if (!NumberUtils.isUint8(direction)) throw 'Malformed direction';\n        /** @type {Array.<Hash>} */\n        this._locators = locators;\n        this._maxInvSize = maxInvSize;\n        this._direction = direction;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetBlocksMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const locators = [];\n        for (let i = 0; i < count; i++) {\n            locators.push(Hash.unserialize(buf));\n        }\n        const maxInvSize = buf.readUint16();\n        const direction = buf.readUint8();\n        return new GetBlocksMessage(locators, maxInvSize, direction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._locators.length);\n        for (const locator of this._locators) {\n            locator.serialize(buf);\n        }\n        buf.writeUint16(this._maxInvSize);\n        buf.writeUint8(this._direction);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2\n            + /*direction*/ 1\n            + /*maxInvSize*/ 2;\n        for (const locator of this._locators) {\n            size += locator.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<Hash>} */\n    get locators() {\n        return this._locators;\n    }\n\n    /** @type {GetBlocksMessage.Direction} */\n    get direction() {\n        return this._direction;\n    }\n\n    /** @type {number} */\n    get maxInvSize() {\n        return this._maxInvSize;\n    }\n}\n/**\n * @enum {number}\n */\nGetBlocksMessage.Direction = {\n    FORWARD: 0x1,\n    BACKWARD: 0x2\n};\nClass.register(GetBlocksMessage);\n","class HeaderMessage extends Message {\n    /**\n     * @param {BlockHeader} header\n     */\n    constructor(header) {\n        super(Message.Type.HEADER);\n        /** @type {BlockHeader} */\n        this._header = header;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const header = BlockHeader.unserialize(buf);\n        return new HeaderMessage(header);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._header.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._header.serializedSize;\n    }\n\n    /** @type {BlockHeader} */\n    get header() {\n        return this._header;\n    }\n}\nClass.register(HeaderMessage);\n","class InvVector {\n    /**\n     * @param {Block} block\n     * @returns {InvVector}\n     */\n    static fromBlock(block) {\n        const hash = block.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {InvVector}\n     */\n    static fromHeader(header) {\n        const hash = header.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @returns {InvVector}\n     */\n    static fromTransaction(tx) {\n        const hash = tx.hash();\n        return new InvVector(InvVector.Type.TRANSACTION, hash);\n    }\n\n    /**\n     * @param {InvVector.Type} type\n     * @param {Hash} hash\n     */\n    constructor(type, hash) {\n        // TODO validate type\n        if (!Hash.isHash(hash)) throw 'Malformed hash';\n        /** @type {InvVector.Type} */\n        this._type = type;\n        /** @type {Hash} */\n        this._hash = hash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {InvVector}\n     */\n    static unserialize(buf) {\n        const type = InvVector.Type.unserialize(buf);\n        const hash = Hash.unserialize(buf);\n        return new InvVector(type, hash);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint32(this._type);\n        this._hash.serialize(buf);\n        return buf;\n    }\n\n    /**\n     * @param {InvVector} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof InvVector\n            && this._type === o.type\n            && this._hash.equals(o.hash);\n    }\n\n    hashCode() {\n        return `${this._type}|${this._hash}`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `InvVector{type=${this._type}, hash=${this._hash}}`;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*invType*/ 4\n            + this._hash.serializedSize;\n    }\n\n    /** @type {InvVector.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n}\n/**\n * @enum {number}\n */\nInvVector.Type = {\n    ERROR: 0,\n    TRANSACTION: 1,\n    BLOCK: 2,\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvVector.Type}\n     */\n    unserialize: function (buf) {\n        return /** @type {InvVector.Type} */ (buf.readUint32());\n    }\n};\nClass.register(InvVector);\n\nclass BaseInventoryMessage extends Message {\n    /**\n     * @param {Message.Type} type\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(type, vectors) {\n        super(type);\n        if (!vectors || !NumberUtils.isUint16(vectors.length)\n            || vectors.some(it => !(it instanceof InvVector))\n            || vectors.length > BaseInventoryMessage.VECTORS_MAX_COUNT) throw 'Malformed vectors';\n        /** @type {Array.<InvVector>} */\n        this._vectors = vectors;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._vectors.length);\n        for (const vector of this._vectors) {\n            vector.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const vector of this._vectors) {\n            size += vector.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<InvVector>} */\n    get vectors() {\n        return this._vectors;\n    }\n}\nBaseInventoryMessage.VECTORS_MAX_COUNT = 1000;\nClass.register(BaseInventoryMessage);\n\nclass InvMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.INV, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new InvMessage(vectors);\n    }\n}\nClass.register(InvMessage);\n\nclass GetDataMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_DATA, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetDataMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetDataMessage(vectors);\n    }\n}\nClass.register(GetDataMessage);\n\nclass GetHeaderMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_HEADER, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetHeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetHeaderMessage(vectors);\n    }\n}\nClass.register(GetHeaderMessage);\n\nclass NotFoundMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.NOT_FOUND, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {NotFoundMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new NotFoundMessage(vectors);\n    }\n}\nClass.register(NotFoundMessage);\n","class MempoolMessage extends Message {\n    constructor() {\n        super(Message.Type.MEMPOOL);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MempoolMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new MempoolMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n}\nClass.register(MempoolMessage);\n","class PingMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PING);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PingMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PingMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n}\nClass.register(PingMessage);\n","class PongMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PONG);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PongMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PongMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n}\nClass.register(PongMessage);\n","class RejectMessage extends Message {\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     */\n    constructor(messageType, code, reason, extraData=new Uint8Array(0)) {\n        super(Message.Type.REJECT);\n        if (!NumberUtils.isUint64(messageType)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint8(code)) throw new Error('Malformed code');\n        if (StringUtils.isMultibyte(reason) || reason.length > 255) throw new Error('Malformed reason');\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint16(extraData.byteLength)) throw new Error('Malformed extraData');\n\n        /** @type {Message.Type} */\n        this._messageType = messageType;\n        /** @type {RejectMessage.Code} */\n        this._code = code;\n        /** @type {string} */\n        this._reason = reason;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RejectMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const messageType = /** @type {Message.Type} */ buf.readVarUint();\n        const code = /** @type {RejectMessage.Code} */ buf.readUint8();\n        const reason = buf.readVarLengthString();\n        const length = buf.readUint16();\n        const extraData = buf.read(length);\n        return new RejectMessage(messageType, code, reason, extraData);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarUint(this._messageType);\n        buf.writeUint8(this._code);\n        buf.writeVarLengthString(this._reason);\n        buf.writeUint16(this._extraData.byteLength);\n        buf.write(this._extraData);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varUintSize(this._messageType)\n            + /*code*/ 1\n            + SerialBuffer.varLengthStringSize(this._reason)\n            + /*extraDataLength*/ 2\n            + this._extraData.byteLength;\n    }\n\n    /** @type {Message.Type} */\n    get messageType() {\n        return this._messageType;\n    }\n\n    /** @type {RejectMessage.Code} */\n    get code() {\n        return this._code;\n    }\n\n    /** @type {string} */\n    get reason() {\n        return this._reason;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n}\n/**\n * @enum {number}\n */\nRejectMessage.Code = {\n    REJECT_MALFORMED: 0x01,\n    REJECT_INVALID: 0x10,\n    REJECT_OBSOLETE: 0x11,\n    REJECT_DOUBLE: 0x12,\n    REJECT_DUST: 0x41,\n    REJECT_INSUFFICIENT_FEE: 0x42\n};\nClass.register(RejectMessage);\n","class SignalMessage extends Message {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     */\n    constructor(senderId, recipientId, nonce, ttl, flags = 0, payload = new Uint8Array(0), senderPubKey, signature) {\n        super(Message.Type.SIGNAL);\n        if (!(senderId instanceof PeerId)) throw 'Malformed senderId';\n        if (!(recipientId instanceof PeerId)) throw 'Malformed recipientId';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        if (!NumberUtils.isUint8(ttl)) throw 'Malformed ttl';\n        if (!NumberUtils.isUint8(flags)) throw 'Malformed flags';\n        if (!(payload instanceof Uint8Array) || !NumberUtils.isUint16(payload.byteLength)) throw 'Malformed payload';\n        const hasPayload = payload.byteLength > 0;\n        if (hasPayload && !(signature instanceof Signature)) throw 'Malformed signature';\n        if (hasPayload && !(senderPubKey instanceof PublicKey)) throw 'Malformed public key';\n\n        // Note that the signature is NOT verified here.\n        // Callers must explicitly invoke verifySignature() to check it.\n\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n        /** @type {number} */\n        this._ttl = ttl;\n        /** @type {SignalMessage.Flags|number} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._payload = payload;\n        /** @type {PublicKey} */\n        this._senderPubKey = hasPayload ? senderPubKey : undefined;\n        /** @type {Signature} */\n        this._signature = hasPayload ? signature : undefined;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SignalMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const senderId = PeerId.unserialize(buf);\n        const recipientId = PeerId.unserialize(buf);\n        const nonce = buf.readUint32();\n        const ttl = buf.readUint8();\n        const flags = buf.readUint8();\n        const length = buf.readUint16();\n        const payload = buf.read(length);\n        const senderPubKey = length > 0 ? PublicKey.unserialize(buf) : undefined;\n        const signature = length > 0 ? Signature.unserialize(buf) : undefined;\n        return new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._senderId.serialize(buf);\n        this._recipientId.serialize(buf);\n        buf.writeUint32(this._nonce);\n        buf.writeUint8(this._ttl);\n        buf.writeUint8(this._flags);\n        buf.writeUint16(this._payload.byteLength);\n        buf.write(this._payload);\n        if (this._payload.byteLength > 0) {\n            this._senderPubKey.serialize(buf);\n            this._signature.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*senderId*/ this._senderId.serializedSize\n            + /*recipientId*/ this._recipientId.serializedSize\n            + /*nonce*/ 4\n            + /*ttl*/ 1\n            + /*flags*/ 1\n            + /*payloadLength*/ 2\n            + this._payload.byteLength\n            + (this._payload.byteLength > 0 ? this._senderPubKey.serializedSize : 0)\n            + (this._payload.byteLength > 0 ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    verifySignature() {\n        if (!this._signature) {\n            return false;\n        }\n\n        return this._signature.verify(this._senderPubKey, this._payload)\n            && this._senderId.equals(this._senderPubKey.toPeerId());\n    }\n\n    /** @type {PeerId} */\n    get senderId() {\n        return this._senderId;\n    }\n\n    /** @type {PeerId} */\n    get recipientId() {\n        return this._recipientId;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    /** @type {number} */\n    get ttl() {\n        return this._ttl;\n    }\n\n    /** @type {SignalMessage.Flags|number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /** @type {Uint8Array} */\n    get payload() {\n        return this._payload;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {PublicKey} */\n    get senderPubKey() {\n        return this._senderPubKey;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasPayload() {\n        return this._payload.byteLength > 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isUnroutable() {\n        return (this._flags & SignalMessage.Flag.UNROUTABLE) !== 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTtlExceeded() {\n        return (this._flags & SignalMessage.Flag.TTL_EXCEEDED) !== 0;\n    }\n}\n/**\n * @enum {number}\n */\nSignalMessage.Flag = {\n    UNROUTABLE: 0x1,\n    TTL_EXCEEDED: 0x2\n};\nClass.register(SignalMessage);\n","class SubscribeMessage extends Message {\n    constructor(subscription) {\n        super(Message.Type.SUBSCRIBE);\n        this._subscription = subscription;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SubscribeMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const subscription = Subscription.unserialize(buf);\n        return new SubscribeMessage(subscription);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._subscription.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._subscription.serializedSize;\n    }\n\n    /** @type {Subscription} */\n    get subscription() {\n        return this._subscription;\n    }\n}\nClass.register(SubscribeMessage);\n","class TxMessage extends Message {\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     */\n    constructor(transaction, accountsProof) {\n        super(Message.Type.TX);\n        /** @type {Transaction} */\n        this._transaction = transaction;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TxMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const transaction = Transaction.unserialize(buf);\n        const hasAccountsProof = buf.readUint8();\n        if (hasAccountsProof === 1) {\n            const accountsProof = AccountsProof.unserialize(buf);\n            return new TxMessage(transaction, accountsProof);\n        }\n        return new TxMessage(transaction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._transaction.serialize(buf);\n        buf.writeUint8(this._accountsProof ? 1 : 0);\n        if (this._accountsProof) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + this._transaction.serializedSize\n            + /*hasAccountsProof*/ 1;\n        if (this._accountsProof) {\n            size += this._accountsProof.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Transaction} */\n    get transaction() {\n        return this._transaction;\n    }\n\n    /** @type {boolean} */\n    get hasAccountsProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {AccountsProof} */\n    get accountsProof() {\n        return this._accountsProof;\n    }\n}\nClass.register(TxMessage);\n","class VersionMessage extends Message {\n    /**\n     * @param {number} version\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} genesisHash\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     */\n    constructor(version, peerAddress, genesisHash, headHash, challengeNonce) {\n        super(Message.Type.VERSION);\n        if (!NumberUtils.isUint32(version)) throw new Error('Malformed version');\n        if (!(peerAddress instanceof PeerAddress)) throw new Error('Malformed peerAddress');\n        if (!Hash.isHash(genesisHash)) throw new Error('Malformed genesisHash');\n        if (!Hash.isHash(headHash)) throw new Error('Malformed headHash');\n        if (!(challengeNonce instanceof Uint8Array) || challengeNonce.byteLength !== 32) throw new Error('Malformed challenge nonce');\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n        /** @type {Hash} */\n        this._genesisHash = genesisHash;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /** @type {Uint8Array} */\n        this._challengeNonce = challengeNonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {VersionMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const version = buf.readUint32();\n        const peerAddress = PeerAddress.unserialize(buf);\n        const genesisHash = Hash.unserialize(buf);\n        const headHash = Hash.unserialize(buf);\n        const challengeNonce = buf.read(VersionMessage.CHALLENGE_SIZE);\n        return new VersionMessage(version, peerAddress, genesisHash, headHash, challengeNonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._version);\n        this._peerAddress.serialize(buf);\n        this._genesisHash.serialize(buf);\n        this._headHash.serialize(buf);\n        buf.write(this._challengeNonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*version*/ 4\n            + this._peerAddress.serializedSize\n            + this._genesisHash.serializedSize\n            + this._headHash.serializedSize\n            + VersionMessage.CHALLENGE_SIZE;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {Hash} */\n    get genesisHash() {\n        return this._genesisHash;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {Uint8Array} */\n    get challengeNonce() {\n        return this._challengeNonce;\n    }\n}\n\nVersionMessage.CHALLENGE_SIZE = 32;\nClass.register(VersionMessage);\n","class VerAckMessage extends Message {\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     */\n    constructor(publicKey, signature) {\n        super(Message.Type.VERACK);\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VerAckMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new VerAckMessage(publicKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this.publicKey.serialize(buf);\n        this.signature.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._publicKey.serializedSize\n            + this._signature.serializedSize;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n}\nClass.register(VerAckMessage);\n","class AccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [accountsProof]\n     */\n    constructor(blockHash, accountsProof=null) {\n        super(Message.Type.ACCOUNTS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (accountsProof && !(accountsProof instanceof AccountsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let accountsProof = null;\n        if (hasProof !== 0) {\n            accountsProof = AccountsProof.unserialize(buf);\n        }\n        return new AccountsProofMessage(blockHash, accountsProof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._accountsProof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._accountsProof;\n    }\n}\nClass.register(AccountsProofMessage);\n","class GetAccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_ACCOUNTS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.length < 1\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetAccountsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetAccountsProofMessage);\n","class ChainProofMessage extends Message {\n    /**\n     * @param {ChainProof} proof\n     */\n    constructor(proof) {\n        super(Message.Type.CHAIN_PROOF);\n        if (!(proof instanceof ChainProof)) throw 'Malformed chainProof';\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {ChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const proof = ChainProof.unserialize(buf);\n        return new ChainProofMessage(proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._proof.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._proof.serializedSize;\n    }\n\n    /** @type {ChainProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(ChainProofMessage);\n","class GetChainProofMessage extends Message {\n    constructor() {\n        super(Message.Type.GET_CHAIN_PROOF);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new GetChainProofMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n}\nClass.register(GetChainProofMessage);\n","class AccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [accountsTreeChunk]\n     */\n    constructor(blockHash, accountsTreeChunk=null) {\n        super(Message.Type.ACCOUNTS_TREE_CHUNK);\n        if (!(blockHash instanceof Hash)) throw 'Malformed blockHash';\n        if (accountsTreeChunk && !(accountsTreeChunk instanceof AccountsTreeChunk)) throw 'Malformed chunk';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsTreeChunk} */\n        this._accountsTreeChunk = accountsTreeChunk;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasChunk = buf.readUint8();\n        let accountsTreeChunk = null;\n        if (hasChunk !== 0) {\n            accountsTreeChunk = AccountsTreeChunk.unserialize(buf);\n        }\n        return new AccountsTreeChunkMessage(blockHash, accountsTreeChunk);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasChunk() ? 1 : 0);\n        if (this.hasChunk()) {\n            this._accountsTreeChunk.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasChunk() ? this._accountsTreeChunk.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasChunk() {\n        return !!this._accountsTreeChunk;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsTreeChunk} */\n    get chunk() {\n        return this._accountsTreeChunk;\n    }\n}\nClass.register(AccountsTreeChunkMessage);\n","class GetAccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     */\n    constructor(blockHash, startPrefix) {\n        super(Message.Type.GET_ACCOUNTS_TREE_CHUNK);\n        if (!blockHash || !(blockHash instanceof Hash)) throw 'Malformed block hash';\n        if (StringUtils.isMultibyte(startPrefix)\n            || !NumberUtils.isUint8(startPrefix.length)) throw 'Malformed start prefix';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        this._startPrefix = startPrefix;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const startPrefix = buf.readVarLengthString();\n        return new GetAccountsTreeChunkMessage(blockHash, startPrefix);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeVarLengthString(this._startPrefix);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + SerialBuffer.varLengthStringSize(this._startPrefix);\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {string} */\n    get startPrefix() {\n        return this._startPrefix;\n    }\n}\nClass.register(GetAccountsTreeChunkMessage);\n","class TransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     */\n    constructor(blockHash, proof=null) {\n        super(Message.Type.TRANSACTIONS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (proof && !(proof instanceof TransactionsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {TransactionsProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let proof = null;\n        if (hasProof !== 0) {\n            proof = TransactionsProof.unserialize(buf);\n        }\n        return new TransactionsProofMessage(blockHash, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._proof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._proof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._proof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {TransactionsProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProofMessage);\n","class GetTransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_TRANSACTIONS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetTransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetTransactionsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetTransactionsProofMessage);\n","class GetTransactionReceiptsMessage extends Message {\n    /**\n     * @param {Address} address\n     */\n    constructor(address) {\n        super(Message.Type.GET_TRANSACTION_RECEIPTS);\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n        /** @type {Address} */\n        this._address = address;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetTransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const address = Address.unserialize(buf);\n        return new GetTransactionReceiptsMessage(address);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._address.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._address.serializedSize;\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n}\nClass.register(GetTransactionReceiptsMessage);\n","class TransactionReceiptsMessage extends Message {\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     */\n    constructor(transactionReceipts) {\n        super(Message.Type.TRANSACTION_RECEIPTS);\n        if (!transactionReceipts || !NumberUtils.isUint16(transactionReceipts.length)\n            || transactionReceipts.some(it => !(it instanceof TransactionReceipt))\n            || transactionReceipts.length > TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) throw new Error('Malformed transactionReceipts');\n        /** @type {Array.<TransactionReceipt>} */\n        this._transactionReceipts = transactionReceipts;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const transactionReceipts = [];\n        for (let i = 0; i < count; ++i) {\n            transactionReceipts.push(TransactionReceipt.unserialize(buf));\n        }\n        return new TransactionReceiptsMessage(transactionReceipts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._transactionReceipts.length);\n        for (const receipt of this._transactionReceipts) {\n            receipt.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*count*/ 2\n            + this._transactionReceipts.reduce((sum, receipt) => sum + receipt.serializedSize, 0);\n    }\n\n    /** @type {Array.<TransactionReceipt>} */\n    get transactionReceipts() {\n        return this._transactionReceipts;\n    }\n}\nClass.register(TransactionReceiptsMessage);\nTransactionReceiptsMessage.RECEIPTS_MAX_COUNT = 500;\n","class MessageFactory {\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        return Message.peekType(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static parse(buf) {\n        const type = Message.peekType(buf);\n        const clazz = MessageFactory.CLASSES[type];\n        if (!clazz || !clazz.unserialize) throw new Error(`Invalid message type: ${type}`);\n        return clazz.unserialize(buf);\n    }\n}\n/**\n * @dict \n * @type {object}\n */\nMessageFactory.CLASSES = {};\nMessageFactory.CLASSES[Message.Type.VERSION] = VersionMessage;\nMessageFactory.CLASSES[Message.Type.INV] = InvMessage;\nMessageFactory.CLASSES[Message.Type.GET_DATA] = GetDataMessage;\nMessageFactory.CLASSES[Message.Type.GET_HEADER] = GetHeaderMessage;\nMessageFactory.CLASSES[Message.Type.NOT_FOUND] = NotFoundMessage;\nMessageFactory.CLASSES[Message.Type.BLOCK] = BlockMessage;\nMessageFactory.CLASSES[Message.Type.HEADER] = HeaderMessage;\nMessageFactory.CLASSES[Message.Type.TX] = TxMessage;\nMessageFactory.CLASSES[Message.Type.GET_BLOCKS] = GetBlocksMessage;\nMessageFactory.CLASSES[Message.Type.MEMPOOL] = MempoolMessage;\nMessageFactory.CLASSES[Message.Type.REJECT] = RejectMessage;\nMessageFactory.CLASSES[Message.Type.SUBSCRIBE] = SubscribeMessage;\nMessageFactory.CLASSES[Message.Type.ADDR] = AddrMessage;\nMessageFactory.CLASSES[Message.Type.GET_ADDR] = GetAddrMessage;\nMessageFactory.CLASSES[Message.Type.PING] = PingMessage;\nMessageFactory.CLASSES[Message.Type.PONG] = PongMessage;\nMessageFactory.CLASSES[Message.Type.SIGNAL] = SignalMessage;\nMessageFactory.CLASSES[Message.Type.GET_CHAIN_PROOF] = GetChainProofMessage;\nMessageFactory.CLASSES[Message.Type.CHAIN_PROOF] = ChainProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_PROOF] = GetAccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_PROOF] = AccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = GetAccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_TREE_CHUNK] = AccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTIONS_PROOF] = GetTransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTIONS_PROOF] = TransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTION_RECEIPTS] = GetTransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTION_RECEIPTS] = TransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.VERACK] = VerAckMessage;\nClass.register(MessageFactory);\n","class WebRtcConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     */\n    constructor(networkConfig) {\n        super();\n\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n\n        /** @type {HashMap.<PeerId,PeerConnector>} */\n        this._connectors = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {PeerChannel} signalChannel\n     * @returns {boolean}\n     */\n    connect(peerAddress, signalChannel) {\n        if (peerAddress.protocol !== Protocol.RTC) throw 'Malformed peerAddress';\n\n        const peerId = peerAddress.peerId;\n        if (this._connectors.contains(peerId)) {\n            return false;\n        }\n\n        const connector = new OutboundPeerConnector(this._networkConfig, peerAddress, signalChannel);\n        connector.on('connection', conn => this._onConnection(conn, peerId));\n        this._connectors.put(peerId, connector);\n\n        this._timers.setTimeout(`connect_${peerId}`, () => {\n            this._connectors.remove(peerId);\n            this._timers.clearTimeout(`connect_${peerId}`);\n            this.fire('error', peerAddress, 'timeout');\n        }, WebRtcConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    isValidSignal(msg) {\n        return this._connectors.contains(msg.senderId) && this._connectors.get(msg.senderId).nonce === msg.nonce;\n    }\n\n    onSignal(channel, msg) {\n        // Check if we received an unroutable/ttl exceeded response from one of the signaling peers.\n        if (msg.isUnroutable() || msg.isTtlExceeded()) {\n            // Clear the timeout early if we initiated the connection.\n            if (this.isValidSignal(msg) && this._connectors.get(msg.senderId) instanceof OutboundPeerConnector) {\n                const peerAddress = this._connectors.get(msg.senderId).peerAddress;\n\n                this._connectors.remove(msg.senderId);\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                // XXX Reason needs to be adapted when more flags are added.\n                const reason = msg.isUnroutable() ? 'unroutable' : 'ttl exceeded';\n                this.fire('error', peerAddress, reason);\n            }\n\n            return;\n        }\n\n        let payload;\n        try {\n            payload = JSON.parse(BufferUtils.toAscii(msg.payload));\n        } catch (e) {\n            Log.e(WebRtcConnector, `Failed to parse signal payload from ${msg.senderId}`);\n            return;\n        }\n\n        if (!payload) {\n            Log.d(WebRtcConnector, `Discarding signal from ${msg.senderId} - empty payload`);\n            return;\n        }\n\n        if (payload.type === 'offer') {\n            // Check if we have received an offer on an ongoing connection.\n            // This can happen if two peers initiate connections to one another\n            // simultaneously. Resolve this by having the peer with the higher\n            // peerId discard the offer while the one with the lower peerId\n            // accepts it.\n            /** @type {PeerConnector} */\n            let connector = this._connectors.get(msg.senderId);\n            if (connector) {\n                if (msg.recipientId.compare(msg.senderId) > 0) {\n                    // Discard the offer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, discarding offer from ${msg.senderId} (<${msg.recipientId})`);\n                    return;\n                } else if (connector instanceof InboundPeerConnector) {\n                    // We have already seen an offer from this peer. Forward it to the existing connector.\n                    Log.w(WebRtcConnector, `Duplicate offer received from ${msg.senderId}`);\n                    connector.onSignal(payload);\n                    return;\n                } else {\n                    // We are going to accept the offer. Clear the connect timeout\n                    // from our previous outbound connection attempt to this peer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, accepting offer from ${msg.senderId} (>${msg.recipientId})`);\n                    this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                    // XXX Abort the outbound connection attempt.\n                    this.fire('error', connector.peerAddress, 'simultaneous inbound connection');\n                }\n            }\n\n            // Accept the offer.\n            connector = new InboundPeerConnector(this._networkConfig, channel, msg.senderId, payload);\n            connector.on('connection', conn => this._onConnection(conn, msg.senderId));\n            this._connectors.put(msg.senderId, connector);\n\n            this._timers.setTimeout(`connect_${msg.senderId}`, () => {\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n                this._connectors.remove(msg.senderId);\n            }, WebRtcConnector.CONNECT_TIMEOUT);\n        }\n\n        // If we are already establishing a connection with the sender of this\n        // signal, forward it to the corresponding connector.\n        else if (this._connectors.contains(msg.senderId)) {\n            this._connectors.get(msg.senderId).onSignal(payload);\n        }\n\n        // If none of the above conditions is met, the signal is invalid and we discard it.\n    }\n\n    _onConnection(conn, peerId) {\n        // Clear the connect timeout.\n        this._timers.clearTimeout(`connect_${peerId}`);\n\n        // Clean up when this connection closes.\n        conn.on('close', () => this._onClose(peerId));\n\n        // Tell listeners about the new connection.\n        this.fire('connection', conn);\n    }\n\n    _onClose(peerId) {\n        this._connectors.remove(peerId);\n        this._timers.clearTimeout(`connect_${peerId}`);\n    }\n}\nWebRtcConnector.CONNECT_TIMEOUT = 5000; // ms\nClass.register(WebRtcConnector);\n\nclass PeerConnector extends Observable {\n    /**\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} signalChannel\n     * @param {PeerId} peerId\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(networkConfig, signalChannel, peerId, peerAddress) {\n        super();\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._signalChannel = signalChannel;\n        /** @type {PeerId} */\n        this._peerId = peerId;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress; // null for inbound connections\n\n        /** @type {number} */\n        this._nonce = NumberUtils.randomUint32();\n\n        /** @type {RTCPeerConnection} */\n        this._rtcConnection = WebRtcFactory.newPeerConnection(this._networkConfig.rtcConfig);\n        this._rtcConnection.onicecandidate = e => this._onIceCandidate(e);\n\n        this._lastIceCandidate = null;\n        this._iceCandidateQueue = [];\n    }\n\n    onSignal(signal) {\n        if (signal.sdp) {\n            this._rtcConnection.setRemoteDescription(WebRtcFactory.newSessionDescription(signal))\n                .then(() => {\n                    if (signal.type === 'offer') {\n                        this._rtcConnection.createAnswer()\n                            .then(description => this._onDescription(description))\n                            .catch(Log.e.tag(PeerConnector));\n                    }\n\n                    this._handleCandidateQueue().catch(Log.w.tag(PeerConnector));\n                })\n                .catch(Log.e.tag(PeerConnector));\n        } else if (signal.candidate) {\n            this._addIceCandidate(signal).catch(Log.w.tag(PeerConnector));\n        }\n    }\n\n    /**\n     * @param {*} signal\n     * @returns {Promise}\n     * @private\n     */\n    _addIceCandidate(signal) {\n        this._lastIceCandidate = WebRtcFactory.newIceCandidate(signal);\n\n        // Do not try to add ICE candidates before the remote description is set.\n        if (!this._rtcConnection.remoteDescription || !this._rtcConnection.remoteDescription.type) {\n            this._iceCandidateQueue.push(signal);\n            return Promise.resolve();\n        }\n\n        return this._rtcConnection.addIceCandidate(this._lastIceCandidate)\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    async _handleCandidateQueue() {\n        // Handle ICE candidates if they already arrived.\n        for (const candidate of this._iceCandidateQueue) {\n            await this._addIceCandidate(candidate);\n        }\n        this._iceCandidateQueue = [];\n    }\n\n    _signal(signal) {\n        const payload = BufferUtils.fromAscii(JSON.stringify(signal));\n        const keyPair = this._networkConfig.keyPair;\n        const peerId = this._networkConfig.peerId;\n        this._signalChannel.signal(\n            peerId,\n            this._peerId,\n            this._nonce,\n            Network.SIGNAL_TTL_INITIAL,\n            0, /*flags*/\n            payload,\n            keyPair.publicKey,\n            Signature.create(keyPair.privateKey, keyPair.publicKey, payload)\n        );\n    }\n\n    _onIceCandidate(event) {\n        if (event.candidate !== null) {\n            this._signal(event.candidate);\n        }\n    }\n\n    _onDescription(description) {\n        this._rtcConnection.setLocalDescription(description)\n            .then(() => this._signal(this._rtcConnection.localDescription))\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    _onDataChannel(event) {\n        const channel = new WebRtcDataChannel(event.channel || event.target);\n\n        // There is no API to get the remote IP address. As a crude heuristic, we parse the IP address\n        // from the last ICE candidate seen before the connection was established.\n        // TODO Can we improve this?\n        let netAddress = null;\n        if (this._lastIceCandidate) {\n            try {\n                netAddress = WebRtcUtils.candidateToNetAddress(this._lastIceCandidate);\n            } catch (e) {\n                Log.w(PeerConnector, `Failed to parse IP from ICE candidate: ${this._lastIceCandidate}`);\n            }\n        } else {\n            // XXX Why does this happen?\n            Log.w(PeerConnector, 'No ICE candidate seen for inbound connection');\n        }\n\n        const conn = new NetworkConnection(channel, Protocol.RTC, netAddress, this._peerAddress);\n        this.fire('connection', conn);\n    }\n\n    get nonce() {\n        return this._nonce;\n    }\n\n    get peerAddress() {\n        return this._peerAddress;\n    }\n}\nClass.register(PeerConnector);\n\nclass OutboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, peerAddress, signalChannel) {\n        super(webRtcConfig, signalChannel, peerAddress.peerId, peerAddress);\n        this._peerAddress = peerAddress;\n\n        // Create offer.\n        const channel = this._rtcConnection.createDataChannel('data-channel');\n        channel.binaryType = 'arraybuffer';\n        channel.onopen = e => this._onDataChannel(e);\n        this._rtcConnection.createOffer()\n            .then(description => this._onDescription(description))\n            .catch(Log.e.tag(OutboundPeerConnector));\n    }\n}\nClass.register(OutboundPeerConnector);\n\nclass InboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, signalChannel, peerId, offer) {\n        super(webRtcConfig, signalChannel, peerId, null);\n        this._rtcConnection.ondatachannel = event => {\n            event.channel.onopen = e => this._onDataChannel(e);\n        };\n        this.onSignal(offer);\n    }\n}\nClass.register(InboundPeerConnector);\n","class WebRtcDataChannel extends DataChannel {\n    /**\n     * @param {RTCDataChannel} nativeChannel\n     */\n    constructor(nativeChannel) {\n        super();\n        // We expect WebRtc data channels to be ordered.\n        Assert.that(nativeChannel.ordered, 'WebRtc data channel not ordered');\n        /** @type {RTCDataChannel} */\n        this._channel = nativeChannel;\n\n        this._channel.onmessage = msg => this._onMessage(msg.data || msg);\n        this._channel.onclose = () => this._onClose();\n        this._channel.onerror = e => this.fire('error', e, this);\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     * @override\n     */\n    _onMessage(msg) {\n        // FIXME It seems that Firefox still sometimes receives blobs instead of ArrayBuffers on RTC connections.\n        // FIXME FileReader is async and may RE-ORDER MESSAGES!\n        if (msg instanceof Blob) {\n            const reader = new FileReader();\n            reader.onloadend = () => super._onMessage(reader.result);\n            reader.readAsArrayBuffer(msg);\n        } else {\n            super._onMessage(msg);\n        }\n    }\n    /**\n     * @override\n     */\n    sendChunk(msg) {\n        this._channel.send(msg);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._channel.close();\n    }\n\n    /**\n     * @override\n     */\n    get readyState() {\n        return DataChannel.ReadyState.fromString(this._channel.readyState);\n    }\n}\n\nClass.register(WebRtcDataChannel);\n","class WebRtcUtils {\n    static candidateToNetAddress(candidate) {\n        // TODO XXX Ad-hoc parsing of candidates - Improve!\n        const parts = candidate.candidate.split(' ');\n        if (parts.length < 6) {\n            return null;\n        }\n        return NetAddress.fromIP(parts[4]);\n    }\n}\nClass.register(WebRtcUtils);\n","class WebSocketConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @listens WebSocketServer#connection\n     */\n    constructor(networkConfig) {\n        super();\n\n        if (networkConfig.peerAddress.protocol === Protocol.WS) {\n            this._wss = WebSocketFactory.newWebSocketServer(networkConfig);\n            this._wss.on('connection', ws => this._onConnection(ws));\n\n            Log.d(WebSocketConnector, `WebSocketConnector listening on port ${networkConfig.peerAddress.port}`);\n        }\n\n        this._timers = new Timers();\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @fires WebSocketConnector#error\n     * @param {PeerAddress} peerAddress\n     * @return {boolean}\n     */\n    connect(peerAddress) {\n        if (peerAddress.protocol !== Protocol.WS) throw 'Malformed peerAddress';\n\n        const timeoutKey = `connect_${peerAddress}`;\n        if (this._timers.timeoutExists(timeoutKey)) {\n            Log.w(WebSocketConnector, `Already connecting to ${peerAddress}`);\n            return false;\n        }\n\n        const ws = WebSocketFactory.newWebSocket(`wss://${peerAddress.host}:${peerAddress.port}`, {\n            handshakeTimeout: WebSocketConnector.CONNECT_TIMEOUT\n        });\n        ws.binaryType = 'arraybuffer';\n        ws.onopen = () => {\n            this._timers.clearTimeout(timeoutKey);\n\n            // Don't fire error events after the connection has been established.\n            ws.onerror = () => {};\n\n            // There is no way to determine the remote IP in the browser ... thanks for nothing, WebSocket API.\n            const netAddress = (ws._socket && ws._socket.remoteAddress) ? NetAddress.fromIP(ws._socket.remoteAddress) : null;\n            const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, peerAddress);\n            this.fire('connection', conn);\n        };\n        ws.onerror = e => {\n            this._timers.clearTimeout(timeoutKey);\n\n            /**\n             * Tell listeners that an error has ocurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, e);\n        };\n\n        this._timers.setTimeout(timeoutKey, () => {\n            this._timers.clearTimeout(timeoutKey);\n\n            // We don't want to fire the error event again if the websocket\n            // connect fails at a later time.\n            ws.onerror = () => {};\n\n            // If the connection succeeds after we have fired the error event,\n            // close it.\n            ws.onopen = () => {\n                Log.w(WebSocketConnector, `Connection to ${peerAddress} succeeded after timeout - closing it`);\n                ws.close();\n            };\n\n            /**\n             * Tell listeners that a timeout error has ocurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, 'timeout');\n        }, WebSocketConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @param {WebSocket} ws\n     * @return {void}\n     */\n    _onConnection(ws) {\n        const netAddress = NetAddress.fromIP(ws._socket.remoteAddress);\n        const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, /*peerAddress*/ null);\n\n        /**\n        * Tell listeners that an initial connection to a peer has been established.\n        * @event WebSocketConnector#connection\n        */\n        this.fire('connection', conn);\n    }\n}\nWebSocketConnector.CONNECT_TIMEOUT = 1000 * 5; // 5 seconds\nClass.register(WebSocketConnector);\n","class WebSocketDataChannel extends DataChannel {\n    /**\n     * @param {WebSocket} ws\n     */\n    constructor(ws) {\n        super();\n        /** @type {WebSocket} */\n        this._ws = ws;\n        this._ws.onmessage = msg => this._onMessage(msg.data || msg);\n        this._ws.onclose = () => this._onClose();\n        this._ws.onerror = e => this.fire('error', e);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._ws.close();\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array} msg\n     */\n    sendChunk(msg) {\n        this._ws.send(msg);\n    }\n\n    /**\n     * @override\n     * @type {DataChannel.ReadyState}\n     */\n    get readyState() {\n        return /** @type {DataChannel.ReadyState} */ this._ws.readyState;\n    }\n}\n\nClass.register(WebSocketDataChannel);\n","class NetAddress {\n    /**\n     * @param {string} ip\n     * @return {NetAddress}\n     */\n    static fromIP(ip) {\n        const saneIp = NetUtils.sanitizeIP(ip);\n        return new NetAddress(saneIp);\n    }\n\n    /**\n     * @param {string} ip\n     */\n    constructor(ip) {\n        /** @type {string} */\n        this._ip = ip;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {NetAddress}\n     */\n    static unserialize(buf) {\n        const ip = buf.readVarLengthString();\n\n        // Allow empty NetAddresses.\n        if (!ip) {\n            return NetAddress.UNSPECIFIED;\n        }\n\n        return NetAddress.fromIP(ip);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeVarLengthString(this._ip);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return SerialBuffer.varLengthStringSize(this._ip);\n    }\n\n    /**\n     * @param {NetAddress} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetAddress\n            && this._ip === o.ip;\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `${this._ip}`;\n    }\n\n    /** @type {string} */\n    get ip() {\n        return this._ip;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPseudo() {\n        return !this._ip || NetAddress.UNKNOWN.equals(this);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPrivate() {\n        return this.isPseudo() || NetUtils.isPrivateIP(this._ip);\n    }\n}\nNetAddress.UNSPECIFIED = new NetAddress('');\nNetAddress.UNKNOWN = new NetAddress('<unknown>');\nClass.register(NetAddress);\n","class PeerId extends Primitive {\n    /**\n     * @param {PeerId} o\n     * @returns {PeerId}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new PeerId(obj);\n    }\n\n    constructor(arg) {\n        super(arg, Uint8Array, PeerId.SERIALIZED_SIZE);\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {PeerId} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new PeerId(buf.read(PeerId.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return PeerId.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerId\n            && super.equals(o);\n    }\n\n    /**\n     * @returns {string}\n     * @override\n     */\n    toString() {\n        return this.toHex();\n    }\n\n    /**\n     * @param {string} base64\n     * @return {PeerId}\n     */\n    static fromBase64(base64) {\n        return new PeerId(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {PeerId}\n     */\n    static fromHex(hex) {\n        return new PeerId(BufferUtils.fromHex(hex));\n    }\n}\n\nPeerId.SERIALIZED_SIZE = 16;\nClass.register(PeerId);\n","class PeerAddress {\n    /**\n     * @param {number} protocol\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(protocol, services, timestamp, netAddress, publicKey, distance, signature) {\n        if (!NumberUtils.isUint8(distance)) throw new Error('Malformed distance');\n        if (publicKey !== null && !(publicKey instanceof PublicKey)) throw new Error('Malformed publicKey');\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {number} */\n        this._services = services;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress || NetAddress.UNSPECIFIED;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {number} */\n        this._distance = distance;\n        /** @type {?Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PeerAddress}\n     */\n    static unserialize(buf) {\n        const protocol = buf.readUint8();\n        switch (protocol) {\n            case Protocol.WS:\n                return WsPeerAddress.unserialize(buf);\n\n            case Protocol.RTC:\n                return RtcPeerAddress.unserialize(buf);\n\n            case Protocol.DUMB:\n                return DumbPeerAddress.unserialize(buf);\n\n            default:\n                throw `Malformed PeerAddress protocol ${protocol}`;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        if (!this._publicKey) throw new Error('PeerAddress without publicKey may not be serialized.');\n        if (!this._signature) throw new Error('PeerAddress without signature may not be serialized.');\n\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        // Never serialize private netAddresses.\n        if (this._netAddress.isPrivate()) {\n            NetAddress.UNSPECIFIED.serialize(buf);\n        } else {\n            this._netAddress.serialize(buf);\n        }\n\n        this._publicKey.serialize(buf);\n        buf.writeUint8(this._distance);\n        this._signature.serialize(buf);\n\n        return buf;\n    }\n\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8\n            + this._netAddress.serializedSize\n            + this._publicKey.serializedSize\n            + /*distance*/ 1\n            + this._signature.serializedSize;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8;\n    }\n\n    /**\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        // We consider peer addresses to be equal if the public key or peer id is not known on one of them:\n        // Peers from the network always contain a peer id and public key, peers without peer id or public key\n        // are always set by the user.\n        return o instanceof PeerAddress\n            && this.protocol === o.protocol\n            && (!this.publicKey || !o.publicKey || this.publicKey.equals(o.publicKey))\n            && (!this.peerId || !o.peerId || this.peerId.equals(o.peerId));\n            /* services is ignored */\n            /* timestamp is ignored */\n            /* netAddress is ignored */\n            /* distance is ignored */\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verifySignature() {\n        if (this._signatureVerified === undefined) {\n            this._signatureVerified = this.signature.verify(this.publicKey, this.serializeContent());\n        }\n        return this._signatureVerified;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {number} */\n    get services() {\n        return this._services;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress.isPseudo() ? null : this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value || NetAddress.UNSPECIFIED;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {PeerId} */\n    get peerId() {\n        return this._publicKey ? this._publicKey.toPeerId() : null;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        // Never change the signature of a remote address.\n        if (this._distance !== 0) {\n            return;\n        }\n\n        this._signature = signature;\n        this._signatureVerified = undefined;\n    }\n\n    // Changed when passed on to other peers.\n    /** @type {number} */\n    set distance(value) {\n        this._distance = value;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isSeed() {\n        return this._timestamp === 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    exceedsAge() {\n        // Seed addresses are never too old.\n        if (this.isSeed()) {\n            return false;\n        }\n\n        const age = Date.now() - this.timestamp;\n        switch (this.protocol) {\n            case Protocol.WS:\n                return age > PeerAddressBook.MAX_AGE_WEBSOCKET;\n\n            case Protocol.RTC:\n                return age > PeerAddressBook.MAX_AGE_WEBRTC;\n\n            case Protocol.DUMB:\n                return age > PeerAddressBook.MAX_AGE_DUMB;\n        }\n        return false;\n    }\n\n}\n\nClass.register(PeerAddress);\n\nclass WsPeerAddress extends PeerAddress {\n    /**\n     * @param {string} host\n     * @param {number} port\n     * @param {string} [publicKeyHex]\n     * @returns {WsPeerAddress}\n     */\n    static seed(host, port, publicKeyHex) {\n        const publicKey = publicKeyHex ? new PublicKey(BufferUtils.fromHex(publicKeyHex)) : null;\n        return new WsPeerAddress(Services.FULL, /*timestamp*/ 0, NetAddress.UNSPECIFIED, publicKey, 0, host, port);\n    }\n\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {string} host\n     * @param {number} port\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, host, port, signature) {\n        super(Protocol.WS, services, timestamp, netAddress, publicKey, distance, signature);\n        if (!host) throw new Error('Malformed host');\n        if (!NumberUtils.isUint16(port)) throw new Error('Malformed port');\n        this._host = host;\n        this._port = port;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {WsPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        const host = buf.readVarLengthString();\n        const port = buf.readUint16();\n        return new WsPeerAddress(services, timestamp, netAddress, publicKey, distance, host, port, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        super.serializeContent(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    globallyReachable() {\n        return NetUtils.hostGloballyReachable(this.host);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return super.serializedContentSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof WsPeerAddress\n            && ((!!this.peerId && !!o.peerId) || (this._host === o.host && this._port === o.port));\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerId\n            ? `wss:///${this.peerId}`\n            : `wss://${this._host}:${this._port}/`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `wss://${this._host}:${this._port}/${this.peerId ? this.peerId : ''}`;\n    }\n\n    /**\n     * @returns {WsPeerAddress}\n     */\n    withoutId() {\n        return new WsPeerAddress(this.services, this.timestamp, this.netAddress, null, this.distance, this.host, this.port);\n    }\n\n    /** @type {string} */\n    get host() {\n        return this._host;\n    }\n\n    /** @type {number} */\n    get port() {\n        return this._port;\n    }\n}\n\nClass.register(WsPeerAddress);\n\nclass RtcPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.RTC, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RtcPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new RtcPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof RtcPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `rtc:///${this.peerId}`;\n    }\n}\n\nClass.register(RtcPeerAddress);\n\nclass DumbPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.DUMB, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {DumbPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new DumbPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof DumbPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `dumb:///${this.peerId}`;\n    }\n}\n\nClass.register(DumbPeerAddress);\n","class PeerAddressState {\n    /**\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {number} */\n        this.state = PeerAddressState.NEW;\n        /** @type {number} */\n        this.lastConnected = -1;\n        /** @type {number} */\n        this.bannedUntil = -1;\n        /** @type {number} */\n        this.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        /** @type {SignalRouter} */\n        this._signalRouter = new SignalRouter(peerAddress);\n\n        /** @type {number} */\n        this._failedAttempts = 0;\n\n        /**\n         * Map from closeType to number of occurrences\n         * @type {Map.<number,number>}\n         * @private\n         */\n        this._closeTypes = new Map();\n    }\n\n    /** @type {SignalRouter} */\n    get signalRouter() {\n        return this._signalRouter;\n    }\n\n\n    /** @type {number} */\n    get maxFailedAttempts() {\n        switch (this.peerAddress.protocol) {\n            case Protocol.RTC:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC;\n            case Protocol.WS:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_WS;\n            default:\n                return 0;\n        }\n    }\n\n    /** @type {number} */\n    get failedAttempts() {\n        if (this._signalRouter.bestRoute) {\n            return this._signalRouter.bestRoute.failedAttempts;\n        } else {\n            return this._failedAttempts;\n        }\n    }\n\n    /** @type {number} */\n    set failedAttempts(value) {\n        if (this._signalRouter.bestRoute) {\n            this._signalRouter.bestRoute.failedAttempts = value;\n            this._signalRouter.updateBestRoute(); // scores may have changed\n        } else {\n            this._failedAttempts = value;\n        }\n    }\n\n    /**\n     * @param {number} type\n     */\n    close(type) {\n        if (!type) return;\n\n        if (this._closeTypes.has(type)) {\n            this._closeTypes.set(type, this._closeTypes.get(type) + 1);\n        } else {\n            this._closeTypes.set(type, 1);\n        }\n\n        if (this.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        if (CloseType.isBanningType(type)) {\n            this.state = PeerAddressState.BANNED;\n        } else if (CloseType.isFailingType(type)) {\n            this.state = PeerAddressState.FAILED;\n        } else {\n            this.state = PeerAddressState.TRIED;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n}\nPeerAddressState.NEW = 1;\nPeerAddressState.ESTABLISHED = 2;\nPeerAddressState.TRIED = 3;\nPeerAddressState.FAILED = 4;\nPeerAddressState.BANNED = 5;\nClass.register(PeerAddressState);\n\nclass SignalRouter {\n    /**\n     * @constructor\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {SignalRoute} */\n        this._bestRoute = null;\n        /** @type {HashSet.<SignalRoute>} */\n        this._routes = new HashSet();\n    }\n\n    /** @type {SignalRoute} */\n    get bestRoute() {\n        return this._bestRoute;\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     * @returns {void}\n     */\n    addRoute(signalChannel, distance, timestamp) {\n        const oldRoute = this._routes.get(signalChannel);\n        const newRoute = new SignalRoute(signalChannel, distance, timestamp);\n\n        if (oldRoute) {\n            // Do not reset failed attempts.\n            newRoute.failedAttempts = oldRoute.failedAttempts;\n        }\n        this._routes.add(newRoute);\n\n        if (!this._bestRoute || newRoute.score > this._bestRoute.score\n            || (newRoute.score === this._bestRoute.score && timestamp > this._bestRoute.timestamp)) {\n\n            this._bestRoute = newRoute;\n            this.peerAddress.distance = this._bestRoute.distance;\n        }\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteBestRoute() {\n        if (this._bestRoute) {\n            this.deleteRoute(this._bestRoute.signalChannel);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @returns {void}\n     */\n    deleteRoute(signalChannel) {\n        this._routes.remove(signalChannel); // maps to same hashCode\n        if (this._bestRoute && this._bestRoute.signalChannel.equals(signalChannel)) {\n            this.updateBestRoute();\n        }\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteAllRoutes() {\n        this._bestRoute = null;\n        this._routes = new HashSet();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasRoute() {\n        return this._routes.length > 0;\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    updateBestRoute() {\n        let bestRoute = null;\n        // Choose the route with minimal distance and maximal timestamp.\n        for (const route of this._routes.values()) {\n            if (bestRoute === null || route.score > bestRoute.score\n                || (route.score === bestRoute.score && route.timestamp > bestRoute.timestamp)) {\n\n                bestRoute = route;\n            }\n        }\n        this._bestRoute = bestRoute;\n        if (this._bestRoute) {\n            this.peerAddress.distance = this._bestRoute.distance;\n        } else {\n            this.peerAddress.distance = PeerAddressBook.MAX_DISTANCE + 1;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n}\nClass.register(SignalRouter);\n\nclass SignalRoute {\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     */\n    constructor(signalChannel, distance, timestamp) {\n        this.failedAttempts = 0;\n        this.timestamp = timestamp;\n        this._signalChannel = signalChannel;\n        this._distance = distance;\n    }\n\n    /** @type {PeerChannel} */\n    get signalChannel() {\n        return this._signalChannel;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {number} */\n    get score() {\n        return ((PeerAddressBook.MAX_DISTANCE - this._distance) / 2) * (1 - (this.failedAttempts / PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC));\n    }\n\n    /**\n     * @param {SignalRoute} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof SignalRoute\n            && this._signalChannel.equals(o._signalChannel);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._signalChannel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `SignalRoute{signalChannel=${this._signalChannel}, distance=${this._distance}, timestamp=${this.timestamp}, failedAttempts=${this.failedAttempts}}`;\n    }\n}\nClass.register(SignalRoute);\n","class PeerAddressBook extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} netconfig\n     */\n    constructor(netconfig) {\n        super();\n\n        /**\n         * Set of PeerAddressStates of all peerAddresses we know.\n         * @type {HashSet.<PeerAddressState>}\n         * @private\n         */\n        this._store = new HashSet();\n\n        /**\n         * Map from peerIds to RTC peerAddresses.\n         * @type {HashMap.<PeerId,PeerAddressState>}\n         * @private\n         */\n        this._peerIds = new HashMap();\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = netconfig;\n\n\n        // Init seed peers.\n        this.add(/*channel*/ null, PeerAddressBook.SEED_PEERS);\n\n        // Setup housekeeping interval.\n        setInterval(() => this._housekeeping(), PeerAddressBook.HOUSEKEEPING_INTERVAL);\n    }\n\n    /**\n     * @returns {Array<PeerAddressState>}\n     */\n    values() {\n        return this._store.values();\n    }\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     * @private\n     */\n    _get(peerAddress) {\n        if (peerAddress instanceof WsPeerAddress) {\n            const localPeerAddress = this._store.get(peerAddress.withoutId());\n            if (localPeerAddress) return localPeerAddress;\n        }\n        return this._store.get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     */\n    getState(peerAddress) {\n        return this._get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerAddress|null}\n     */\n    get(peerAddress) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerAddress|null}\n     */\n    getByPeerId(peerId) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._peerIds.get(peerId);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerChannel}\n     */\n    getChannelByPeerId(peerId) {\n        const peerAddressState = this._peerIds.get(peerId);\n        if (peerAddressState && peerAddressState.signalRouter.bestRoute) {\n            return peerAddressState.signalRouter.bestRoute.signalChannel;\n        }\n        return null;\n    }\n\n    /**\n     * @todo improve this by returning the best addresses first.\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @param {number} maxAddresses\n     * @returns {Array.<PeerAddress>}\n     */\n    query(protocolMask, serviceMask, maxAddresses = 1000) {\n        // XXX inefficient linear scan\n        const now = Date.now();\n        const addresses = [];\n        for (const peerAddressState of this._store.values()) {\n            // Never return banned or failed addresses.\n            if (peerAddressState.state === PeerAddressState.BANNED\n                    || peerAddressState.state === PeerAddressState.FAILED) {\n                continue;\n            }\n\n            // Never return seed peers.\n            const address = peerAddressState.peerAddress;\n            if (address.isSeed()) {\n                continue;\n            }\n\n            // Only return addresses matching the protocol mask.\n            if ((address.protocol & protocolMask) === 0) {\n                continue;\n            }\n\n            // Only return addresses matching the service mask.\n            if ((address.services & serviceMask) === 0) {\n                continue;\n            }\n\n            // Update timestamp for connected peers.\n            if (peerAddressState.state === PeerAddressState.ESTABLISHED) {\n                // Also update timestamp for RTC connections\n                if (peerAddressState.signalRouter.bestRoute) {\n                    peerAddressState.signalRouter.bestRoute.timestamp = now;\n                }\n            }\n\n            // Never return addresses that are too old.\n            if (address.exceedsAge()) {\n                continue;\n            }\n\n            // Return this address.\n            addresses.push(address);\n\n            // Stop if we have collected maxAddresses.\n            if (addresses.length >= maxAddresses) {\n                break;\n            }\n        }\n        return addresses;\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|Array.<PeerAddress>} arg\n     * @fires PeerAddressBook#added\n     */\n    add(channel, arg) {\n        const peerAddresses = Array.isArray(arg) ? arg : [arg];\n        const newAddresses = [];\n\n        for (const addr of peerAddresses) {\n            if (this._add(channel, addr)) {\n                newAddresses.push(addr);\n            }\n        }\n\n        // Tell listeners that we learned new addresses.\n        if (newAddresses.length) {\n            this.fire('added', newAddresses, this);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {boolean}\n     * @private\n     */\n    _add(channel, peerAddress) {\n        // Max book size reached\n        if (this._store.length >= PeerAddressBook.MAX_SIZE) {\n            return false;\n        }\n\n        // Ignore our own address.\n        if (this._networkConfig.peerAddress.equals(peerAddress)) {\n            return false;\n        }\n\n        // Ignore address if it is too old.\n        // Special case: allow seed addresses (timestamp == 0) via null channel.\n        if (channel && peerAddress.exceedsAge()) {\n            Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - too old (${new Date(peerAddress.timestamp)})`);\n            return false;\n        }\n\n        // Ignore address if its timestamp is too far in the future.\n        if (peerAddress.timestamp > Date.now() + PeerAddressBook.MAX_TIMESTAMP_DRIFT) {\n            Log.d(PeerAddressBook, `Ignoring addresses ${peerAddress} - timestamp in the future`);\n            return false;\n        }\n\n        // Increment distance values of RTC addresses.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddress.distance++;\n\n            // Ignore address if it exceeds max distance.\n            if (peerAddress.distance > PeerAddressBook.MAX_DISTANCE) {\n                Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - max distance exceeded`);\n                // Drop any route to this peer over the current channel. This may prevent loops.\n                const peerAddressState = this._get(peerAddress);\n                if (peerAddressState) {\n                    peerAddressState.signalRouter.deleteRoute(channel);\n                }\n                return false;\n            }\n        }\n\n        // Check if we already know this address.\n        let peerAddressState = this._get(peerAddress);\n        if (peerAddressState) {\n            const knownAddress = peerAddressState.peerAddress;\n\n            // Ignore address if it is banned.\n            if (peerAddressState.state === PeerAddressState.BANNED) {\n                return false;\n            }\n\n            // Never update seed peers.\n            if (knownAddress.isSeed()) {\n                return false;\n            }\n\n            // Never erase NetAddresses.\n            if (knownAddress.netAddress && !peerAddress.netAddress) {\n                peerAddress.netAddress = knownAddress.netAddress;\n            }\n\n            // Ignore address if it is a websocket address and we already know this address with a more recent timestamp.\n            if (peerAddress.protocol === Protocol.WS && knownAddress.timestamp >= peerAddress.timestamp) {\n                return false;\n            }\n        } else {\n            // Add new peerAddressState.\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n            if (peerAddress.protocol === Protocol.RTC) {\n                // Index by peerId.\n                this._peerIds.put(peerAddress.peerId, peerAddressState);\n            }\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp);\n        }\n\n        // Update the address.\n        peerAddressState.peerAddress = peerAddress;\n\n        return true;\n    }\n\n    /**\n     * Called when a connection to this peerAddress has been established.\n     * The connection might have been initiated by the other peer, so address\n     * may not be known previously.\n     * If it is already known, it has been updated by a previous version message.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {void}\n     */\n    established(channel, peerAddress) {\n        let peerAddressState = this._get(peerAddress);\n        \n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n\n            if (peerAddress.protocol === Protocol.RTC) {\n                this._peerIds.put(peerAddress.peerId, peerAddressState);\n            }\n\n            this._store.add(peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.ESTABLISHED;\n        peerAddressState.lastConnected = Date.now();\n        peerAddressState.failedAttempts = 0;\n        peerAddressState.bannedUntil = -1;\n        peerAddressState.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        if (!peerAddressState.peerAddress.isSeed()) {\n            peerAddressState.peerAddress = peerAddress;\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp);\n        }\n    }\n\n    /**\n     * Called when a connection to this peerAddress is closed.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @param {number|null} type\n     * @returns {void}\n     */\n    close(channel, peerAddress, type = null) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // register the type of disconnection\n        peerAddressState.close(type);\n\n        // Delete all addresses that were signalable over the disconnected peer.\n        if (channel) {\n            this._removeBySignalChannel(channel);\n        }\n\n        if (CloseType.isBanningType(type)){\n            this._ban(peerAddress);\n        }\n        else if (CloseType.isFailingType(type)) {\n            peerAddressState.failedAttempts++;\n\n            if (peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts) {\n                // Remove address only if we have tried the maximum number of backoffs.\n                if (peerAddressState.banBackoff >= PeerAddressBook.MAX_FAILED_BACKOFF) {\n                    this._remove(peerAddress);\n                } else {\n                    peerAddressState.bannedUntil = Date.now() + peerAddressState.banBackoff;\n                    peerAddressState.banBackoff = Math.min(PeerAddressBook.MAX_FAILED_BACKOFF, peerAddressState.banBackoff * 2);\n                }\n            }\n        }\n\n        // Immediately delete dumb addresses, since we cannot connect to those anyway.\n        if (peerAddress.protocol === Protocol.DUMB) {\n            this._remove(peerAddress);\n        }\n    }\n\n    /**\n     * Called when a message has been returned as unroutable.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     */\n    unroutable(channel, peerAddress) {\n        if (!peerAddress) {\n            return;\n        }\n\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        if (!peerAddressState.signalRouter.bestRoute || !peerAddressState.signalRouter.bestRoute.signalChannel.equals(channel)) {\n            Log.w(PeerAddressBook, `Got unroutable for ${peerAddress} on a channel other than the best route.`);\n            return;\n        }\n\n        peerAddressState.signalRouter.deleteBestRoute();\n        if (!peerAddressState.signalRouter.hasRoute()) {\n            this._remove(peerAddressState.peerAddress);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {number} [duration] in milliseconds\n     * @returns {void}\n     * @private\n     */\n    _ban(peerAddress, duration = PeerAddressBook.DEFAULT_BAN_TIME) {\n        let peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.BANNED;\n        peerAddressState.bannedUntil = Date.now() + duration;\n\n        // Drop all routes to this peer.\n        peerAddressState.signalRouter.deleteAllRoutes();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isBanned(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState\n            && peerAddressState.state === PeerAddressState.BANNED\n            // XXX Never consider seed peers to be banned. This allows us to use\n            // the banning mechanism to prevent seed peers from being picked when\n            // they are down, but still allows recovering seed peers' inbound\n            // connections to succeed.\n            && !peerAddressState.peerAddress.isSeed();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     * @private\n     */\n    _remove(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // Never delete seed addresses, ban them instead for a couple of minutes.\n        if (peerAddressState.peerAddress.isSeed()) {\n            this._ban(peerAddress, peerAddressState.banBackoff);\n            return;\n        }\n\n        // Delete from peerId index.\n        if (peerAddress.protocol === Protocol.RTC) {\n            this._peerIds.remove(peerAddress.peerId);\n        }\n\n        // Don't delete bans.\n        if (peerAddressState.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        // Delete the address.\n        this._store.remove(peerAddress);\n    }\n\n    /**\n     * Delete all RTC-only routes that are signalable over the given peer.\n     * @param {PeerChannel} channel\n     * @returns {void}\n     * @private\n     */\n    _removeBySignalChannel(channel) {\n        // XXX inefficient linear scan\n        for (const peerAddressState of this._store.values()) {\n            if (peerAddressState.peerAddress.protocol === Protocol.RTC) {\n                peerAddressState.signalRouter.deleteRoute(channel);\n                if (!peerAddressState.signalRouter.hasRoute()) {\n                    this._remove(peerAddressState.peerAddress);\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        const now = Date.now();\n        const unbannedAddresses = [];\n\n        for (/** @type {PeerAddressState} */ const peerAddressState of this._store.values()) {\n            const addr = peerAddressState.peerAddress;\n\n            switch (peerAddressState.state) {\n                case PeerAddressState.NEW:\n                case PeerAddressState.TRIED:\n                case PeerAddressState.FAILED:\n                    // Delete all new peer addresses that are older than MAX_AGE.\n                    if (addr.exceedsAge()) {\n                        Log.d(PeerAddressBook, `Deleting old peer address ${addr}`);\n                        this._remove(addr);\n                    }\n\n                    // Reset failed attempts after bannedUntil has expired.\n                    if (peerAddressState.state === PeerAddressState.FAILED\n                        && peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts\n                        && peerAddressState.bannedUntil > 0 && peerAddressState.bannedUntil <= now) {\n\n                        peerAddressState.bannedUntil = -1;\n                        peerAddressState.failedAttempts = 0;\n                        unbannedAddresses.push(addr);\n                    }\n\n                    break;\n\n                case PeerAddressState.BANNED:\n                    if (peerAddressState.bannedUntil <= now) {\n                        // Don't remove seed addresses, unban them.\n                        if (addr.isSeed()) {\n                            // Restore banned seed addresses to the NEW state.\n                            peerAddressState.state = PeerAddressState.NEW;\n                            peerAddressState.failedAttempts = 0;\n                            peerAddressState.bannedUntil = -1;\n                            unbannedAddresses.push(addr);\n                        } else {\n                            // Delete expires bans.\n                            this._store.remove(addr);\n                        }\n                    }\n                    break;\n\n                case PeerAddressState.ESTABLISHED:\n                    // Also update timestamp for RTC connections\n                    if (peerAddressState.signalRouter.bestRoute) {\n                        peerAddressState.signalRouter.bestRoute.timestamp = now;\n                    }\n                    break;\n\n                default:\n                    // TODO What about peers who are stuck connecting? Can this happen?\n                    // Do nothing for CONNECTING peers.\n            }\n        }\n\n        if (unbannedAddresses.length) {\n            this.fire('added', unbannedAddresses, this);\n        }\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._store.length;\n    }\n}\nPeerAddressBook.MAX_AGE_WEBSOCKET = 1000 * 60 * 30; // 30 minutes\nPeerAddressBook.MAX_AGE_WEBRTC = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_AGE_DUMB = 1000 * 60; // 1 minute\nPeerAddressBook.MAX_DISTANCE = 4;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_WS = 3;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_RTC = 2;\nPeerAddressBook.MAX_TIMESTAMP_DRIFT = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.HOUSEKEEPING_INTERVAL = 1000 * 60; // 1 minute\nPeerAddressBook.DEFAULT_BAN_TIME = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.INITIAL_FAILED_BACKOFF = 1000 * 30; // 30 seconds\nPeerAddressBook.MAX_FAILED_BACKOFF = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_SIZE = PlatformUtils.isBrowser() ? 10000 : 200000;\nPeerAddressBook.SEED_PEERS = [\n    // WsPeerAddress.seed('alpacash.com', 8080),\n    // WsPeerAddress.seed('nimiq1.styp-rekowsky.de', 8080),\n    // WsPeerAddress.seed('nimiq2.styp-rekowsky.de', 8080),\n    // WsPeerAddress.seed('seed1.nimiq-network.com', 8080),\n    // WsPeerAddress.seed('seed2.nimiq-network.com', 8080),\n    // WsPeerAddress.seed('seed3.nimiq-network.com', 8080),\n    // WsPeerAddress.seed('seed4.nimiq-network.com', 8080),\n    // WsPeerAddress.seed('emily.nimiq-network.com', 443)\n    WsPeerAddress.seed('dev.nimiq-network.com', 8080, 'e65e39616662f2c16d62dc08915e5a1d104619db8c2b9cf9b389f96c8dce9837')\n];\nClass.register(PeerAddressBook);\n","class CloseType {\n    /**\n     * @param {number} closingType\n     * @return {boolean}\n     */\n    static isBanningType(closingType){\n        return closingType >= 100 && closingType < 200;\n    }\n\n    /**\n     * @param {number} closingType\n     * @return {boolean}\n     */\n    static isFailingType(closingType){\n        return closingType >= 200;\n    }\n}\n\n// Regular Close Types\n\nCloseType.GET_BLOCKS_TIMEOUT = 1;\nCloseType.GET_CHAIN_PROOF_TIMEOUT = 2;\nCloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT = 3;\nCloseType.GET_HEADER_TIMEOUT = 4;\nCloseType.INVALID_ACCOUNTS_TREE_CHUNK = 5;\nCloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH = 6;\nCloseType.INVALID_CHAIN_PROOF = 7;\nCloseType.RECEIVED_WRONG_HEADER = 8;\nCloseType.DID_NOT_GET_REQUESTED_HEADER = 9;\nCloseType.ABORTED_SYNC = 10;\n\nCloseType.GET_ACCOUNTS_PROOF_TIMEOUT = 11;\nCloseType.GET_TRANSACTIONS_PROOF_TIMEOUT = 12;\nCloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT = 13;\nCloseType.INVALID_ACCOUNTS_PROOF = 14;\nCloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH = 15;\nCloseType.INCOMPLETE_ACCOUNTS_PROOF = 16;\nCloseType.INVALID_BLOCK = 17;\nCloseType.INVALID_CHAIN_PROOF = 18;\nCloseType.INVALID_TRANSACTION_PROOF = 19;\n\nCloseType.SENDING_PING_MESSAGE_FAILED = 22;\nCloseType.SENDING_OF_VERSION_MESSAGE_FAILED = 29;\n\nCloseType.DUPLICATE_CONNECTION = 30;\nCloseType.PEER_IS_BANNED = 31;\nCloseType.CONNECTION_LIMIT_PER_IP = 32;\nCloseType.MANUAL_NETWORK_DISCONNECT  = 33;\nCloseType.MANUAL_WEBSOCKET_DISCONNECT  = 34;\nCloseType.MAX_PEER_COUNT_REACHED  = 35;\n\nCloseType.PEER_CONNECTION_RECYCLED  = 36;\nCloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE  = 37;\n\n// Ban Close Types\n\nCloseType.RECEIVED_INVALID_BLOCK = 100;\nCloseType.BLOCKCHAIN_SYNC_FAILED = 101;\nCloseType.RECEIVED_INVALID_HEADER = 102;\nCloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION = 103;\nCloseType.ADDR_MESSAGE_TOO_LARGE = 104;\nCloseType.INVALID_ADDR = 105;\nCloseType.ADDR_NOT_GLOBALLY_REACHABLE = 106;\nCloseType.INVALID_SIGNAL_TTL = 107;\nCloseType.INVALID_SIGNATURE = 108;\nCloseType.INCOMPATIBLE_VERSION = 109;\nCloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE = 110;\nCloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE  = 111;\nCloseType.DIFFERENT_GENESIS_BLOCK = 112;\nCloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE = 113;\nCloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE = 114;\n\n// Fail Close Types\n\nCloseType.CLOSED_BY_REMOTE = 200;\nCloseType.PING_TIMEOUT = 201;\nCloseType.CONNECTION_FAILED = 202;\nCloseType.NETWORK_ERROR = 203;\nCloseType.VERSION_TIMEOUT = 204;\nCloseType.VERACK_TIMEOUT = 205;\n\nClass.register(CloseType);\n","class NetworkConnection extends Observable {\n    /**\n     * @param {DataChannel} channel\n     * @param {number} protocol\n     * @param {NetAddress} netAddress\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(channel, protocol, netAddress, peerAddress) {\n        super();\n        /** @type {DataChannel} */\n        this._channel = channel;\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {boolean} */\n        this._inbound = !peerAddress;\n\n        /** @type {boolean} */\n        this._closed = false;\n\n        /** @type {*} */\n        this._lastError = null;\n\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = NetworkConnection._instanceCount++;\n\n        this._channel.on('message', msg => this._onMessage(msg));\n        this._channel.on('close', () => this._onClose(CloseType.CLOSED_BY_REMOTE, 'Closed by remote'));\n        this._channel.on('error', e => this._onError(e));\n    }\n\n    _onMessage(msg) {\n        // Don't emit messages if this channel is closed.\n        if (this._closed) {\n            return;\n        }\n\n        this._bytesReceived += msg.byteLength || msg.length;\n        this.fire('message', msg, this);\n    }\n\n    /**\n     * @param {*} e\n     * @private\n     */\n    _onError(e) {\n        this._lastError = e;\n        this.fire('error', e, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _onClose(type, reason) {\n        // Don't fire close event again when already closed.\n        if (this._closed) {\n            return;\n        }\n\n        // Mark this connection as closed.\n        this._closed = true;\n\n        // Propagate last network error.\n        if (type === CloseType.CLOSED_BY_REMOTE && this._lastError) {\n            type = CloseType.NETWORK_ERROR;\n            reason = this._lastError;\n        }\n\n        // Tell listeners that this connection has closed.\n        this.fire('close', type, reason, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _close(type, reason) {\n        // Don't wait for the native close event to fire.\n        this._onClose(type, reason);\n\n        // Close the native channel.\n        this._channel.close();\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelOpen() {\n        return this._channel.readyState === DataChannel.ReadyState.OPEN;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosing() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSING;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosed() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSED;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @return {boolean}\n     */\n    send(msg) {\n        const logAddress = this._peerAddress || this._netAddress;\n        if (this._closed) {\n            return false;\n        }\n\n        // Fire close event (early) if channel is closing/closed.\n        if (this._isChannelClosing() || this._isChannelClosed()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel closing/closed (${this._channel.readyState})`);\n            this._onClose();\n            return false;\n        }\n\n        // Don't attempt to send if channel is not (yet) open.\n        if (!this._isChannelOpen()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel not open (${this._channel.readyState})`);\n            return false;\n        }\n\n        try {\n            this._channel.send(msg);\n            this._bytesSent += msg.byteLength || msg.length;\n            return true;\n        } catch (e) {\n            Log.e(NetworkConnection, `Failed to send data to ${logAddress}: ${e.message || e}`);\n            return false;\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._channel.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._channel.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        const connType = this._inbound ? 'inbound' : 'outbound';\n        Log.d(NetworkConnection, `Closing ${connType} connection #${this._id} ${this._peerAddress || this._netAddress}` + (reason ? ` - ${reason}` : '') + ` (${type})`);\n        this._close(type, reason);\n    }\n\n    /**\n     * @param {NetworkConnection} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetworkConnection\n            && this._id === o.id;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._id.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `NetworkConnection{id=${this._id}, protocol=${this._protocol}, peerAddress=${this._peerAddress}, netAddress=${this._netAddress}}`;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived;\n    }\n\n    /** @type {boolean} */\n    get inbound() {\n        return this._inbound;\n    }\n\n    /** @type {boolean} */\n    get outbound() {\n        return !this._inbound;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._closed;\n    }\n}\n// Used to generate unique NetworkConnection ids.\nNetworkConnection._instanceCount = 0;\nClass.register(NetworkConnection);\n","class PeerChannel extends Observable {\n    /**\n     * @listens NetworkConnection#message\n     * @param {NetworkConnection} connection\n     */\n    constructor(connection) {\n        super();\n        this._conn = connection;\n        this._conn.on('message', msg => this._onMessage(msg));\n\n        // Forward specified events on the connection to listeners of this Observable.\n        this.bubble(this._conn, 'close', 'error');\n    }\n\n    /**\n     * @param {Uint8Array} rawMsg\n     * @private\n     */\n    _onMessage(rawMsg) {\n        let msg = null, type = null;\n\n        try {\n            const buf = new SerialBuffer(rawMsg);\n            type = MessageFactory.peekType(buf);\n            msg = MessageFactory.parse(buf);\n        } catch(e) {\n            Log.w(PeerChannel, `Failed to parse message from ${this.peerAddress || this.netAddress}`, e.message || e);\n\n            // From the Bitcoin Reference:\n            //  \"Be careful of reject message feedback loops where two peers\n            //   each don’t understand each other’s reject messages and so keep\n            //   sending them back and forth forever.\"\n\n            // If the message does not make sense at a whole or we fear to get into a reject loop,\n            // we ban the peer instead.\n            if (!type || type === Message.Type.REJECT) {\n                this.close(CloseType.FAILED_TO_PARSE_MESSAGE_TYPE, 'Failed to parse message type');\n                return;\n            }\n\n            // Otherwise inform other node and ignore message.\n            this.reject(type, RejectMessage.Code.REJECT_MALFORMED, e.message || e);\n            return;\n        }\n\n        if (!msg) return;\n\n        try {\n            this.fire(PeerChannel.Event[msg.type], msg, this);\n            this.fire('message-log', msg, this);\n        } catch (e) {\n            Log.w(PeerChannel, `Error while processing ${msg.type} message from ${this.peerAddress || this.netAddress}: ${e}`);\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._conn.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._conn.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _send(msg) {\n        return this._conn.send(msg.serialize());\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        this._conn.close(type, reason);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     * @return {boolean}\n     */\n    version(peerAddress, headHash, challengeNonce) {\n        return this._send(new VersionMessage(Version.CODE, peerAddress, Block.GENESIS.HASH, headHash, challengeNonce));\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verack(publicKey, signature) {\n        return this._send(new VerAckMessage(publicKey, signature));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    inv(vectors) {\n        return this._send(new InvMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    notFound(vectors) {\n        return this._send(new NotFoundMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getData(vectors) {\n        return this._send(new GetDataMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getHeader(vectors) {\n        return this._send(new GetHeaderMessage(vectors));\n    }\n\n    /**\n     * @param {Block} block\n     * @return {boolean}\n     */\n    block(block) {\n        return this._send(new BlockMessage(block));\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @return {boolean}\n     */\n    header(header) {\n        return this._send(new HeaderMessage(header));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     * @return {boolean}\n     */\n    tx(transaction, accountsProof) {\n        return this._send(new TxMessage(transaction, accountsProof));\n    }\n\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {boolean} [ascending]\n     * @return {boolean}\n     */\n    getBlocks(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, ascending=true) {\n        return this._send(new GetBlocksMessage(locators, maxInvSize, ascending ? GetBlocksMessage.Direction.FORWARD : GetBlocksMessage.Direction.BACKWARD));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    mempool() {\n        return this._send(new MempoolMessage());\n    }\n\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     * @return {boolean}\n     */\n    reject(messageType, code, reason, extraData) {\n        return this._send(new RejectMessage(messageType, code, reason, extraData));\n    }\n\n    /**\n     * @param {Subscription} subscription\n     * @returns {boolean}\n     */\n    subscribe(subscription) {\n        return this._send(new SubscribeMessage(subscription));\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @return {boolean}\n     */\n    addr(addresses) {\n        return this._send(new AddrMessage(addresses));\n    }\n\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @return {boolean}\n     */\n    getAddr(protocolMask, serviceMask) {\n        return this._send(new GetAddrMessage(protocolMask, serviceMask));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    ping(nonce) {\n        return this._send(new PingMessage(nonce));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    pong(nonce) {\n        return this._send(new PongMessage(nonce));\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     * @return {boolean}\n     */\n    signal(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature) {\n        return this._send(new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getAccountsProof(blockHash, addresses) {\n        return this._send(new GetAccountsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [proof]\n     * @return {boolean}\n     */\n    accountsProof(blockHash, proof) {\n        return this._send(new AccountsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    getChainProof() {\n        return this._send(new GetChainProofMessage());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @return {boolean}\n     */\n    chainProof(proof) {\n        return this._send(new ChainProofMessage(proof));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @return {boolean}\n     */\n    getAccountsTreeChunk(blockHash, startPrefix) {\n        return this._send(new GetAccountsTreeChunkMessage(blockHash, startPrefix));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [chunk]\n     * @return {boolean}\n     */\n    accountsTreeChunk(blockHash, chunk) {\n        return this._send(new AccountsTreeChunkMessage(blockHash, chunk));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getTransactionsProof(blockHash, addresses) {\n        return this._send(new GetTransactionsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     * @return {boolean}\n     */\n    transactionsProof(blockHash, proof) {\n        return this._send(new TransactionsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {boolean}\n     */\n    getTransactionReceipts(address) {\n        return this._send(new GetTransactionReceiptsMessage(address));\n    }\n\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     * @returns {boolean}\n     */\n    transactionReceipts(transactionReceipts) {\n        return this._send(new TransactionReceiptsMessage(transactionReceipts));\n    }\n\n    /**\n     * @param {PeerChannel} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerChannel\n            && this._conn.equals(o.connection);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._conn.hashCode();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `PeerChannel{conn=${this._conn}}`;\n    }\n\n    /** @type {NetworkConnection} */\n    get connection() {\n        return this._conn;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._conn.id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._conn.protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._conn.peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._conn.peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._conn.netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._conn.netAddress = value;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._conn.closed;\n    }\n}\nClass.register(PeerChannel);\n\nPeerChannel.Event = {};\nPeerChannel.Event[Message.Type.VERSION] = 'version';\nPeerChannel.Event[Message.Type.INV] = 'inv';\nPeerChannel.Event[Message.Type.GET_DATA] = 'get-data';\nPeerChannel.Event[Message.Type.GET_HEADER] = 'get-header';\nPeerChannel.Event[Message.Type.NOT_FOUND] = 'not-found';\nPeerChannel.Event[Message.Type.GET_BLOCKS] = 'get-blocks';\nPeerChannel.Event[Message.Type.BLOCK] = 'block';\nPeerChannel.Event[Message.Type.HEADER] = 'header';\nPeerChannel.Event[Message.Type.TX] = 'tx';\nPeerChannel.Event[Message.Type.MEMPOOL] = 'mempool';\nPeerChannel.Event[Message.Type.REJECT] = 'reject';\nPeerChannel.Event[Message.Type.SUBSCRIBE] = 'subscribe';\nPeerChannel.Event[Message.Type.ADDR] = 'addr';\nPeerChannel.Event[Message.Type.GET_ADDR] = 'get-addr';\nPeerChannel.Event[Message.Type.PING] = 'ping';\nPeerChannel.Event[Message.Type.PONG] = 'pong';\nPeerChannel.Event[Message.Type.SIGNAL] = 'signal';\nPeerChannel.Event[Message.Type.GET_CHAIN_PROOF] = 'get-chain-proof';\nPeerChannel.Event[Message.Type.CHAIN_PROOF] = 'chain-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_PROOF] = 'get-accounts-proof';\nPeerChannel.Event[Message.Type.ACCOUNTS_PROOF] = 'accounts-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = 'get-accounts-tree-chunk';\nPeerChannel.Event[Message.Type.ACCOUNTS_TREE_CHUNK] = 'accounts-tree-chunk';\nPeerChannel.Event[Message.Type.GET_TRANSACTIONS_PROOF] = 'get-transactions-proof';\nPeerChannel.Event[Message.Type.TRANSACTIONS_PROOF] = 'transactions-proof';\nPeerChannel.Event[Message.Type.GET_TRANSACTION_RECEIPTS] = 'get-transaction-receipts';\nPeerChannel.Event[Message.Type.TRANSACTION_RECEIPTS] = 'transaction-receipts';\nPeerChannel.Event[Message.Type.VERACK] = 'verack';\n","class NetworkAgent extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {PeerAddressBook} addresses\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} channel\n     *\n     * @listens PeerChannel#version\n     * @listens PeerChannel#verack\n     * @listens PeerChannel#addr\n     * @listens PeerChannel#getAddr\n     * @listens PeerChannel#ping\n     * @listens PeerChannel#pong\n     * @listens PeerChannel#close\n     */\n    constructor(blockchain, addresses, networkConfig, channel) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {PeerAddressBook} */\n        this._addresses = addresses;\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._channel = channel;\n\n        /**\n         * The peer object we create after the handshake completes.\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        /**\n         * All peerAddresses that we think the remote peer knows.\n         * @type {HashSet.<PeerAddress>}\n         * @private\n         */\n        this._knownAddresses = new HashSet();\n\n        /**\n         * Helper object to keep track of timeouts & intervals.\n         * @type {Timers}\n         * @private\n         */\n        this._timers = new Timers();\n\n        /**\n         * True if we have received the peer's version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionReceived = false;\n\n        /**\n         * True if we have received the peer's verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackReceived = false;\n\n        /**\n         * True if we have successfully sent our version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionSent = false;\n\n        /**\n         * True if we have successfully sent our verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackSent = false;\n\n        /**\n         * Number of times we have tried to send out the version message.\n         * @type {number}\n         * @private\n         */\n        this._versionAttempts = 0;\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._peerAddressVerified = false;\n\n        /**\n         * @type {Uint8Array}\n         * @private\n         */\n        this._peerChallengeNonce = null;\n\n        /**\n         * @type {Map.<number, number>}\n         * @private\n         */\n        this._pingTimes = new Map();\n\n        /** @type {Uint8Array} */\n        this._challengeNonce = new Uint8Array(VersionMessage.CHALLENGE_SIZE);\n        Crypto.lib.getRandomValues(this._challengeNonce);\n\n        // Listen to network/control messages from the peer.\n        channel.on('version', msg => this._onVersion(msg));\n        channel.on('verack', msg => this._onVerAck(msg));\n        channel.on('addr', msg => this._onAddr(msg));\n        channel.on('get-addr', msg => this._onGetAddr(msg));\n        channel.on('ping', msg => this._onPing(msg));\n        channel.on('pong', msg => this._onPong(msg));\n\n        // Clean up when the peer disconnects.\n        channel.on('close', () => this._onClose());\n    }\n\n    /**\n     * @param {Array.<PeerAddress|RtcPeerAddress>} addresses\n     */\n    relayAddresses(addresses) {\n        // Don't relay if the handshake hasn't finished yet.\n        if (!this._versionReceived || !this._versionSent) {\n            return;\n        }\n\n        // Only relay addresses that the peer doesn't know yet. If the address\n        // the peer knows is older than RELAY_THROTTLE, relay the address again.\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude DumbPeerAddresses.\n            if (addr.protocol === Protocol.DUMB) {\n                return false;\n            }\n\n            const knownAddress = this._knownAddresses.get(addr);\n            return !addr.isSeed() // Never relay seed addresses.\n                && (!knownAddress || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE);\n        });\n\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n\n            // We assume that the peer knows these addresses now.\n            for (const address of filteredAddresses) {\n                this._knownAddresses.add(address);\n            }\n        }\n    }\n\n\n    /* Handshake */\n\n    handshake() {\n        if (this._versionSent) {\n            // Version already sent, no need to handshake again.\n            return;\n        }\n\n        // Kick off the handshake by telling the peer our version, network address & blockchain head hash.\n        // Firefox sends the data-channel-open event too early, so sending the version message might fail.\n        // Try again in this case.\n        if (!this._channel.version(this._networkConfig.peerAddress, this._blockchain.headHash, this._challengeNonce)) {\n            this._versionAttempts++;\n            if (this._versionAttempts >= NetworkAgent.VERSION_ATTEMPTS_MAX) {\n                this._channel.close(CloseType.SENDING_OF_VERSION_MESSAGE_FAILED, 'sending of version message failed');\n                return;\n            }\n\n            setTimeout(this.handshake.bind(this), NetworkAgent.VERSION_RETRY_DELAY);\n            return;\n        }\n\n        this._versionSent = true;\n\n        // Drop the peer if it doesn't send us a version message.\n        // Only do this if we haven't received the peer's version message already.\n        if (!this._versionReceived) {\n            // TODO Should we ban instead?\n            this._timers.setTimeout('version', () => {\n                this._timers.clearTimeout('version');\n                this._channel.close(CloseType.VERSION_TIMEOUT, 'version timeout');\n            }, NetworkAgent.HANDSHAKE_TIMEOUT);\n        } else if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        this._timers.setTimeout('verack', () => {\n            this._timers.clearTimeout('verack');\n            this._channel.close(CloseType.VERACK_TIMEOUT, 'verack timeout');\n        }, NetworkAgent.HANDSHAKE_TIMEOUT);\n    }\n\n    /**\n     * @param {VersionMessage} msg\n     * @private\n     */\n    _onVersion(msg) {\n        Log.d(NetworkAgent, () => `[VERSION] ${msg.peerAddress} ${msg.headHash.toBase64()}`);\n\n        const now = Date.now();\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate version messages.\n        if (this._versionReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate version message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the version timeout.\n        this._timers.clearTimeout('version');\n\n        // Check if the peer is running a compatible version.\n        if (!Version.isCompatible(msg.version)) {\n            this._channel.reject(Message.Type.VERSION, RejectMessage.Code.REJECT_OBSOLETE, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            this._channel.close(CloseType.INCOMPATIBLE_VERSION, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            return;\n        }\n\n        // Check if the peer is working on the same genesis block.\n        if (!Block.GENESIS.HASH.equals(msg.genesisHash)) {\n            this._channel.close(CloseType.DIFFERENT_GENESIS_BLOCK, `different genesis block (${msg.genesisHash})`);\n            return;\n        }\n\n        // Check that the given peerAddress is correctly signed.\n        if (!msg.peerAddress.verifySignature()) {\n            this._channel.close(CloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE, 'invalid peerAddress in version message');\n            return;\n        }\n\n        // TODO check services?\n\n        // Check that the given peerAddress matches the one we expect.\n        // In case of inbound WebSocket connections, this is the first time we\n        // see the remote peer's peerAddress.\n        const peerAddress = msg.peerAddress;\n        if (this._channel.peerAddress) {\n            if (!this._channel.peerAddress.equals(peerAddress)) {\n                this._channel.close(CloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE, 'unexpected peerAddress in version message');\n                return;\n            }\n            this._peerAddressVerified = true;\n        }\n\n        // The client might not send its netAddress. Set it from our address database if we have it.\n        if (!peerAddress.netAddress || peerAddress.netAddress.isPseudo()) {\n            /** @type {PeerAddress} */\n            const storedAddress = this._addresses.get(peerAddress);\n            if (storedAddress && storedAddress.netAddress) {\n                peerAddress.netAddress = storedAddress.netAddress;\n            }\n        }\n\n        // Set/update the channel's peer address.\n        this._channel.peerAddress = peerAddress;\n\n        // Create peer object. Since the initial version message received from the\n        // peer contains their local timestamp, we can use it to calculate their\n        // offset to our local timestamp and store it for later (last argument).\n        this._peer = new Peer(\n            this._channel,\n            msg.version,\n            msg.headHash,\n            peerAddress.timestamp - now\n        );\n\n        this._peerChallengeNonce = msg.challengeNonce;\n        this._versionReceived = true;\n\n        // Tell listeners that we received this peer's version information.\n        // Listeners registered to this event might close the connection to this peer.\n        this.fire('version', this._peer, this);\n\n        // Abort handshake if the connection was closed.\n        if (this._channel.closed) {\n            return;\n        }\n\n        if (!this._versionSent) {\n            this.handshake();\n            return;\n        }\n\n        if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        if (this._verackReceived) {\n            this._finishHandshake();\n        }\n    }\n\n    _sendVerAck() {\n        Assert.that(this._peerAddressVerified);\n\n        const data = BufferUtils.concatTypedArrays(this._channel.peerAddress.peerId.serialize(), this._peerChallengeNonce);\n        const signature = Signature.create(this._networkConfig.keyPair.privateKey, this._networkConfig.keyPair.publicKey, data);\n        this._channel.verack(this._networkConfig.keyPair.publicKey, signature);\n\n        this._verackSent = true;\n    }\n\n    /**\n     * @param {VerAckMessage} msg\n     * @private\n     */\n    _onVerAck(msg) {\n        Log.d(NetworkAgent, () => `[VERACK] from ${this._channel.peerAddress}`);\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate verack messages.\n        if (this._verackReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate verack message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the verack timeout.\n        this._timers.clearTimeout('verack');\n\n        // Verify public key\n        if (!msg.publicKey.toPeerId().equals(this._channel.peerAddress.peerId)) {\n            this._channel.close(CloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE, 'Invalid public key in verack message');\n            return;\n        }\n\n        // Verify signature\n        const data = BufferUtils.concatTypedArrays(this._networkConfig.peerAddress.peerId.serialize(), this._challengeNonce);\n        if (!msg.signature.verify(msg.publicKey, data)) {\n            this._channel.close(CloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE, 'Invalid signature in verack message');\n            return;\n        }\n\n        if (!this._peerAddressVerified) {\n            this._peerAddressVerified = true;\n            this._sendVerAck();\n        }\n\n        // Remember that the peer has sent us this address.\n        this._knownAddresses.add(this._channel.peerAddress);\n\n        this._verackReceived = true;\n\n        if (this._verackSent) {\n            this._finishHandshake();\n        }\n    }\n\n    _finishHandshake() {\n        // Setup regular connectivity check.\n        // TODO randomize interval?\n        this._timers.setInterval('connectivity',\n            () => this._checkConnectivity(),\n            NetworkAgent.CONNECTIVITY_CHECK_INTERVAL);\n\n        // Regularly announce our address.\n        this._timers.setInterval('announce-addr',\n            () => this._channel.addr([this._networkConfig.peerAddress]),\n            NetworkAgent.ANNOUNCE_ADDR_INTERVAL);\n\n        // Tell listeners that the handshake with this peer succeeded.\n        this.fire('handshake', this._peer, this);\n\n        // Request new network addresses from the peer.\n        this._requestAddresses();\n    }\n\n\n    /* Addresses */\n\n    _requestAddresses() {\n        // Request addresses from peer.\n        this._channel.getAddr(this._networkConfig.protocolMask, this._networkConfig.services.accepted);\n\n        // We don't use a timeout here. The peer will not respond with an addr message if\n        // it doesn't have any new addresses.\n    }\n\n    /**\n     * @param {AddrMessage} msg\n     * @private\n     */\n    _onAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Reject messages that contain more than 1000 addresses, ban peer (bitcoin).\n        if (msg.addresses.length > 1000) {\n            Log.w(NetworkAgent, 'Rejecting addr message - too many addresses');\n            this._channel.close(CloseType.ADDR_MESSAGE_TOO_LARGE, 'addr message too large');\n            return;\n        }\n\n        // Remember that the peer has sent us these addresses.\n        for (const addr of msg.addresses) {\n            if (!addr.verifySignature()) {\n                this._channel.close(CloseType.INVALID_ADDR, 'invalid addr');\n                return;\n            }\n            if (addr.protocol === Protocol.WS && !addr.globallyReachable()) {\n                this._channel.close(CloseType.ADDR_NOT_GLOBALLY_REACHABLE, 'addr not globally reachable');\n                return;\n            }\n            this._knownAddresses.add(addr);\n        }\n\n        // Put the new addresses in the address pool.\n        this._addresses.add(this._channel, msg.addresses);\n\n        // Tell listeners that we have received new addresses.\n        this.fire('addr', msg.addresses, this);\n    }\n\n    /**\n     * @private\n     * @param {GetAddrMessage} msg\n     * @return {void}\n     */\n    _onGetAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Find addresses that match the given serviceMask.\n        const addresses = this._addresses.query(msg.protocolMask, msg.serviceMask);\n\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude known addresses from the response unless they are older than RELAY_THROTTLE.\n            const knownAddress = this._knownAddresses.get(addr);\n            return !knownAddress || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE;\n        });\n\n        // Send the addresses back to the peer.\n        // If we don't have any new addresses, don't send the message at all.\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n        }\n    }\n\n\n    /* Connectivity Check */\n\n    _checkConnectivity() {\n        // Generate random nonce.\n        const nonce = NumberUtils.randomUint32();\n\n        // Send ping message to peer.\n        // If sending the ping message fails, assume the connection has died.\n        if (!this._channel.ping(nonce)) {\n            this._channel.close(CloseType.SENDING_PING_MESSAGE_FAILED, 'sending ping message failed');\n            return;\n        }\n\n        // Save ping timestamp to detect the speed of the connection\n        this._pingTimes.set(nonce, Date.now());\n\n        // Drop peer if it doesn't answer with a matching pong message within the timeout.\n        this._timers.setTimeout(`ping_${nonce}`, () => {\n            this._timers.clearTimeout(`ping_${nonce}`);\n            this._channel.close(CloseType.PING_TIMEOUT, 'ping timeout');\n            this._pingTimes.delete(nonce);\n        }, NetworkAgent.PING_TIMEOUT);\n    }\n\n    /**\n     * @param {PingMessage} msg\n     * @private\n     */\n    _onPing(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Respond with a pong message\n        this._channel.pong(msg.nonce);\n    }\n\n    /**\n     * @param {PongMessage} msg\n     * @fires NetworkAgent#ping-pong\n     * @private\n     */\n    _onPong(msg) {\n        // Clear the ping timeout for this nonce.\n        this._timers.clearTimeout(`ping_${msg.nonce}`);\n\n        /** @type {number} */\n        const startTime = this._pingTimes.get(msg.nonce);\n        if (startTime) {\n            const delta = Date.now() - startTime;\n            if (delta > 0) {\n                this.fire('ping-pong', delta);\n            }\n            this._pingTimes.delete(msg.nonce);\n        }\n    }\n\n    /**\n     * @private\n     */\n    _onClose() {\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _canAcceptMessage(msg) {\n        // The first message must be the version message.\n        if (!this._versionReceived && msg.type !== Message.Type.VERSION) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no version message received previously');\n            return false;\n        }\n        if (this._versionReceived && !this._verackReceived && msg.type !== Message.Type.VERACK) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no verack message received previously');\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n}\n\nNetworkAgent.HANDSHAKE_TIMEOUT = 1000 * 4; // 4 seconds\nNetworkAgent.PING_TIMEOUT = 1000 * 10; // 10 seconds\nNetworkAgent.CONNECTIVITY_CHECK_INTERVAL = 1000 * 60; // 1 minute\nNetworkAgent.ANNOUNCE_ADDR_INTERVAL = 1000 * 60 * 5; // 5 minutes\nNetworkAgent.RELAY_THROTTLE = 1000 * 60 * 2; // 2 minutes\nNetworkAgent.VERSION_ATTEMPTS_MAX = 10;\nNetworkAgent.VERSION_RETRY_DELAY = 500; // 500 ms\nClass.register(NetworkAgent);\n","class PeerConnectionStatistics {\n    /**\n     * @constructor\n     */\n    constructor() {\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this._latencies = [];\n\n        /**\n         * @type {HashMap<number, number>}\n         * @private\n         */\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @returns {void}\n     */\n    reset() {\n        this._latencies = [];\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @param {number} latency\n     * @returns {void}\n     */\n    addLatency(latency) {\n        this._latencies.push(latency);\n    }\n\n    /**\n     * @param {Message} msg\n     * @returns {void}\n     */\n    addMessage(msg) {\n        this._messages.put(msg.type, this._messages.contains(msg.type) ? this._messages.get(msg.type) + 1 : 1);\n    }\n\n    /**\n     * @param {number} msgType\n     * @returns {number}\n     */\n    getMessageCount(msgType) {\n        return this._messages.contains(msgType) ? this._messages.get(msgType) : 0;\n    }\n\n    /** @type {number} */\n    get latencyMedian() {\n        const length = this._latencies.length;\n\n        if (length === 0) {\n            return 0;\n        }\n\n        this._latencies.sort((a, b) => a - b);\n        let median;\n        if ((length % 2) === 0) {\n            median = Math.round((this._latencies[(length / 2) - 1] + this._latencies[length / 2]) / 2);\n        } else {\n            median = this._latencies[(length - 1) / 2];\n        }\n        return median;\n    }\n\n}\nClass.register(PeerConnectionStatistics);\n","class PeerConnection {\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection}\n     */\n    static getOutbound(peerAddress) {\n        const peerConnection = new PeerConnection();\n        peerConnection._peerAddress = peerAddress;\n        peerConnection._state = PeerConnectionState.CONNECTING;\n        return peerConnection;\n    }\n\n    /**\n     * @param {NetworkConnection} networkConnection\n     * @returns {PeerConnection}\n     */\n    static getInbound(networkConnection) {\n        const peerConnection = new PeerConnection();\n        peerConnection._networkConnection = networkConnection;\n        return peerConnection;\n    }\n\n    /**\n     * @constructor\n     */\n    constructor() {\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = PeerConnection._instanceCount++;\n\n        /**\n         * @type {PeerAddress}\n         * @private\n         */\n        this._peerAddress = null;\n\n        // Helper Objects are added during lifecycle\n        /**\n         * @type {NetworkConnection}\n         * @private\n         */\n        this._networkConnection = null;\n \n        /**\n         * @type {PeerChannel}\n         * @private\n         */\n        this._peerChannel = null;\n\n        /**\n         * @type {NetworkAgent}\n         * @private\n         */\n        this._networkAgent = null;\n\n        /**\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        // Lifecycle state of connection\n        /**\n         * @type {number}\n         * @private\n         */\n        this._state = PeerConnectionState.NEW;\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this._closingType = null;\n\n        // Latest score given, computed by PeerScorer\n        /**\n         * @type {number}\n         * @private\n         */\n        this._score = null;\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this._establishedSince = null;\n\n        /**\n         * @type {PeerConnectionStatistics}\n         * @private\n         */\n        this._statistics = new PeerConnectionStatistics();\n    }\n\n    /** @type {number} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @param {PeerAddress} value */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetworkConnection} */\n    get networkConnection() {\n        return this._networkConnection;\n    }\n\n    /** @param {NetworkConnection} value */\n    set networkConnection(value) {\n        this._networkConnection = value;\n        this._state = PeerConnectionState.CONNECTED;\n    }\n\n    /** @type {PeerChannel} */\n    get peerChannel() {\n        return this._peerChannel;\n    }\n\n    /** @param {PeerChannel} value */\n    set peerChannel(value) {\n        this._peerChannel = value;\n    }\n\n    /** @type {NetworkAgent} */\n    get networkAgent() {\n        return this._networkAgent;\n    }\n\n    /** @param {NetworkAgent} value */\n    set networkAgent(value) {\n        this._networkAgent = value;\n        this._state = PeerConnectionState.NEGOTIATING;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @param {Peer} value */\n    set peer(value) {\n        this._peer = value;\n        this._state = PeerConnectionState.ESTABLISHED;\n        this._establishedSince = Date.now();\n\n        // start statistics\n        this._networkAgent.on('ping-pong', (latency) => this._statistics.addLatency(latency));\n        this._peerChannel.on('message-log', (msg) => this._statistics.addMessage(msg));\n    }\n\n    /** @type {number} */\n    get score() {\n        return this._score;\n    }\n\n    /** @param {number} value */\n    set score(value) {\n        this._score = value;\n    }\n\n    /** @type {number} */\n    get establishedSince() {\n        return this._establishedSince;\n    }\n\n    /** @type {number} */\n    get ageEstablished() {\n        return Date.now() - this.establishedSince;\n    }\n\n    /** @type {PeerConnectionStatistics} */\n    get statistics() {\n        return this._statistics;\n    }\n}\n// Used to generate unique PeerConnection ids.\nPeerConnection._instanceCount = 0;\nClass.register(PeerConnection);\n\nclass PeerConnectionState {\n}\nPeerConnectionState.NEW = 1;\nPeerConnectionState.CONNECTING = 2;\nPeerConnectionState.CONNECTED = 3;\nPeerConnectionState.NEGOTIATING = 4;\nPeerConnectionState.ESTABLISHED = 5;\nClass.register(PeerConnectionState);\n","class SignalProcessor {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {WebRtcConnector} rtcConnector\n     */\n    constructor(peerAddresses, networkConfig, rtcConnector) {\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {WebRtcConnector}\n         * @private\n         */\n        this._rtcConnector = rtcConnector;\n\n        /**\n         * @type {SignalStore}\n         * @private\n         */\n        this._forwards = new SignalStore();\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {SignalMessage} msg\n     * @returns {void}\n     */\n    onSignal(channel, msg) {\n        // Discard signals with invalid TTL.\n        if (msg.ttl > Network.SIGNAL_TTL_INITIAL) {\n            channel.close(CloseType.INVALID_SIGNAL_TTL, 'invalid signal ttl');\n            return;\n        }\n\n        // Discard signals that have a payload, which is not properly signed.\n        if (msg.hasPayload() && !msg.verifySignature()) {\n            channel.close(CloseType.INVALID_SIGNATURE, 'invalid signature');\n            return;\n        }\n\n        // Can be undefined for non-rtc nodes.\n        const myPeerId = this._networkConfig.peerAddress.peerId;\n\n        // Discard signals from myself.\n        if (msg.senderId.equals(myPeerId)) {\n            Log.w(SignalProcessor, `Received signal from myself to ${msg.recipientId} from ${channel.peerAddress} (myId: ${myPeerId})`);\n            return;\n        }\n\n        // If the signal has the unroutable flag set and we previously forwarded a matching signal,\n        // mark the route as unusable.\n        if (msg.isUnroutable() && this._forwards.signalForwarded(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, /*nonce*/ msg.nonce)) {\n            const senderAddr = this._addresses.getByPeerId(msg.senderId);\n            this._addresses.unroutable(channel, senderAddr);\n        }\n\n        // If the signal is intended for us, pass it on to our WebRTC connector.\n        if (msg.recipientId.equals(myPeerId)) {\n            // If we sent out a signal that did not reach the recipient because of TTL\n            // or it was unroutable, delete this route.\n            if (this._rtcConnector.isValidSignal(msg) && (msg.isUnroutable() || msg.isTtlExceeded())) {\n                const senderAddr = this._addresses.getByPeerId(msg.senderId);\n                this._addresses.unroutable(channel, senderAddr);\n            }\n            this._rtcConnector.onSignal(channel, msg);\n            return;\n        }\n\n        // Discard signals that have reached their TTL.\n        if (msg.ttl <= 0) {\n            Log.d(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - TTL reached`);\n            // Send signal containing TTL_EXCEEDED flag back in reverse direction.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.TTL_EXCEEDED);\n            }\n            return;\n        }\n\n        // Otherwise, try to forward the signal to the intended recipient.\n        const signalChannel = this._addresses.getChannelByPeerId(msg.recipientId);\n        if (!signalChannel) {\n            Log.d(SignalProcessor, `Failed to forward signal from ${msg.senderId} to ${msg.recipientId} - no route found`);\n            // If we don't know a route to the intended recipient, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Discard signal if our shortest route to the target is via the sending peer.\n        // XXX Why does this happen?\n        if (signalChannel.peerAddress.equals(channel.peerAddress)) {\n            Log.w(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - shortest route via sending peer`);\n            // If our best route is via the sending peer, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Decrement ttl and forward signal.\n        signalChannel.signal(msg.senderId, msg.recipientId, msg.nonce, msg.ttl - 1, msg.flags, msg.payload, msg.senderPubKey, msg.signature);\n\n        // We store forwarded messages if there are no special flags set.\n        if (msg.flags === 0) {\n            this._forwards.add(msg.senderId, msg.recipientId, msg.nonce);\n        }\n\n        // XXX This is very spammy!!!\n        // Log.v(Network, `Forwarding signal (ttl=${msg.ttl}) from ${msg.senderId} `\n        //     + `(received from ${channel.peerAddress}) to ${msg.recipientId} `\n        //     + `(via ${signalChannel.peerAddress})`);\n    }\n}\nClass.register(SignalProcessor);\n\nclass SignalStore {\n    /**\n     * @param {number} maxSize maximum number of entries\n     */\n    constructor(maxSize = 1000) {\n        /** @type {number} */\n        this._maxSize = maxSize;\n        /** @type {Queue.<ForwardedSignal>} */\n        this._queue = new Queue();\n        /** @type {HashMap.<ForwardedSignal, number>} */\n        this._store = new HashMap();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    add(senderId, recipientId, nonce) {\n        // If we already forwarded such a message, just update timestamp.\n        if (this.contains(senderId, recipientId, nonce)) {\n            const signal = new ForwardedSignal(senderId, recipientId, nonce);\n            this._store.put(signal, Date.now());\n            this._queue.remove(signal);\n            this._queue.enqueue(signal);\n            return;\n        }\n\n        // Delete oldest if needed.\n        if (this.length >= this._maxSize) {\n            const oldest = this._queue.dequeue();\n            this._store.remove(oldest);\n        }\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        this._queue.enqueue(signal);\n        this._store.put(signal, Date.now());\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    contains(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        return this._store.contains(signal);\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    signalForwarded(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        const lastSeen = this._store.get(signal);\n        if (!lastSeen) {\n            return false;\n        }\n        const valid = lastSeen + ForwardedSignal.SIGNAL_MAX_AGE > Date.now();\n        if (!valid) {\n            // Because of the ordering, we know that everything after that is invalid too.\n            const toDelete = this._queue.dequeueUntil(signal);\n            for (const dSignal of toDelete) {\n                this._store.remove(dSignal);\n            }\n        }\n        return valid;\n    }\n}\nSignalStore.SIGNAL_MAX_AGE = 10 /* seconds */;\nClass.register(SignalStore);\n\nclass ForwardedSignal {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    constructor(senderId, recipientId, nonce) {\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {ForwardedSignal} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof ForwardedSignal\n            && this._senderId.equals(o._senderId)\n            && this._recipientId.equals(o._recipientId)\n            && this._nonce === o._nonce;\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ForwardedSignal{senderId=${this._senderId}, recipientId=${this._recipientId}, nonce=${this._nonce}}`;\n    }\n}\nClass.register(ForwardedSignal);\n","class ConnectionPool extends Observable {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {IBlockchain} blockchain\n     * @param {Time} time\n     * @listens WebSocketConnector#connection\n     * @listens WebSocketConnector#error\n     * @listens WebRtcConnector#connection\n     * @listens WebRtcConnector#error\n     */\n    constructor(peerAddresses, networkConfig, blockchain, time) {\n        super();\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * HashMap from peerAddresses to connections.\n         * @type {HashMap.<PeerAddress, PeerConnection>}\n         * @private\n         */\n        this._connectionsByPeerAddress = new HashMap();\n        \n        /**\n         * HashMap from netAddresses to connections.\n         * @type {HashMap.<NetAddress, Array<PeerConnection>>}\n         * @private\n         */\n        this._connectionsByNetAddress = new HashMap();\n\n        // Total bytes sent/received on past connections.\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {WebSocketConnector} */\n        this._wsConnector = new WebSocketConnector(this._networkConfig);\n        this._wsConnector.on('connection', conn => this._onConnection(conn));\n        this._wsConnector.on('error', (peerAddr, e) => this._onConnectError(peerAddr, e));\n\n        /** @type {WebRtcConnector} */\n        this._rtcConnector = new WebRtcConnector(this._networkConfig);\n        this._rtcConnector.on('connection', conn => this._onConnection(conn));\n        this._rtcConnector.on('error', (peerAddr, reason) => this._onConnectError(peerAddr, reason));\n\n        // Number of WebSocket/WebRTC connections.\n        /** @type {number} */\n        this._peerCountWs = 0;\n        /** @type {number} */\n        this._peerCountRtc = 0;\n        /** @type {number} */\n        this._peerCountDumb = 0;\n        /** @type {number} */\n        this._peerCountFull = 0;\n        /** @type {number} */\n        this._peerCountLight = 0;\n        /** @type {number} */\n        this._peerCountNano = 0;\n\n        /**\n         * Number of ongoing outbound connection attempts.\n         * @type {number}\n         * @private\n         */\n        this._connectingCount = 0;\n\n        /**\n         * Number of not established inbound connections.\n         * @type {number}\n         * @private\n         */\n        this._inboundCount = 0;\n\n        /** @type {SignalProcessor} */\n        this._signalProcessor = new SignalProcessor(peerAddresses, networkConfig, this._rtcConnector);\n\n        // When true, send a signal to network to close an established connection for a incoming one\n        /** @type {boolean} */\n        this._allowInboundExchange = false;\n    }\n\n    /**\n     * @returns {Array<PeerConnection>}\n     */\n    values() {\n        return Array.from(this._connectionsByPeerAddress.values());\n    }\n\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection|null}\n     */\n    getConnectionByPeerAddress(peerAddress) {\n        return this._connectionsByPeerAddress.get(peerAddress);\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array<PeerConnection>}\n     */\n    getConnectionsByNetAddress(netAddress) {\n        return this._connectionsByNetAddress.get(netAddress) || [];\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isEstablished(peerAddress) {\n        const peerAddressState = this.getConnectionByPeerAddress(peerAddress);\n        return peerAddressState && peerAddressState.state === PeerConnectionState.ESTABLISHED;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _add(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.put(peerConnection.peerAddress, peerConnection);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _remove(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.remove(peerConnection.peerAddress);\n        }\n\n        if (peerConnection.networkConnection && peerConnection.networkConnection.netAddress) {\n            this._removeNetAddress(peerConnection, peerConnection.networkConnection.netAddress);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _addNetAddress(peerConnection, netAddress) {\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            this._connectionsByNetAddress.get(netAddress).push(peerConnection);\n        } else {\n            this._connectionsByNetAddress.put(netAddress, [peerConnection]);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _removeNetAddress(peerConnection, netAddress) {\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            const peerConnections = this._connectionsByNetAddress.get(netAddress);\n\n            const index = peerConnections.indexOf(peerConnection);\n            if (index >= 0) {\n                peerConnections.splice(index, 1);\n            }\n\n            if (peerConnections.length === 0) {\n                this._connectionsByNetAddress.remove(netAddress);\n            }\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    _hasPriority(peerAddress) {\n        return this.peerCountFull === 0 && Services.isFullNode(peerAddress.services);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    _checkOutboundConnectionRequest(peerAddress) {\n        if (peerAddress === null) {\n            return false;\n        }\n\n        if (peerAddress.protocol !== Protocol.WS && peerAddress.protocol !== Protocol.RTC) {\n            Log.e(Network, 'Cannot connect to {$this.peerAddress} - unsupported protocol');\n            return false;\n        }\n\n        if (this._addresses.isBanned(peerAddress)){\n            Log.e(Network, `Connecting to banned address ${peerAddress}`);\n            return false;\n        }\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        if (peerConnection) {\n            Log.e(Network, `Duplicate connection to ${peerAddress}`);\n            return false;\n        }\n\n        // Forbid connection if we have too many connections to the peer's IP address.\n        if (peerAddress.netAddress && !peerAddress.netAddress.isPseudo()) {\n            if (this.getConnectionsByNetAddress(peerAddress.netAddress).length > Network.PEER_COUNT_PER_IP_MAX) {\n                Log.e(ConnectionPool, `connection limit per ip (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n        }\n\n        // Reject peer if we have reached max peer count.\n        if (this.peerCount >= Network.PEER_COUNT_MAX && !this._hasPriority(peerAddress)) {\n            Log.e(ConnectionPool, `max peer count reached (${Network.PEER_COUNT_MAX})`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {NetworkConnection} conn\n     * @returns {boolean}\n     * @private\n     */\n    _checkConnection(conn) {\n        // Close connection if we have too many connections to the peer's IP address.\n        if (conn.netAddress && !conn.netAddress.isPseudo()) {\n            if (this.getConnectionsByNetAddress(conn.netAddress).length >= Network.PEER_COUNT_PER_IP_MAX) {\n                conn.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per ip (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n        }\n\n        // Reject peer if we have reached max peer count.\n        if (this.peerCount >= Network.PEER_COUNT_MAX\n            && !(conn.outbound && this._hasPriority(conn.peerAddress))\n            && !(conn.inbound && this._allowInboundExchange)) {\n\n            conn.close(CloseType.MAX_PEER_COUNT_REACHED, `max peer count reached (${Network.PEER_COUNT_MAX})`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {boolean}\n     * @private\n     */\n    _checkHandshake(peerConnection, peer) {\n        // Close connection if we are already connected to this peer.\n        if (this.isEstablished(peer.peerAddress)) {\n            peerConnection.peerChannel.close(CloseType.DUPLICATE_CONNECTION, `Duplicate connection to ${peer.peerAddress} (post-handshake)` );\n            return false;\n        }\n\n        // Close connection if this peer is banned.\n        if (this._addresses.isBanned(peer.peerAddress)) {\n            peerConnection.peerChannel.close(CloseType.PEER_IS_BANNED, `Connection with banned address ${peer.peerAddress} (post-handshake)`);\n            return false;\n        }\n\n        // Close connection if we have too many connections to the peer's IP address.\n        if (peer.netAddress && !peer.netAddress.isPseudo()) {\n            if (this.getConnectionsByNetAddress(peer.netAddress).length > Network.PEER_COUNT_PER_IP_MAX) {\n                peerConnection.peerChannel.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per ip (${Network.PEER_COUNT_PER_IP_MAX}) reached (post-handshake)`);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    connectOutbound(peerAddress) {\n        // all checks in one step\n        if (!this._checkOutboundConnectionRequest(peerAddress)){\n            return false;\n        }\n\n        // Connection request accepted.\n\n        // create fresh PeerConnection instance\n        const peerConnection = PeerConnection.getOutbound(peerAddress);\n        this._add(peerConnection);\n\n        // choose connector type and call\n        let connecting = false;\n        if (peerAddress.protocol === Protocol.WS) {\n            connecting = this._wsConnector.connect(peerAddress);\n        } else {\n            const signalChannel = this._addresses.getChannelByPeerId(peerAddress.peerId);\n            connecting = this._rtcConnector.connect(peerAddress, signalChannel);\n        }\n\n        if (connecting) {\n            this._connectingCount++;\n        } else {\n            this._remove(peerConnection);\n            Log.d(Network, `Outbound attempt not connecting: ${peerAddress}`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @listens PeerChannel#signal\n     * @listens NetworkAgent#handshake\n     * @listens NetworkAgent#close\n     * @fires ConnectionPool#connection\n     * @param {NetworkConnection} conn\n     * @returns {void}\n     * @private\n     */\n    _onConnection(conn) {\n        let peerConnection;\n        if (conn.outbound) {\n            this._connectingCount--;\n\n            peerConnection = this.getConnectionByPeerAddress(conn.peerAddress);\n\n            Assert.that(peerConnection, `Connecting to outbound peer address not stored ${conn.peerAddress}`);\n            Assert.that(peerConnection.state === PeerConnectionState.CONNECTING,\n                `PeerConnection state not CONNECTING ${conn.peerAddress}`);\n        } else {\n            peerConnection = PeerConnection.getInbound(conn);\n            this._inboundCount++;\n        }\n\n        // Set peerConnection to CONNECTED state.\n        peerConnection.networkConnection = conn;\n\n        // Register close listener early to clean up correctly in case _checkConnection() closes the connection.\n        conn.on('close', (type, reason) => this._onClose(peerConnection, type, reason));\n\n        if (!this._checkConnection(conn)) {\n            return;\n        }\n\n        // Connection accepted.\n\n        if (conn.netAddress && !conn.netAddress.isPseudo()) {\n            this._addNetAddress(peerConnection, conn.netAddress);\n        }\n\n        const connType = conn.inbound ? 'inbound' : 'outbound';\n        Log.d(ConnectionPool, `Connection established (${connType}) #${conn.id} ${conn.netAddress || conn.peerAddress || '<pending>'}`);\n\n        // Let listeners know about this connection.\n        this.fire('connection', conn);\n\n        // Create peer channel.\n        const channel = new PeerChannel(conn);\n        channel.on('signal', msg => this._signalProcessor.onSignal(channel, msg));\n \n        peerConnection.peerChannel = channel;\n\n        // Create network agent.\n        const agent = new NetworkAgent(this._blockchain, this._addresses, this._networkConfig, channel);\n        agent.on('version', peer => this._checkHandshake(peerConnection, peer));\n        agent.on('handshake', peer => this._onHandshake(peerConnection, peer));\n\n        // Set peerConnection to NEGOTIATING state.\n        peerConnection.networkAgent = agent;\n\n        // Initiate handshake with the peer.\n        agent.handshake();\n    }\n\n    /**\n     * Handshake with this peer was successful.\n     * @fires ConnectionPool#peer-joined\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#recyling-request\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {void}\n     * @private\n     */\n    _onHandshake(peerConnection, peer) {\n        // Handshake accepted.\n\n        // Check if we need to recycle a connection.\n        if (this.peerCount >= Network.PEER_COUNT_MAX) {\n            this.fire('recycling-request');\n        }\n\n        if (peerConnection.networkConnection.inbound) {\n            peerConnection.peerAddress = peer.peerAddress;\n            this._add(peerConnection);\n            this._inboundCount--;\n        }\n\n        // Set peerConnection to ESTABLISHED state.\n        peerConnection.peer = peer;\n\n        if (peer.netAddress && !peer.netAddress.isPseudo() && this.getConnectionsByNetAddress(peer.netAddress).indexOf(peerConnection) < 0) {\n            this._addNetAddress(peerConnection, peer.netAddress);\n        }\n \n        this._updateConnectedPeerCount(peer.peerAddress, 1);\n\n        this._addresses.established(peer.channel, peer.peerAddress);\n\n        // Let listeners know about this peer.\n        this.fire('peer-joined', peer);\n\n        // Let listeners know that the peers changed.\n        this.fire('peers-changed');\n\n        Log.d(ConnectionPool, () => `[PEER-JOINED] ${peer.peerAddress} ${peer.netAddress} (version=${peer.version}, services=${peer.peerAddress.services}, headHash=${peer.headHash.toBase64()})`);\n    }\n\n    /**\n     * This peer channel was closed.\n     * @param {PeerConnection} peerConnection\n     * @param {number} type\n     * @param {string} reason\n     * @fires ConnectionPool#peer-left\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#close\n     * @returns {void}\n     * @private\n     */\n    _onClose(peerConnection, type, reason) {\n        // Update total bytes sent/received.\n        this._bytesSent += peerConnection.networkConnection.bytesSent;\n        this._bytesReceived +=  peerConnection.networkConnection.bytesReceived;\n\n        if (peerConnection.peerAddress) {\n            this._addresses.close(peerConnection.peerChannel, peerConnection.peerAddress, type);\n        }\n\n        this._remove(peerConnection);\n\n        // Check if the handshake with this peer has completed.\n        if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n            this._updateConnectedPeerCount(peerConnection.peerAddress, -1);\n\n            // Tell listeners that this peer has gone away.\n            this.fire('peer-left', peerConnection.peer);\n\n            // Let listeners know that the peers changed.\n            this.fire('peers-changed');\n\n            const kbTransferred = ((peerConnection.networkConnection.bytesSent\n                + peerConnection.networkConnection.bytesReceived) / 1000).toFixed(2);\n            Log.d(ConnectionPool, `[PEER-LEFT] ${peerConnection.peerAddress} ${peerConnection.peer.netAddress} `\n                + `(version=${peerConnection.peer.version}, transferred=${kbTransferred} kB, closingType=${type} ${reason})`);\n        } else {\n            if (peerConnection.networkConnection.inbound) {\n                this._inboundCount--;\n                Log.w(ConnectionPool, `Inbound connection closed pre-handshake: ${reason} (${type})`);\n            } else {\n                Log.w(ConnectionPool, `Connection to ${peerConnection.peerAddress} closed pre-handshake: ${reason} (${type})`);\n                this.fire('connect-error', peerConnection.peerAddress, `${reason} (${type})`);\n            }\n        }\n\n        // Let listeners know about this closing.\n        this.fire('close', peerConnection, type, reason);\n    }\n\n    /**\n     * Connection to this peer address failed.\n     * @param {PeerAddress} peerAddress\n     * @param {string|*} [reason]\n     * @fires ConnectionPool#connect-error\n     * @returns {void}\n     * @private\n     */\n    _onConnectError(peerAddress, reason) {\n        Log.w(ConnectionPool, `Connection to ${peerAddress} failed` + (typeof reason === 'string' ? ` - ${reason}` : ''));\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        Assert.that(peerConnection && peerConnection.state === PeerConnectionState.CONNECTING);\n        this._remove(peerConnection);\n\n        this._connectingCount--;\n\n        this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n\n        this.fire('connect-error', peerAddress, reason);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {number} delta\n     * @returns {void}\n     * @private\n     */\n    _updateConnectedPeerCount(peerAddress, delta) {\n        switch (peerAddress.protocol) {\n            case Protocol.WS:\n                this._peerCountWs += delta;\n                break;\n            case Protocol.RTC:\n                this._peerCountRtc += delta;\n                break;\n            case Protocol.DUMB:\n                this._peerCountDumb += delta;\n                break;\n            default:\n                Log.w(PeerAddressBook, `Unknown protocol ${peerAddress.protocol}`);\n        }\n\n        if (Services.isFullNode(peerAddress.services)) {\n            this._peerCountFull += delta;\n        } else if (Services.isLightNode(peerAddress.services)) {\n            this._peerCountLight += delta;\n        } else {\n            this._peerCountNano += delta;\n        }\n    }\n\n\n    /**\n     * @param {string|*} reason\n     * @returns {void}\n     */\n    disconnect(reason) {\n        // Close all active connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel) {\n                connection.peerChannel.close(CloseType.MANUAL_NETWORK_DISCONNECT, reason || 'manual network disconnect');\n            }\n        }\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        // Close all websocket connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel && connection.peerAddress && connection.peerAddress.protocol === Protocol.WS) {\n                connection.channel.close(CloseType.MANUAL_WEBSOCKET_DISCONNECT, 'manual websocket disconnect');\n            }\n        }\n    }\n\n\n    /** @type {number} */\n    get peerCountWs() {\n        return this._peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountRtc() {\n        return this._peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._peerCountWs + this._peerCountRtc + this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountFull() {\n        return this._peerCountFull;\n    }\n\n    /** @type {number} */\n    get peerCountLight() {\n        return this._peerCountLight;\n    }\n\n    /** @type {number} */\n    get peerCountNano() {\n        return this._peerCountNano;\n    }\n\n    /** @type {number} */\n    get connectingCount() {\n        return this._connectingCount;\n    }\n\n    /** @type {number} */\n    get count() {\n        return this._connectionsByPeerAddress.length + this._inboundCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesSent : 0), 0);\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesReceived : 0), 0);\n    }\n\n    /** @param {boolean} value */\n    set allowInboundExchange(value) {\n        this._allowInboundExchange = value;\n    }\n\n}\nClass.register(ConnectionPool);\n","class PeerScorer extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerAddressBook} addresses\n     * @param {ConnectionPool} connections\n     */\n    constructor(networkConfig, addresses, connections) {\n        super();\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = addresses;\n\n        /**\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = connections;\n\n        /**\n         * @type {Array<PeerConnection>}\n         * @private\n         */\n        this._connectionScores = null;\n    }\n\n    /**\n     * @returns {?PeerAddress}\n     */\n    pickAddress() {\n        const addresses = this._addresses.values();\n        const numAddresses = addresses.length;\n\n        // Pick a random start index.\n        const index = Math.floor(Math.random() * numAddresses);\n\n        // Score up to 1000 addresses starting from the start index and pick the\n        // one with the highest score. Never pick addresses with score < 0.\n        const minCandidates = Math.min(numAddresses, 1000);\n        const candidates = new HashMap();\n        for (let i = 0; i < numAddresses; i++) {\n            const idx = (index + i) % numAddresses;\n            const address = addresses[idx];\n            const score = this._scoreAddress(address);\n            if (score >= 0) {\n                candidates.put(score, address);\n                if (candidates.length >= minCandidates) {\n                    break;\n                }\n            }\n        }\n\n        if (candidates.length === 0) {\n            return null;\n        }\n\n        // Return the candidate with the highest score.\n        const scores = candidates.keys().sort((a, b) => b - a);\n        const winner = candidates.get(scores[0]);\n        return winner.peerAddress;\n    }\n\n    /**\n     * @param {PeerAddressState} peerAddressState\n     * @returns {number}\n     * @private\n     */\n    _scoreAddress(peerAddressState) {\n        const peerAddress = peerAddressState.peerAddress;\n\n        // Filter addresses that we cannot connect to.\n        if (!this._networkConfig.canConnect(peerAddress.protocol)) {\n            return -1;\n        }\n\n        // Filter addresses that are too old.\n        if (peerAddress.exceedsAge()) {\n            return -1;\n        }\n\n        // a channel to that peer address is CONNECTING, CONNECTED, NEGOTIATING OR ESTABLISHED\n        if (this._connections.getConnectionByPeerAddress(peerAddress)) {\n            return -1;\n        }\n\n        // Filter addresses that are too old.\n        if (peerAddress.exceedsAge()) {\n            return -1;\n        }\n\n        // (protocol + services) * age\n        const score = (this._scoreProtocol(peerAddress) + this._scoreServices(peerAddress))\n            * ((peerAddress.timestamp / 1000) + 1);\n\n        switch (peerAddressState.state) {\n            case PeerAddressState.BANNED:\n                return -1;\n\n            case PeerAddressState.NEW:\n            case PeerAddressState.TRIED:\n                return score;\n\n            case PeerAddressState.FAILED:\n                // Don't pick failed addresses when they have failed the maximum number of times.\n                return (1 - ((peerAddressState.failedAttempts + 1) / peerAddressState.maxFailedAttempts)) * score;\n\n            default:\n                return -1;\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {number}\n     * @private\n     */\n    _scoreProtocol(peerAddress) {\n        let score = 1;\n\n        // We want at least two websocket connection\n        if (this._connections.peerCountWs < 2) {\n            score *= peerAddress.protocol === Protocol.WS ? 3 : 1;\n        } else {\n            score *= peerAddress.protocol === Protocol.RTC ? 3 : 1;\n        }\n\n        // Prefer WebRTC addresses with lower distance:\n        //  distance = 0: self\n        //  distance = 1: direct connection\n        //  distance = 2: 1 hop\n        //  ...\n        // We only expect distance >= 2 here.\n        if (peerAddress.protocol === Protocol.RTC) {\n            score *= 1 + ((PeerAddressBook.MAX_DISTANCE - peerAddress.distance) / 2);\n        }\n\n        return score;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {number}\n     * @private\n     */\n    _scoreServices(peerAddress) {\n        if (this._connections.peerCount > 2 && this._connections.peerCountFull === 0 && Services.isFullNode(peerAddress.services)) {\n            return 10;\n        }\n        return 0;\n    }\n\n    /**\n     * @returns {void}\n     */\n    scoreConnections() {\n        const candidates = [];\n\n        for (const peerConnection of this._connections.values()) {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                // Grant new connections a grace period from recycling.\n                if (peerConnection.ageEstablished > PeerScorer._getMinAge(peerConnection.peerAddress)) {\n                    peerConnection.score = this._scoreConnection(peerConnection);\n                    candidates.push(peerConnection);\n                }\n\n                peerConnection.statistics.reset();\n            }\n        }\n\n        // sort by score\n        this._connectionScores = candidates.sort((a, b) => b.score - a.score);\n    }\n\n    /**\n     * @param {number} count\n     * @param {number} type\n     * @param {string} reason\n     * @returns {void}\n     */\n    recycleConnections(count, type, reason) {\n        if (!this._connectionScores) {\n            return;\n        }\n\n        while (count > 0 && this._connectionScores.length > 0) {\n            const peerConnection = this._connectionScores.pop();\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                peerConnection.peerChannel.close(type, `${reason}`);\n                count--;\n            }\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnection(peerConnection) {\n        const scoreAge = this._scoreConnectionAge(peerConnection);\n\n        // Connection type\n        const scoreType = peerConnection.networkConnection.inbound ? 0 : 1;\n\n        // Protocol, when low on Websocket connections, give it some aid\n        const distribution = this._connections.peerCountWs / this._connections.peerCount;\n        let scoreProtocol = 0;\n        if (distribution < PeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION) {\n            if (peerConnection.peerAddress.protocol === Protocol.WS) {\n                scoreProtocol = 1;\n            }\n        }\n\n        // Connection speed, based on ping-pong latency median\n        const medianDelay = peerConnection.statistics.latencyMedian;\n        let scoreSpeed = 0;\n        if (medianDelay > 0 && medianDelay < NetworkAgent.PING_TIMEOUT) {\n            scoreSpeed = 1 - medianDelay / NetworkAgent.PING_TIMEOUT;\n        }\n\n        return 0.4 * scoreAge + 0.2 * scoreType + 0.2 * scoreProtocol + 0.2 * scoreSpeed;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnectionAge(peerConnection) {\n        const score = (age, bestAge, maxAge) => Math.max(Math.min(1 - (age - bestAge) / maxAge, 1), 0);\n\n        const age = peerConnection.ageEstablished;\n        const services = peerConnection.peerAddress.services;\n        if (Services.isFullNode(services)) {\n            return age / (2 * PeerScorer.BEST_AGE_FULL) + 0.5;\n        } else if (Services.isLightNode(services)) {\n            return score(age, PeerScorer.BEST_AGE_LIGHT, PeerScorer.MAX_AGE_LIGHT);\n        } else {\n            return score(age, PeerScorer.BEST_AGE_NANO, PeerScorer.MAX_AGE_NANO);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {number}\n     * @private\n     */\n    static _getMinAge(peerAddress) {\n        if (Services.isFullNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_FULL;\n        } else if (Services.isLightNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_LIGHT;\n        } else {\n            return PeerScorer.MIN_AGE_NANO;\n        }\n    }\n\n    /** @type {Array.<PeerConnection>|null} */\n    get connectionScores() {\n        return this._connectionScores;\n    }\n\n    /** @type {number|null} */\n    get lowestConnectionScore() {\n        return this._connectionScores && this._connectionScores.length > 0\n            ? this._connectionScores[this._connectionScores.length - 1].score\n            : null;\n    }\n}\nPeerScorer.MIN_AGE_FULL = 5 * 60 * 1000; // 5 minutes\nPeerScorer.BEST_AGE_FULL = 24 * 60 * 60 * 1000; // 24 hours\n\nPeerScorer.MIN_AGE_LIGHT = 2 * 60 * 1000; // 2 minutes\nPeerScorer.BEST_AGE_LIGHT = 15 * 60 * 1000; // 15 minutes\nPeerScorer.MAX_AGE_LIGHT = 6 * 60 * 60 * 1000; // 6 hours\n\nPeerScorer.MIN_AGE_NANO = 60 * 1000; // 1 minute\nPeerScorer.BEST_AGE_NANO = 5 * 60 * 1000; // 5 minutes\nPeerScorer.MAX_AGE_NANO = 30 * 60 * 1000; // 30 minutes\n\nPeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION = 0.15; // 15%\n\nClass.register(PeerScorer);\n","class NetworkConfig {\n    /**\n     * @returns {NetworkConfig}\n     */\n    static getDefault() {\n        return PlatformUtils.supportsWebRTC()\n            ? new RtcNetworkConfig()\n            : new DumbNetworkConfig();\n    }\n\n    /**\n     * @constructor\n     * @param {number} protocolMask\n     */\n    constructor(protocolMask) {\n        /** @type {number} */\n        this._protocolMask = protocolMask;\n\n        /**\n         * @type {KeyPair}\n         * @protected\n         */\n        this._keyPair = null;\n\n        /**\n         * @type {PeerId}\n         * @protected\n         */\n        this._peerId = null;\n\n        /**\n         * @type {Services}\n         * @protected\n         */\n        this._services = null;\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initPersistent() {\n        const db = await PeerKeyStore.getPersistent();\n        await this._init(db);\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initVolatile() {\n        const db = PeerKeyStore.createVolatile();\n        await this._init(db);\n    }\n\n    /**\n     * @private\n     * @param {PeerKeyStore} db\n     * @returns {void}\n     */\n    async _init(db) {\n        if (this._keyPair) {\n            return;\n        }\n\n        /** @type {KeyPair} */\n        let keys = await db.get('keys');\n        if (!keys) {\n            keys = KeyPair.generate();\n            await db.put('keys', keys);\n        }\n\n        this._keyPair = keys;\n        this._peerId = keys.publicKey.toPeerId();\n    }\n\n    /**\n     * Used for filtering peer addresses by protocols.\n     * @type {number}\n     */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /**\n     * @type {KeyPair}\n     */\n    get keyPair() {\n        return this._keyPair;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /**\n     * @type {PeerId}\n     */\n    get peerId() {\n        return this._peerId;\n    }\n\n    /**\n     * @type {Services}\n     */\n    get services() {\n        return this._services;\n    }\n\n    /**\n     * @param {Services} services\n     */\n    set services(services) {\n        this._services = services;\n    }\n\n    /**\n     * @type {PeerAddress}\n     */\n    get peerAddress() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {number} protocol\n     * @returns {boolean}\n     */\n    canConnect(protocol) {\n        return (protocol & this._protocolMask) !== 0;\n    }\n}\n\nClass.register(NetworkConfig);\n\nclass WsNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     * @param {string} host\n     * @param {number} port\n     * @param {string} key\n     * @param {string} cert\n     */\n    constructor(host, port, key, cert) {\n        super(Protocol.WS);\n        this._host = host;\n        this._port = port;\n        this._key = key;\n        this._cert = cert;\n\n        /* @type {{key: string, cert: string}} */\n        this._sslConfig = {\n            key: this._key,\n            cert: this._cert\n        };\n    }\n\n    /**\n     * @type {{key: string, cert: string}}\n     */\n    get sslConfig() {\n        return this._sslConfig;\n    }\n\n    /**\n     * @type {WsPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new WsPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0,\n            this._host, this._port);\n\n        if (!peerAddress.globallyReachable()) {\n            throw 'PeerAddress not globally reachable.';\n        }\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(WsNetworkConfig);\n\nclass RtcNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS | Protocol.RTC);\n        this._rtcConfig = {\n            iceServers: [\n                {urls: 'stun:stun.l.google.com:19302'},\n                {urls: 'stun:stun.nimiq-network.com:19302'}\n            ]\n        };\n    }\n\n    /**\n     * @returns {?RTCConfiguration}\n     */\n    get rtcConfig() {\n        return this._rtcConfig;\n    }\n\n    /**\n     * @type {RtcPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new RtcPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(RtcNetworkConfig);\n\nclass DumbNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS);\n    }\n\n    /**\n     * @type {DumbPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new DumbPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(DumbNetworkConfig);\n","class Network extends Observable {\n    /**\n     * @constructor\n     * @param {IBlockchain} blockchain\n     * @param {NetworkConfig} networkConfig\n     * @param {Time} time\n     * @listens PeerAddressBook#added\n     * @listens ConnectionPool#peer-joined\n     * @listens ConnectionPool#peer-left\n     * @listens ConnectionPool#peers-changed\n     * @listens ConnectionPool#recycling-request\n     * @listens ConnectionPool#connect-error\n     */\n    constructor(blockchain, networkConfig, time) {\n        super();\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * Flag indicating whether we should actively connect to other peers\n         * if our peer count is below PEER_COUNT_DESIRED.\n         * @type {boolean}\n         * @private\n         */\n        this._autoConnect = false;\n\n        /**\n         * Backoff for peer count check in seconds.\n         * @type {number}\n         * @private\n         */\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n\n        /**\n         * Flag indicating whether we already triggered a backoff.\n         * @type {boolean}\n         * @private\n         */\n        this._backedOff = false;\n\n        /**\n         * The network's addressbook\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = new PeerAddressBook(this._networkConfig);\n\n        // Relay new addresses to peers.\n        this._addresses.on('added', addresses => {\n            this._relayAddresses(addresses);\n            this._checkPeerCount();\n        });\n       \n        /**\n         * Peer connections database & operator\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = new ConnectionPool(this._addresses, networkConfig, blockchain, time);\n\n        this._connections.on('peer-joined', peer => this._onPeerJoined(peer));\n        this._connections.on('peer-left', peer => this._onPeerLeft(peer));\n        this._connections.on('peers-changed', () => this._onPeersChanged());\n        this._connections.on('recycling-request', () => this._onRecyclingRequest());\n        this._connections.on('connect-error', () => this._checkPeerCount());\n\n        /**\n         * Helper object to pick PeerAddressBook.\n         * @type {PeerScorer}\n         * @private\n         */\n        this._scorer = new PeerScorer(this._networkConfig, this._addresses, this._connections);\n\n        /**\n         * @type {number|null}\n         * @private\n         */\n        this._houseKeepingIntervalId = null;\n    }       \n\n    connect() {\n        this._autoConnect = true;\n\n        // Setup housekeeping interval.\n        this._houseKeepingIntervalId = setInterval(() => this._housekeeping(), Network.HOUSEKEEPING_INTERVAL);\n\n        // Start connecting to peers.\n        this._checkPeerCount();\n    }\n\n    /**\n     * @param {string|*} reason\n     */\n    disconnect(reason) {\n        this._autoConnect = false;\n\n        // Clear housekeeping interval.\n        clearInterval(this._houseKeepingIntervalId);\n\n        this._connections.disconnect(reason);\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        this._autoConnect = false;\n\n        this._connections.disconnectWebSocket();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @fires Network#peer-joined\n     */\n    _onPeerJoined(peer){\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        // Tell others about the address that we just connected to.\n        this._relayAddresses([peer.peerAddress]);\n\n        this.fire('peer-joined', peer);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @fires Network#peer-left\n     */\n    _onPeerLeft(peer) {\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        this.fire('peer-left', peer);\n    }\n\n    /**\n     * @fires Network#peers-changed\n     */\n    _onPeersChanged() {\n        this._checkPeerCount();\n\n        this.fire('peers-changed');\n    }\n\n    _onRecyclingRequest() {\n        this._scorer.recycleConnections(1, CloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE, 'Peer connection recycled inbound exchange');\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @returns {void}\n     * @private\n     */\n    _relayAddresses(addresses) {\n        // Pick PEER_COUNT_RELAY random peers and relay addresses to them if:\n        // - number of addresses <= 10\n        // TODO more restrictions, see Bitcoin\n        if (addresses.length > 10) {\n            return;\n        }\n\n        // XXX We don't protect against picking the same peer more than once.\n        // The NetworkAgent will take care of not sending the addresses twice.\n        // In that case, the address will simply be relayed to less peers. Also,\n        // the peer that we pick might already know the address.\n        const peerConnections = this._connections.values();\n        for (let i = 0; i < Network.PEER_COUNT_RELAY; ++i) {\n            const peerConnection = ArrayUtils.randomElement(peerConnections);\n            if (peerConnection && peerConnection.state === PeerConnectionState.ESTABLISHED && peerConnection.networkAgent) {\n                peerConnection.networkAgent.relayAddresses(addresses);\n            }\n        }\n    }\n\n    _checkPeerCount() {\n        if (this._autoConnect\n            && (this._connections.count < Network.PEER_COUNT_DESIRED || this._connections.peerCountFull === 0)\n            && this._connections.connectingCount < Network.CONNECTING_COUNT_MAX) {\n\n            // Pick a peer address that we are not connected to yet.\n            const peerAddress = this._scorer.pickAddress();\n\n            // We can't connect if we don't know any more addresses.\n            if (!peerAddress) {\n                // If no backoff has been triggered, trigger one.\n                // This helps us to check back whether we need more connections.\n                if (!this._backedOff) {\n                    this._backedOff = true;\n                    const oldBackoff = this._backoff;\n                    this._backoff = Math.min(Network.CONNECT_BACKOFF_MAX, oldBackoff * 2);\n                    setTimeout(() => {\n                        this._backedOff = false;\n                        this._checkPeerCount();\n                    }, oldBackoff);\n\n                    // If we are not connected to any peers (anymore), tell listeners that we are disconnected\n                    // and have given up on trying to connect for the time being. This is primarily useful for tests.\n                    if (this._connections.count === 0) {\n                        this.fire('disconnected');\n                    }\n                }\n\n                return;\n            }\n\n            // Connect to this address.\n            if (!this._connections.connectOutbound(peerAddress)) {\n                this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n                setTimeout(() => this._checkPeerCount(), 0);\n            }\n        }\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n    }\n\n    /**\n     * Updates the network time offset by calculating the median offset\n     * from all our peers.\n     * @returns {void}\n     * @private\n     */\n    _updateTimeOffset() {\n        const peerConnections = this._connections.values();\n\n        const offsets = [0]; // Add our own offset.\n        peerConnections.forEach(peerConnection => {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                offsets.push(peerConnection.networkAgent.peer.timeOffset);\n            }\n        });\n\n        const offsetsLength = offsets.length;\n        offsets.sort((a, b) => a - b);\n\n        let timeOffset;\n        if ((offsetsLength % 2) === 0) {\n            timeOffset = Math.round((offsets[(offsetsLength / 2) - 1] + offsets[offsetsLength / 2]) / 2);\n        } else {\n            timeOffset = offsets[(offsetsLength - 1) / 2];\n        }\n\n        this._time.offset = Math.max(Math.min(timeOffset, Network.TIME_OFFSET_MAX), -Network.TIME_OFFSET_MAX);\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        this._scorer.scoreConnections();\n\n        // recycle\n        if (this.peerCount > Network.PEER_COUNT_RECYCLING_ACTIVE) {\n            // recycle 1% at PEER_COUNT_RECYCLING_ACTIVE, 20% at PEER_COUNT_MAX\n            const percentageToRecycle = (this.peerCount - Network.PEER_COUNT_RECYCLING_ACTIVE) * 0.19 / (Network.PEER_COUNT_MAX - Network.PEER_COUNT_RECYCLING_ACTIVE) + 0.01;\n            const connectionsToRecycle = Math.ceil(this.peerCount * percentageToRecycle);\n            this._scorer.recycleConnections(connectionsToRecycle, CloseType.PEER_CONNECTION_RECYCLED, 'Peer connection recycled');\n        }\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /** @type {Time} */\n    get time() {\n        return this._time;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._connections.peerCount;\n    }\n\n    /** @type {number} */\n    get peerCountWebSocket() {\n        return this._connections.peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountWebRtc() {\n        return this._connections.peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._connections.peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountConnecting() {\n        return this._connections.connectingCount;\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._addresses.knownAddressesCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._connections.bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._connections.bytesReceived;\n    }\n}\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_MAX = PlatformUtils.isBrowser() ? 15 : 50000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_PER_IP_MAX = PlatformUtils.isBrowser() ? 2 : 25;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RECYCLING_ACTIVE = PlatformUtils.isBrowser() ? 5 : 1000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_DESIRED = 6;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RELAY = 4;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECTING_COUNT_MAX = 2;\n/**\n * @type {number}\n * @constant\n */\nNetwork.SIGNAL_TTL_INITIAL = 3;\n/**\n * @type {number}\n * @constant\n */\nNetwork.ADDRESS_UPDATE_DELAY = 1000; // 1 second\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_INITIAL = 1000; // 1 second\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_MAX = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.TIME_OFFSET_MAX = 15 * 60 * 1000; // 15 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.HOUSEKEEPING_INTERVAL = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.SCORE_INBOUND_EXCHANGE = 0.5;\nClass.register(Network);\n","class NetUtils {\n    /**\n     * @param {string} ip\n     * @return {boolean}\n     */\n    static isPrivateIP(ip) {\n        if (NetUtils.isLocalIP(ip)) {\n            return true;\n        }\n\n        if (NetUtils.isIPv4Address(ip)) {\n            for (const subnet of NetUtils.IPv4_PRIVATE_NETWORK) {\n                if (NetUtils.isIPv4inSubnet(ip, subnet)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            const parts = ip.toLowerCase().split(':');\n            const isEmbeddedIPv4 = NetUtils.isIPv4Address(parts[parts.length - 1]);\n            if (isEmbeddedIPv4) {\n                return NetUtils.isPrivateIP(parts[parts.length - 1]);\n            }\n\n            // Private subnet is fc00::/7.\n            // So, we only check the first 7 bits of the address to be equal fc00.\n            // The mask shifts by 16-7=9 bits (one part - mask size).\n            if ((parseInt(parts[0], 16) & (-1<<9)) === 0xfc00) {\n                return true;\n            }\n\n            // Link-local addresses are fe80::/10.\n            // Shifting has to be carried out by 16-10=6 bits.\n            if ((parseInt(parts[0], 16) & (-1<<6)) === 0xfe80) {\n                return true;\n            }\n\n            // Does not seem to be a private IP.\n            return false;\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {string} ip\n     * @returns {boolean}\n     */\n    static isLocalIP(ip) {\n        const saneIp = NetUtils._normalizeIP(ip);\n        if (NetUtils.isIPv4Address(ip)) {\n            return saneIp === '127.0.0.1';\n        } else {\n            return saneIp === '::1';\n        }\n    }\n\n    /**\n     * @param {string} ip\n     * @param {string} subnet\n     * @return {boolean}\n     */\n    static isIPv4inSubnet(ip, subnet) {\n        let [subIp, mask] = subnet.split('/');\n        mask = -1<<(32-parseInt(mask));\n        return (NetUtils._IPv4toLong(ip) & mask) === NetUtils._IPv4toLong(subIp);\n    }\n\n    /**\n     * @param {string} ip\n     * @return {boolean}\n     */\n    static isIPv4Address(ip) {\n        const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        return !!match && parseInt(match[1]) <= 255 && parseInt(match[2]) <= 255\n            && parseInt(match[3]) <= 255 && parseInt(match[4]) <= 255;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {boolean}\n     */\n    static isIPv6Address(ip) {\n        const parts = ip.toLowerCase().split(':');\n        // An IPv6 address consists of at most 8 parts and at least 3.\n        if (parts.length > 8 || parts.length < 3) {\n            return false;\n        }\n\n        const isEmbeddedIPv4 = NetUtils.isIPv4Address(parts[parts.length - 1]);\n\n        let innerEmpty = false;\n        for (let i = 0; i < parts.length; ++i) {\n            // Check whether each part is valid.\n            // Note: the last part may be a IPv4 address!\n            // They can be embedded in the last part. Remember that they take 32bit.\n            if (!(/^[a-f0-9]{0,4}$/.test(parts[i])\n                    || (i === parts.length - 1\n                        && isEmbeddedIPv4\n                        && parts.length < 8))) {\n                return false;\n            }\n            // Inside the parts, there has to be at most one empty part.\n            if (parts[i].length === 0 && i > 0 && i < parts.length - 1) {\n                if (innerEmpty) {\n                    return false; // at least two empty parts\n                }\n                innerEmpty = true;\n            }\n        }\n\n        // In the special case of embedded IPv4 addresses, everything but the last 48 bit must be 0.\n        if (isEmbeddedIPv4) {\n            // Exclude the last two parts.\n            for (let i=0; i<parts.length-2; ++i) {\n                if (!/^0{0,4}$/.test(parts[i])) {\n                    return false;\n                }\n            }\n        }\n\n        // If the first part is empty, the second has to be empty as well (e.g., ::1).\n        if (parts[0].length === 0) {\n            return parts[1].length === 0;\n        }\n\n        // If the last part is empty, the second last has to be empty as well (e.g., 1::).\n        if (parts[parts.length - 1].length === 0) {\n            return parts[parts.length - 2].length === 0;\n        }\n\n        // If the length is less than 7 and an IPv4 address is embedded, there has to be an empty part.\n        if (isEmbeddedIPv4 && parts.length < 7) {\n            return innerEmpty;\n        }\n\n        // Otherwise if the length is less than 8, there has to be an empty part.\n        if (parts.length < 8) {\n            return innerEmpty;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {string}\n     */\n    static sanitizeIP(ip) {\n        const saneIp = NetUtils._normalizeIP(ip);\n        // FIXME\n        if (NetUtils.IP_BLACKLIST.indexOf(saneIp) >= 0) {\n            throw `Malformed IP address ${ip}`;\n        }\n        // TODO reject IPv6 broadcast addresses\n        return saneIp;\n    }\n\n    /**\n     * @param {string} host\n     * @returns {boolean}\n     */\n    static hostGloballyReachable(host) {\n        // IP addresses can't have a proper certificate\n        if (NetUtils.isIPv4Address(host) || NetUtils.isIPv6Address(host)) {\n            return false;\n        }\n        // \"the use of dotless domains is prohibited [in new gTLDs]\" [ https://www.icann.org/resources/board-material/resolutions-new-gtld-2013-08-13-en#1 ]. Old gTLDs rarely use them.\n        if (!host.match(/.+\\..+$/)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {string}\n     */\n    static _normalizeIP(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            // Re-create IPv4 address to strip possible leading zeros.\n            // Embed into IPv6 format.\n            const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n            return `${parseInt(match[1])}.${parseInt(match[2])}.${parseInt(match[3])}.${parseInt(match[4])}`;\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            // Shorten IPv6 address according to RFC 5952.\n\n            // Only use lower-case letters.\n            ip = ip.toLowerCase();\n\n            // Split into parts.\n            const parts = ip.split(':');\n\n            // Return normalized IPv4 address if embedded.\n            if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n                return NetUtils._normalizeIP(parts[parts.length - 1]);\n            }\n\n            // If it is already shortened at one point, blow it up again.\n            // It may be the case, that the current shortening is not as described in the RFC.\n            const emptyIndex = parts.indexOf('');\n            if (emptyIndex >= 0) {\n                parts[emptyIndex] = '0';\n                // Also check parts before and after emptyIndex and fill them up if necessary.\n                if (emptyIndex > 0 && parts[emptyIndex-1] === '') {\n                    parts[emptyIndex-1] = '0';\n                }\n                if (emptyIndex < parts.length - 1 && parts[emptyIndex+1] === '') {\n                    parts[emptyIndex+1] = '0';\n                }\n\n                // Add 0s until we have a normal IPv6 length.\n                const necessaryAddition = 8-parts.length;\n                for (let i=0; i<necessaryAddition; ++i) {\n                    parts.splice(emptyIndex, 0, '0');\n                }\n            }\n\n            let maxZeroSeqStart = -1;\n            let maxZeroSeqLength = 0;\n            let curZeroSeqStart = -1;\n            let curZeroSeqLength = 1;\n            for (let i = 0; i < parts.length; ++i) {\n                // Remove leading zeros from each part, but keep at least one number.\n                parts[i] = parts[i].replace(/^0+([a-f0-9])/, '$1');\n\n                // We look for the longest, leftmost consecutive sequence of zero parts.\n                if (parts[i] === '0') {\n                    // Freshly started sequence.\n                    if (curZeroSeqStart < 0) {\n                        curZeroSeqStart = i;\n                    } else {\n                        // Known sequence, so increment length.\n                        curZeroSeqLength++;\n                    }\n                } else {\n                    // A sequence just ended, check if it is of better length.\n                    if (curZeroSeqStart >= 0 && curZeroSeqLength > maxZeroSeqLength) {\n                        maxZeroSeqStart = curZeroSeqStart;\n                        maxZeroSeqLength = curZeroSeqLength;\n                        curZeroSeqStart = -1;\n                        curZeroSeqLength = 1;\n                    }\n                }\n            }\n\n            if (curZeroSeqStart >= 0 && curZeroSeqLength > maxZeroSeqLength) {\n                maxZeroSeqStart = curZeroSeqStart;\n                maxZeroSeqLength = curZeroSeqLength;\n            }\n\n            // Remove consecutive zeros.\n            if (maxZeroSeqStart >= 0 && maxZeroSeqLength > 1) {\n                if (maxZeroSeqLength === parts.length) {\n                    return '::';\n                } else if (maxZeroSeqStart === 0 || maxZeroSeqStart + maxZeroSeqLength === parts.length) {\n                    parts.splice(maxZeroSeqStart, maxZeroSeqLength, ':');\n                } else {\n                    parts.splice(maxZeroSeqStart, maxZeroSeqLength, '');\n                }\n            }\n\n            return parts.join(':');\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {number}\n     */\n    static _IPv4toLong(ip) {\n        const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        return (parseInt(match[1])<<24) + (parseInt(match[2])<<16) + (parseInt(match[3])<<8) + (parseInt(match[4]));\n    }\n}\nNetUtils.IP_BLACKLIST = [\n    '0.0.0.0',\n    '255.255.255.255',\n    '::',\n];\nNetUtils.IPv4_PRIVATE_NETWORK = [\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '100.64.0.0/10', // link-local\n\n    // Actually, the following one is only an approximation,\n    // the first and the last /24 subnets in the range should be excluded.\n    '169.254.0.0/16'\n];\nClass.register(NetUtils);\n","class PeerKeyStore {\n    /**\n     * @returns {Promise.<PeerKeyStore>}\n     */\n    static async getPersistent() {\n        if (!PeerKeyStore._instance) {\n            const jdb = new JDB.JungleDB('peer-key', PeerKeyStore.VERSION);\n\n            // Initialize object stores.\n            jdb.createObjectStore(PeerKeyStore.KEY_DATABASE, new PeerKeyStoreCodec());\n\n            // Establish connection to database.\n            await jdb.connect();\n\n            PeerKeyStore._instance = new PeerKeyStore(jdb.getObjectStore(PeerKeyStore.KEY_DATABASE));\n        }\n        return PeerKeyStore._instance;\n    }\n\n    /**\n     * @returns {PeerKeyStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new PeerKeyStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {string} key\n     * @returns {Promise.<KeyPair>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @param {string} key\n     * @param {KeyPair} keyPair\n     * @returns {Promise}\n     */\n    put(key, keyPair) {\n        return this._store.put(key, keyPair);\n    }\n}\nPeerKeyStore._instance = null;\nPeerKeyStore.VERSION = 2;\nPeerKeyStore.KEY_DATABASE = 'keys';\nClass.register(PeerKeyStore);\n\n/**\n * @implements {ICodec}\n */\nclass PeerKeyStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return KeyPair.unserialize(new SerialBuffer(buf));\n    }\n\n    /**\n     * @type {string}\n     */\n    get valueEncoding() {\n        return 'binary';\n    }\n}\n","class Peer {\n    /**\n     * @param {PeerChannel} channel\n     * @param {number} version\n     * @param {Hash} headHash\n     * @param {number} timeOffset\n     */\n    constructor(channel, version, headHash, timeOffset) {\n        /** @type {PeerChannel} */\n        this._channel = channel;\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /**\n         * Offset between the peer's time and our local time.\n         * @type {number}\n         */\n        this._timeOffset = timeOffset;\n\n        this._setNetAddress();\n    }\n\n    /**\n     * @private\n     * @returns {void}\n     */\n    _setNetAddress() {\n        // If the connector was able the determine the peer's netAddress, update the peer's advertised netAddress.\n        if (this.channel.netAddress) {\n            // TODO What to do if it doesn't match the currently advertised one?\n            if (this.peerAddress.netAddress && !this.peerAddress.netAddress.equals(this.channel.netAddress)) {\n                Log.w(Peer, `Got different netAddress ${this.channel.netAddress} for ${this.peerAddress} `\n                    + `- advertised was ${this.peerAddress.netAddress}`);\n            }\n\n            // Only set the advertised netAddress if we have the public IP of the peer.\n            // WebRTC connectors might return local IP addresses for peers on the same LAN.\n            if (!this.channel.netAddress.isPrivate()) {\n                this.peerAddress.netAddress = this.channel.netAddress;\n            }\n        }\n        // Otherwise, use the netAddress advertised for this peer if available.\n        else if (this.channel.peerAddress.netAddress) {\n            this.channel.netAddress = this.channel.peerAddress.netAddress;\n        }\n        // Otherwise, we don't know the netAddress of this peer. Use a pseudo netAddress.\n        else {\n            this.channel.netAddress = NetAddress.UNKNOWN;\n        }\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {number} */\n    get timeOffset() {\n        return this._timeOffset;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._channel.id;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._channel.peerAddress;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._channel.netAddress;\n    }\n\n    /**\n     * @param {Peer} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Peer\n            && this._channel.equals(o.channel);\n    }\n\n    hashCode() {\n        return this._channel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Peer{version=${this._version}, headHash=${this._headHash}, `\n            + `peerAddress=${this.peerAddress}, netAddress=${this.netAddress}}`;\n    }\n}\nClass.register(Peer);\n","class Miner extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Address} minerAddress\n     * @param {Uint8Array} [extraData=new Uint8Array(0)]\n     *\n     * @listens Mempool#transaction-added\n     * @listens Mempool#transaction-ready\n     */\n    constructor(blockchain, accounts, mempool, time, minerAddress, extraData = new Uint8Array(0)) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n        /** @type {Time} */\n        this._time = time;\n        /** @type {Address} */\n        this._address = minerAddress;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n\n        /**\n         * Number of hashes computed since the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._hashCount = 0;\n\n        /**\n         * Timestamp of the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._lastHashrate = 0;\n\n        /**\n         * Hashrate computation interval handle.\n         * @private\n         */\n        this._hashrateWorker = null;\n\n        /**\n         * The current hashrate of this miner.\n         * @type {number}\n         * @private\n         */\n        this._hashrate = 0;\n\n        /**\n         * The last hash counts used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastHashCounts = [];\n\n        /**\n         * The total hashCount used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalHashCount = 0;\n\n        /**\n         * The time elapsed for the last measurements used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastElapsed = [];\n\n        /**\n         * The total time elapsed used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalElapsed = 0;\n\n        /** @type {MinerWorkerPool} */\n        this._workerPool = new MinerWorkerPool();\n\n        if (typeof navigator === 'object' && navigator.hardwareConcurrency) {\n            this.threads = Math.ceil(navigator.hardwareConcurrency / 2);\n        } else if (PlatformUtils.isNodeJs()) {\n            const cores = require('os').cpus().length;\n            this.threads = Math.ceil(cores / 2);\n            if (cores === 1) this.throttleAfter = 2;\n        } else {\n            this.threads = 1;\n        }\n        this._workerPool.on('share', (obj) => this._onWorkerShare(obj));\n        this._workerPool.on('no-share', (obj) => this._onWorkerShare(obj));\n\n        /**\n         * Flag indicating that the mempool has changed since we started mining the current block.\n         * @type {boolean}\n         * @private\n         */\n        this._mempoolChanged = false;\n\n        /** @type {boolean} */\n        this._restarting = false;\n\n        /** @type {number} */\n        this._lastRestart = 0;\n\n        /** @type {boolean} */\n        this._submittingBlock = false;\n\n        // Listen to changes in the mempool which evicts invalid transactions\n        // after every blockchain head change and then fires 'transactions-ready'\n        // when the eviction process finishes. Restart work on the next block\n        // with fresh transactions when this fires.\n        this._mempool.on('transactions-ready', () => this._startWork());\n\n        // Immediately start processing transactions when they come in.\n        this._mempool.on('transaction-added', () => this._mempoolChanged = true);\n    }\n\n    startWork() {\n        if (this.working) {\n            return;\n        }\n\n        // Initialize hashrate computation.\n        this._hashCount = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n        this._lastHashrate = Date.now();\n        this._hashrateWorker = setInterval(() => this._updateHashrate(), 1000);\n        this._retry = 0;\n\n        // Tell listeners that we've started working.\n        this.fire('start', this);\n\n        // Kick off the mining process.\n        this._startWork().catch(Log.w.tag(Miner));\n    }\n\n    async _startWork() {\n        // XXX Needed as long as we cannot unregister from transactions-ready events.\n        if (!this.working || this._restarting) {\n            return;\n        }\n        try {\n            this._lastRestart = Date.now();\n            this._restarting = true;\n            this._mempoolChanged = false;\n\n            // Construct next block.\n            this._retry = 0;\n            const block = await this.getNextBlock();\n\n            Log.i(Miner, `Starting work on ${block.header}, transactionCount=${block.transactionCount}, hashrate=${this._hashrate} H/s`);\n\n            this._workerPool.startMiningOnBlock(block).catch(Log.w.tag(Miner));\n        } catch (e) {\n            Log.w(Miner, 'Failed to start work, retrying in 100ms');\n            this.stopWork();\n            setTimeout(() => this.startWork(), 100);\n        } finally {\n            this._restarting = false;\n        }\n    }\n\n    /**\n     * @param {{hash: Hash, nonce: number, block: Block}} obj\n     * @private\n     */\n    async _onWorkerShare(obj) {\n        this._hashCount += this._workerPool.noncesPerRun;\n        if (obj.block && obj.block.prevHash.equals(this._blockchain.headHash)) {\n            Log.d(Miner, () => `Received share: ${obj.nonce} / ${obj.hash.toHex()}`);\n            if (BlockUtils.isProofOfWork(obj.hash, obj.block.target) && !this._submittingBlock) {\n                obj.block.header.nonce = obj.nonce;\n                this._submittingBlock = true;\n                if (await obj.block.header.verifyProofOfWork()) {\n                    // Tell listeners that we've mined a block.\n                    this.fire('block-mined', obj.block, this);\n\n                    // Push block into blockchain.\n                    if ((await this._blockchain.pushBlock(obj.block)) < 0) {\n                        this._submittingBlock = false;\n                        this._startWork().catch(Log.w.tag(Miner));\n                        return;\n                    } else {\n                        this._submittingBlock = false;\n                    }\n                } else {\n                    Log.d(Miner, `Ignoring invalid share: ${await obj.block.header.pow()}`);\n                }\n            }\n        }\n        if (this._mempoolChanged && this._lastRestart + Miner.MIN_TIME_ON_BLOCK < Date.now()) {\n            this._startWork().catch(Log.w.tag(Miner));\n        }\n    }\n\n    /**\n     * @return {Promise.<Block>}\n     * @private\n     */\n    async getNextBlock() {\n        this._retry++;\n        try {\n            const nextTarget = await this._blockchain.getNextTarget();\n            const interlink = await this._getNextInterlink(nextTarget);\n            const body = await this._getNextBody(interlink.serializedSize);\n            const header = await this._getNextHeader(nextTarget, interlink, body);\n            if ((await this._blockchain.getNextTarget()) !== nextTarget) return this.getNextBlock();\n            return new Block(header, interlink, body);\n        } catch (e) {\n            // Retry up to three times.\n            if (this._retry <= 3) return this.getNextBlock();\n            throw e;\n        }\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} body\n     * @return {Promise.<BlockHeader>}\n     * @private\n     */\n    async _getNextHeader(nextTarget, interlink, body) {\n        const prevHash = this._blockchain.headHash;\n        const interlinkHash = interlink.hash();\n        const height = this._blockchain.height + 1;\n\n        // Compute next accountsHash.\n        const accounts = await this._accounts.transaction();\n        let accountsHash;\n        try {\n            await accounts.commitBlockBody(body, height, this._blockchain.transactionCache);\n            accountsHash = await accounts.hash();\n            await accounts.abort();\n        } catch (e) {\n            await accounts.abort();\n            throw new Error(`Invalid block body: ${e.message}`);\n        }\n\n        const bodyHash = body.hash();\n        const timestamp = this._getNextTimestamp();\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        const nonce = 0;\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce);\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @returns {Promise.<BlockInterlink>}\n     * @private\n     */\n    _getNextInterlink(nextTarget) {\n        return this._blockchain.head.getNextInterlink(nextTarget);\n    }\n\n    /**\n     * @param {number} interlinkSize\n     * @return {BlockBody}\n     * @private\n     */\n    async _getNextBody(interlinkSize) {\n        const maxSize = Policy.BLOCK_SIZE_MAX\n            - BlockHeader.SERIALIZED_SIZE\n            - interlinkSize\n            - BlockBody.getMetadataSize(this._extraData);\n        const transactions = await this._mempool.getTransactionsForBlock(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        return new BlockBody(this._address, transactions, this._extraData, prunedAccounts);\n    }\n\n    /**\n     * @return {number}\n     * @private\n     */\n    _getNextTimestamp() {\n        const now = Math.floor(this._time.now() / 1000);\n        return Math.max(now, this._blockchain.head.timestamp + 1);\n    }\n\n    /**\n     * @fires Miner#stop\n     */\n    stopWork() {\n        // TODO unregister from blockchain head-changed events.\n        if (!this.working) {\n            return;\n        }\n\n        clearInterval(this._hashrateWorker);\n        this._hashrateWorker = null;\n        this._hashrate = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n\n        // Tell listeners that we've stopped working.\n        this._workerPool.stop();\n        this.fire('stop', this);\n\n        Log.i(Miner, 'Stopped work');\n    }\n\n    /**\n     * @fires Miner#hashrate-changed\n     * @private\n     */\n    _updateHashrate() {\n        const elapsed = (Date.now() - this._lastHashrate) / 1000;\n        const hashCount = this._hashCount;\n        // Enable next measurement.\n        this._hashCount = 0;\n        this._lastHashrate = Date.now();\n\n        // Update stored information on moving average.\n        this._lastElapsed.push(elapsed);\n        this._lastHashCounts.push(hashCount);\n        this._totalElapsed += elapsed;\n        this._totalHashCount += hashCount;\n\n        if (this._lastElapsed.length > Miner.MOVING_AVERAGE_MAX_SIZE) {\n            const oldestElapsed = this._lastElapsed.shift();\n            const oldestHashCount = this._lastHashCounts.shift();\n            this._totalElapsed -= oldestElapsed;\n            this._totalHashCount -= oldestHashCount;\n        }\n\n        this._hashrate = Math.round(this._totalHashCount / this._totalElapsed);\n\n        // Tell listeners about our new hashrate.\n        this.fire('hashrate-changed', this._hashrate, this);\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return !!this._hashrateWorker;\n    }\n\n    /** @type {number} */\n    get hashrate() {\n        return this._hashrate;\n    }\n\n    /** @type {number} */\n    get threads() {\n        return this._workerPool.poolSize;\n    }\n\n    /**\n     * @param {number} threads\n     */\n    set threads(threads) {\n        this._workerPool.poolSize = threads;\n    }\n\n    /** @type {number} */\n    get throttleWait() {\n        return this._workerPool.cycleWait;\n    }\n\n    /**\n     * @param {number} throttleWait\n     */\n    set throttleWait(throttleWait) {\n        this._workerPool.cycleWait = throttleWait;\n    }\n\n    /** @type {number} */\n    get throttleAfter() {\n        return this._workerPool.runsPerCycle;\n    }\n\n    /**\n     * @param {number} throttleAfter\n     */\n    set throttleAfter(throttleAfter) {\n        this._workerPool.runsPerCycle = throttleAfter;\n    }\n}\n\nMiner.MIN_TIME_ON_BLOCK = 10000;\nMiner.MOVING_AVERAGE_MAX_SIZE = 10;\nClass.register(Miner);\n","class Wallet {\n    /**\n     * Create a new Wallet.\n     * @returns {Promise.<Wallet>} Newly created Wallet.\n     */\n    static async generate() {\n        await Crypto.prepareSyncCryptoWorker();\n        return new Wallet(KeyPair.generate());\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {Wallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n        return new Wallet(KeyPair.unserialize(new SerialBuffer(buf)));\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<Wallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return new Wallet(await KeyPair.fromEncrypted(new SerialBuffer(buf), key));\n    }\n\n    /**\n     * Create a new Wallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @returns {Wallet} A newly generated Wallet.\n     */\n    constructor(keyPair) {\n        /** @type {KeyPair} */\n        this._keyPair = keyPair;\n        /** @type {Address} */\n        this._address = this._keyPair.publicKey.toAddress();\n    }\n\n    /**\n     * Create a Transaction that is signed by the owner of this Wallet.\n     * @param {Address} recipient Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared and signed Transaction object. This still has to be sent to the network.\n     */\n    createTransaction(recipient, value, fee, validityStartHeight) {\n        const transaction = new BasicTransaction(this._keyPair.publicKey, recipient, value, fee, validityStartHeight);\n        transaction.signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());\n        return transaction;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        return this._keyPair.serialize();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        return this._keyPair.exportEncrypted(key, unlockKey);\n    }\n\n    /** @type {boolean} */\n    get isLocked() {\n        return this.keyPair.isLocked;\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    lock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.lock(key);\n    }\n\n    relock() {\n        this.keyPair.relock();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    unlock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.unlock(key);\n    }\n\n    /**\n     * @param {Wallet} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Wallet && this.keyPair.equals(o.keyPair) && this.address.equals(o.address);\n    }\n\n    /**\n     * The address of the Wallet owner.\n     * @type {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * The public key of the Wallet owner\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /** @type {KeyPair} */\n    get keyPair() {\n        return this._keyPair;\n    }\n}\n\nClass.register(Wallet);\n","class MultiSigWallet extends Wallet {\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all owners' public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    static fromPublicKeys(keyPair, minSignatures, publicKeys) {\n        if (publicKeys.length === 0) throw new Error('publicKeys may not be empty');\n        if (minSignatures <= 0) throw new Error('minSignatures must be greater than 0');\n        if (!publicKeys.some(key => key.equals(keyPair.publicKey))) throw new Error('Own publicKey must be part of publicKeys');\n\n        // Sort public keys so that the order when signing and construction does not matter.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        const combinations = [...ArrayUtils.k_combinations(publicKeys, minSignatures)];\n        const multiSigKeys = combinations.map(arr => PublicKey.sum(arr));\n        return new MultiSigWallet(keyPair, minSignatures, multiSigKeys);\n    }\n\n    /**\n     * @param {KeyPair} keyPair\n     * @param {SerialBuffer} buf\n     * @returns {MultiSigWallet}\n     * @private\n     */\n    static _loadMultiSig(keyPair, buf) {\n        const minSignatures = buf.readUint8();\n        const numPublicKeys = buf.readUint8();\n        const publicKeys = [];\n        for (let i = 0; i < numPublicKeys; ++i) {\n            publicKeys.push(PublicKey.unserialize(buf));\n        }\n        return new MultiSigWallet(keyPair, minSignatures, publicKeys);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {MultiSigWallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = KeyPair.unserialize(serialBuf);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<MultiSigWallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = await KeyPair.fromEncrypted(serialBuf, key);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all aggregated public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    constructor(keyPair, minSignatures, publicKeys) {\n        super(keyPair);\n        /** @type {number} minSignatures */\n        this._minSignatures = minSignatures;\n        /** @type {Array.<PublicKey>} publicKeys */\n        this._publicKeys = publicKeys;\n        this._publicKeys.sort((a, b) => a.compare(b));\n\n        const merkleRoot = MerkleTree.computeRoot(this._publicKeys);\n        /** @type {Address} */\n        this._address = Address.fromHash(merkleRoot);\n    }\n\n    /**\n     * @override\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        const buf = new SerialBuffer(this.exportedSize);\n        this._keyPair.serialize(buf);\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        const buf = new SerialBuffer(this.encryptedExportedSize);\n        buf.write(await this._keyPair.exportEncrypted(key, unlockKey));\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedExportedSize() {\n        return this._keyPair.encryptedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /** @type {number} */\n    get exportedSize() {\n        return this._keyPair.serializedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /**\n     * Create a Transaction that still needs to be signed.\n     * @param {Address} recipientAddr Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared Transaction object.\n     * @override\n     */\n    createTransaction(recipientAddr, value, fee, validityStartHeight) {\n        return new ExtendedTransaction(this._address, Account.Type.BASIC,\n            recipientAddr, Account.Type.BASIC, value, fee, validityStartHeight,\n            Transaction.Flag.NONE, new Uint8Array(0));\n    }\n\n    /**\n     * Creates a commitment pair for signing a transaction.\n     * @returns {CommitmentPair} The commitment pair.\n     */\n    createCommitment() {\n        return CommitmentPair.generate();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Commitment} aggregatedCommitment\n     * @param {RandomSecret} secret\n     * @returns {PartialSignature}\n     */\n    signTransaction(transaction, publicKeys, aggregatedCommitment, secret) {\n        // Sort public keys to get the right combined public key.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n\n        return PartialSignature.create(this._keyPair.privateKey, this._keyPair.publicKey, publicKeys,\n            secret, aggregatedCommitment, transaction.serializeContent());\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {PublicKey} aggregatedPublicKey\n     * @param {Commitment} aggregatedCommitment\n     * @param {Array.<PartialSignature>} signatures\n     * @returns {Transaction}\n     */\n    completeTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {\n        if (signatures.length !== this._minSignatures) {\n            throw 'Not enough signatures to complete this transaction';\n        }\n\n        const signature = Signature.fromPartialSignatures(aggregatedCommitment, signatures);\n        const proof = SignatureProof.multiSig(aggregatedPublicKey, this._publicKeys, signature);\n        transaction.proof = proof.serialize();\n        return transaction;\n    }\n\n    /** @type {number} */\n    get minSignatures() {\n        return this._minSignatures;\n    }\n\n    /** @type {Array.<PublicKey>} */\n    get publicKeys() {\n        return this._publicKeys;\n    }\n}\nClass.register(MultiSigWallet);\n","// TODO: Move outside of Nimiq Core library?\nclass WalletStore {\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    constructor(dbName = 'wallet') {\n        this._jdb = new JDB.JungleDB(dbName, WalletStore.VERSION);\n        /** @type {ObjectStore} */\n        this._walletStore = null;\n        /** @type {ObjectStore} */\n        this._multiSigStore = null;\n\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    async _init() {\n        // Initialize object stores.\n        this._walletStore = this._jdb.createObjectStore(WalletStore.WALLET_DATABASE, new WalletStoreCodec());\n        this._multiSigStore = this._jdb.createObjectStore(WalletStore.MULTISIG_WALLET_DATABASE, new WalletStoreCodec());\n\n        // Establish connection to database.\n        await this._jdb.connect();\n\n        return this;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async hasDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        return !!defaultAddress;\n    }\n\n    /**\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?Wallet>}\n     */\n    async getDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        if (!defaultAddress) {\n            const defaultWallet = await Wallet.generate();\n            await this.put(defaultWallet);\n            await this.setDefault(defaultWallet.address);\n            return defaultWallet;\n        }\n        const base64Address = new Address(defaultAddress);\n        return this.get(base64Address, key);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    setDefault(address) {\n        const defaultAddress = address.serialize();\n        return this._walletStore.put('default', defaultAddress);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<Wallet>}\n     */\n    async get(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._walletStore.get(base64Address);\n        if (key) {\n            return Wallet.loadEncrypted(buf, key);\n        }\n        return Wallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {Wallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async put(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._walletStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    async remove(address) {\n        const base64Address = address.toBase64();\n        const tx = this._walletStore.transaction();\n        await tx.remove(base64Address);\n        // Remove default address as well if they coincide.\n        let defaultAddress = await this._walletStore.get('default');\n        if (defaultAddress) {\n            defaultAddress = new Address(defaultAddress);\n            if (address.equals(defaultAddress)) {\n                await tx.remove('default');\n            }\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async list() {\n        const keys = await this._walletStore.keys();\n        return Array.from(keys).filter(key => key !== 'default').map(key => Address.fromBase64(key));\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<MultiSigWallet>}\n     */\n    async getMultiSig(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._multiSigStore.get(base64Address);\n        if (key) {\n            return MultiSigWallet.loadEncrypted(buf, key);\n        }\n        return MultiSigWallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {MultiSigWallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async putMultiSig(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._multiSigStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    removeMultiSig(address) {\n        const base64Address = address.toBase64();\n        return this._multiSigStore.remove(base64Address);\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async listMultiSig() {\n        const keys = await this._multiSigStore.keys();\n        return Array.from(keys).map(key => Address.fromBase64(key));\n    }\n\n    close() {\n        return this._jdb.close();\n    }\n}\nClass.register(WalletStore);\nWalletStore._instance = null;\nWalletStore.VERSION = 1;\nWalletStore.WALLET_DATABASE = 'wallets';\nWalletStore.MULTISIG_WALLET_DATABASE = 'multisig-wallets';\n\n/**\n * @implements {ICodec}\n */\nclass WalletStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj;\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @type {string}\n     */\n    get valueEncoding() {\n        return 'binary';\n    }\n}\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof IWorker._moduleLoadedCallbacks[module] === 'function') {\n            IWorker._moduleLoadedCallbacks[module]();\n            IWorker._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} script\n             * @returns {Promise.<boolean>}\n             */\n            importScript(script) {\n                return this._invoke('importScript', [script]);\n            }\n\n            /**\n             * @param {string} wasm\n             * @param {string} module\n             * @returns {Promise.<boolean>}\n             */\n            importWasm(wasm, module = 'Module') {\n                return this._invoke('importWasm', [wasm, module]);\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            importScript(script, module = 'Module') {\n                if (module && IWorker._global[module] && IWorker._global[module].asm) return false;\n                if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n                if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n\n                const moduleSettings = IWorker._global[module] || {};\n                return new Promise(async (resolve, reject) => {\n                    if (module) {\n                        switch (typeof moduleSettings.preRun) {\n                            case 'undefined':\n                                moduleSettings.preRun = () => resolve(true);\n                                break;\n                            case 'function':\n                                moduleSettings.preRun = [moduleSettings, () => resolve(true)];\n                                break;\n                            case 'object':\n                                moduleSettings.preRun.push(() => resolve(true));\n                        }\n                    }\n                    if (typeof importScripts === 'function') {\n                        await new Promise((resolve) => {\n                            IWorker._moduleLoadedCallbacks[module] = resolve;\n                            importScripts(script);\n                        });\n                        IWorker._global[module] = IWorker._global[module](moduleSettings);\n                        if (!module) resolve(true);\n                    } else if (typeof window === 'object') {\n                        await new Promise((resolve) => {\n                            IWorker._loadBrowserScript(script, resolve);\n                        });\n                        IWorker._global[module] = IWorker._global[module](moduleSettings);\n                        if (!module) resolve(true);\n                    } else if (typeof require === 'function') {\n                        IWorker._global[module] = require(script)(moduleSettings);\n                        if (!module) resolve(true);\n                    } else {\n                        reject('No way to load scripts.');\n                    }\n                });\n            }\n\n            /**\n             * @param {string} wasm\n             * @param {string} module\n             * @returns {Promise.<boolean>}\n             */\n            importWasm(wasm, module = 'Module') {\n                if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n                if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n                if (!IWorker._global.WebAssembly) {\n                    Log.w(IWorker, 'No support for WebAssembly available.');\n                    return Promise.resolve(false);\n                }\n\n                return new Promise((resolve) => {\n                    try {\n                        if (PlatformUtils.isNodeJs()) {\n                            const toUint8Array = function (buf) {\n                                const u = new Uint8Array(buf.length);\n                                for (let i = 0; i < buf.length; ++i) {\n                                    u[i] = buf[i];\n                                }\n                                return u;\n                            };\n                            const fs = require('fs');\n                            fs.readFile(wasm, (err, data) => {\n                                if (err) {\n                                    Log.w(IWorker, `Failed to access WebAssembly module ${wasm}: ${err}`);\n                                    resolve(false);\n                                } else {\n                                    IWorker._global[module] = IWorker._global[module] || {};\n                                    IWorker._global[module].wasmBinary = toUint8Array(data);\n                                    resolve(true);\n                                }\n                            });\n                        } else {\n                            const xhr = new XMLHttpRequest();\n                            xhr.open('GET', wasm, true);\n                            xhr.responseType = 'arraybuffer';\n                            xhr.onload = function () {\n                                IWorker._global[module] = IWorker._global[module] || {};\n                                IWorker._global[module].wasmBinary = xhr.response;\n                                resolve(true);\n                            };\n                            xhr.onerror = function () {\n                                Log.w(IWorker, `Failed to access WebAssembly module ${wasm}`);\n                                resolve(false);\n                            };\n                            xhr.send(null);\n                        }\n                    } catch (e) {\n                        Log.w(IWorker, `Failed to access WebAssembly module ${wasm}`);\n                        resolve(false);\n                    }\n                });\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","/**\n * @interface\n */\nclass CryptoWorker {\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeBlake2b(input) {}\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeSha256(input) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param privateKey\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeyDerive(privateKey) {}\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {Promise.<{commitment:Uint8Array, secret:Uint8Array}>}\n     */\n    async commitmentCreate(randomness) {}\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Promise.<Uint8Array>}\n     */\n    async scalarsAdd(a, b) {}\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Promise.<Uint8Array>}\n     */\n    async commitmentsAggregate(commitments) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeysHash(publicKeys) {}\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeyDelinearize(publicKey, publicKeysHash) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {}\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Promise.<Uint8Array>}\n     */\n    async delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {}\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Promise.<Uint8Array>}\n     */\n    async signatureCreate(privateKey, publicKey, message) {}\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {Promise.<bool>}\n     */\n    async signatureVerify(publicKey, message, signature) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash) {}\n}\nCryptoWorker.ARGON2_HASH_SIZE = 32;\nCryptoWorker.BLAKE2_HASH_SIZE = 32;\nCryptoWorker.SHA256_HASH_SIZE = 32;\nCryptoWorker.PUBLIC_KEY_SIZE = 32;\nCryptoWorker.PRIVATE_KEY_SIZE = 32;\nCryptoWorker.MULTISIG_RANDOMNESS_SIZE = 32;\nCryptoWorker.SIGNATURE_SIZE = 64;\nCryptoWorker.PARTIAL_SIGNATURE_SIZE = 32;\nCryptoWorker.SIGNATURE_HASH_SIZE = 64;\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        if (IWorker._insideWebWorker) {\n            Crypto._workerSync = this;\n            Crypto._workerAsync = this;\n        }\n        await this._superInit.call(this, name);\n\n        if (await this.importWasm('worker-wasm.wasm')) {\n            await this.importScript('worker-wasm.js');\n        } else {\n            await this.importScript('worker-js.js');\n        }\n\n        const memoryStart = Module._get_static_memory_start();\n        const memorySize = Module._get_static_memory_size();\n        if (memorySize < CryptoWorker.PUBLIC_KEY_SIZE + CryptoWorker.PRIVATE_KEY_SIZE + CryptoWorker.SIGNATURE_SIZE) {\n            throw Error('Static memory too small');\n        }\n        let byteOffset = memoryStart;\n        this._pubKeyPointer = byteOffset;\n        this._pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.PUBLIC_KEY_SIZE);\n        byteOffset += CryptoWorker.PUBLIC_KEY_SIZE;\n        this._privKeyPointer = byteOffset;\n        this._privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.PRIVATE_KEY_SIZE);\n        byteOffset += CryptoWorker.PRIVATE_KEY_SIZE;\n        this._signaturePointer = byteOffset;\n        this._signatureBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.SIGNATURE_SIZE);\n        byteOffset += CryptoWorker.SIGNATURE_SIZE;\n        this._messagePointer = byteOffset;\n        this._messageBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, (memoryStart + memorySize) - byteOffset);\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeBlake2b(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.BLAKE2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.BLAKE2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.BLAKE2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const stackTmp = Module.stackSave();\n            for(const input of inputs) {\n                Module.stackRestore(stackTmp);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n                hashes.push(hash);\n            }\n            return hashes;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeSha256(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.SHA256_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n            const hash = new Uint8Array(CryptoWorker.SHA256_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.SHA256_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(key.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n            const wasmSalt = Module.stackAlloc(salt.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n            const res = Module._nimiq_kdf(wasmOut, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    publicKeyDerive(privateKey) {\n        const publicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n        if (privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._privKeyBuffer.set(privateKey);\n        Module._ed25519_public_key_derive(this._pubKeyPointer, this._privKeyPointer);\n        this._privKeyBuffer.fill(0);\n        publicKey.set(this._pubKeyBuffer);\n        return publicKey;\n    }\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {{commitment:Uint8Array, secret:Uint8Array}}\n     */\n    commitmentCreate(randomness) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOutCommitment = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmOutSecret = Module.stackAlloc(CryptoWorker.PRIVATE_KEY_SIZE);\n            const wasmIn = Module.stackAlloc(randomness.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);\n            const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);\n            if (res !== 1) {\n                throw new Error(`Secret must not be 0 or 1: ${res}`);\n            }\n            const commitment = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            const secret = new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);\n            commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, CryptoWorker.PUBLIC_KEY_SIZE));\n            secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, CryptoWorker.PRIVATE_KEY_SIZE));\n            return {commitment, secret};\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    scalarsAdd(a, b) {\n        if (a.byteLength !== CryptoWorker.PARTIAL_SIGNATURE_SIZE || b.byteLength !== CryptoWorker.PARTIAL_SIGNATURE_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOutSum = Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            const wasmInA = Module.stackAlloc(a.length);\n            const wasmInB = Module.stackAlloc(b.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n            Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n            const sum = new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, CryptoWorker.PARTIAL_SIGNATURE_SIZE));\n            return sum;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    commitmentsAggregate(commitments) {\n        if (commitments.some(commitment => commitment.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedCommitments = new Uint8Array(commitments.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < commitments.length; ++i) {\n            concatenatedCommitments.set(commitments[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);\n            Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);\n            const aggCommitments = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return aggCommitments;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.SIGNATURE_HASH_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n            const hashedPublicKey = new Uint8Array(CryptoWorker.SIGNATURE_HASH_SIZE);\n            hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.SIGNATURE_HASH_SIZE));\n            return hashedPublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n            const delinearizedPublicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return delinearizedPublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n            const aggregatePublicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return aggregatePublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {\n        if (privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);\n            const delinearizedPrivateKey = new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);\n            delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PRIVATE_KEY_SIZE));\n            return delinearizedPrivateKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)\n            || privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || secret.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || aggregateCommitment.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInSecret = Module.stackAlloc(secret.length);\n            const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);\n            const wasmInMessage = Module.stackAlloc(message.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);\n            Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);\n            const partialSignature = new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PARTIAL_SIGNATURE_SIZE));\n            return partialSignature;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    signatureCreate(privateKey, publicKey, message) {\n        const signature = new Uint8Array(CryptoWorker.SIGNATURE_SIZE);\n        const messageLength = message.byteLength;\n        if (messageLength > this._messageBuffer.byteLength\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._messageBuffer.set(message);\n        this._pubKeyBuffer.set(publicKey);\n        this._privKeyBuffer.set(privateKey);\n        Module._ed25519_sign(this._signaturePointer, this._messagePointer, messageLength,\n            this._pubKeyPointer, this._privKeyPointer);\n        this._privKeyBuffer.fill(0);\n        signature.set(this._signatureBuffer);\n        return signature;\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    signatureVerify(publicKey, message, signature) {\n        const messageLength = message.byteLength;\n        if (signature.byteLength !== CryptoWorker.SIGNATURE_SIZE\n            || message.byteLength > this._messageBuffer.byteLength\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._signatureBuffer.set(signature);\n        this._messageBuffer.set(message);\n        this._pubKeyBuffer.set(publicKey);\n        return !!Module._ed25519_verify(this._signaturePointer, this._messagePointer, messageLength,\n            this._pubKeyPointer);\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash) {\n        // XXX Create a stub genesis block within the worker.\n        if (!Block.GENESIS) {\n            Block.GENESIS = { HASH: Hash.unserialize(new SerialBuffer(genesisHash)) };\n        }\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n","/**\n * @interface\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","class MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n\n        if (await this.importWasm('worker-wasm.wasm')) {\n            await this.importScript('worker-wasm.js');\n        } else {\n            await this.importScript('worker-js.js');\n        }\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n *\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            const nimiq_node = require(`${__dirname}/nimiq_node`);\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    nimiq_node.nimiq_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await Crypto.argon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact = block.nBits) {\n        this._block = block;\n        this._shareCompact = shareCompact;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","// Print stack traces to the console.\nError.prototype.toString = function () {\n    return this.stack;\n};\n\n// Don't exit on uncaught exceptions.\nprocess.on('uncaughtException', (err) => {\n    // Blacklist unsupressable WebSocket errors.\n    const message = err.message;\n    if (message\n        && (\n            message.startsWith('connect E')\n            || message === \"Cannot read property 'aborted' of null\")\n        ) {\n        return;\n    }\n\n    console.error(`Uncaught exception: ${err.message || err}`, err);\n});\n"]}